"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-stdlib";
exports.ids = ["vendor-chunks/three-stdlib"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/constants.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst version = parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"));\n //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7QUFDakMsTUFBTUMsVUFBVUMsU0FBU0YsMkNBQVFBLENBQUNHLE9BQU8sQ0FBQyxRQUFRO0FBR2hELENBQ0YscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vM0QtQUktRW5nbGlzaC8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvX3BvbHlmaWxsL2NvbnN0YW50cy5qcz9mMTdlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJFVklTSU9OIH0gZnJvbSBcInRocmVlXCI7XG5jb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQoUkVWSVNJT04ucmVwbGFjZSgvXFxEKy9nLCBcIlwiKSk7XG5leHBvcnQge1xuICB2ZXJzaW9uXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlJFVklTSU9OIiwidmVyc2lvbiIsInBhcnNlSW50IiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/libs/MeshoptDecoder.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshoptDecoder: () => (/* binding */ MeshoptDecoder)\n/* harmony export */ });\nlet generated;\nconst MeshoptDecoder = ()=>{\n    if (generated) return generated;\n    const wasm_base = \"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\";\n    const wasm_simd = \"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\";\n    const detector = new Uint8Array([\n        0,\n        97,\n        115,\n        109,\n        1,\n        0,\n        0,\n        0,\n        1,\n        4,\n        1,\n        96,\n        0,\n        0,\n        3,\n        3,\n        2,\n        0,\n        0,\n        5,\n        3,\n        1,\n        0,\n        1,\n        12,\n        1,\n        0,\n        10,\n        22,\n        2,\n        12,\n        0,\n        65,\n        0,\n        65,\n        0,\n        65,\n        0,\n        252,\n        10,\n        0,\n        0,\n        11,\n        7,\n        0,\n        65,\n        0,\n        253,\n        15,\n        26,\n        11\n    ]);\n    const wasmpack = new Uint8Array([\n        32,\n        0,\n        65,\n        253,\n        3,\n        1,\n        2,\n        34,\n        4,\n        106,\n        6,\n        5,\n        11,\n        8,\n        7,\n        20,\n        13,\n        33,\n        12,\n        16,\n        128,\n        9,\n        116,\n        64,\n        19,\n        113,\n        127,\n        15,\n        10,\n        21,\n        22,\n        14,\n        255,\n        66,\n        24,\n        54,\n        136,\n        107,\n        18,\n        23,\n        192,\n        26,\n        114,\n        118,\n        132,\n        17,\n        77,\n        101,\n        130,\n        144,\n        27,\n        87,\n        131,\n        44,\n        45,\n        74,\n        156,\n        154,\n        70,\n        167\n    ]);\n    if (typeof WebAssembly !== \"object\") {\n        return {\n            supported: false\n        };\n    }\n    let wasm = wasm_base;\n    if (WebAssembly.validate(detector)) {\n        wasm = wasm_simd;\n    }\n    let instance;\n    const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result)=>{\n        instance = result.instance;\n        instance.exports.__wasm_call_ctors();\n    });\n    function unpack(data) {\n        const result = new Uint8Array(data.length);\n        for(let i = 0; i < data.length; ++i){\n            const ch = data.charCodeAt(i);\n            result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n        }\n        let write = 0;\n        for(let i = 0; i < data.length; ++i){\n            result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n        }\n        return result.buffer.slice(0, write);\n    }\n    function decode(fun, target, count, size, source, filter) {\n        const sbrk = instance.exports.sbrk;\n        const count4 = count + 3 & ~3;\n        const tp = sbrk(count4 * size);\n        const sp = sbrk(source.length);\n        const heap = new Uint8Array(instance.exports.memory.buffer);\n        heap.set(source, sp);\n        const res = fun(tp, count, size, sp, source.length);\n        if (res === 0 && filter) {\n            filter(tp, count4, size);\n        }\n        target.set(heap.subarray(tp, tp + count * size));\n        sbrk(tp - sbrk(0));\n        if (res !== 0) {\n            throw new Error(`Malformed buffer data: ${res}`);\n        }\n    }\n    const filters = {\n        // legacy index-based enums for glTF\n        0: \"\",\n        1: \"meshopt_decodeFilterOct\",\n        2: \"meshopt_decodeFilterQuat\",\n        3: \"meshopt_decodeFilterExp\",\n        // string-based enums for glTF\n        NONE: \"\",\n        OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n        QUATERNION: \"meshopt_decodeFilterQuat\",\n        EXPONENTIAL: \"meshopt_decodeFilterExp\"\n    };\n    const decoders = {\n        // legacy index-based enums for glTF\n        0: \"meshopt_decodeVertexBuffer\",\n        1: \"meshopt_decodeIndexBuffer\",\n        2: \"meshopt_decodeIndexSequence\",\n        // string-based enums for glTF\n        ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n        TRIANGLES: \"meshopt_decodeIndexBuffer\",\n        INDICES: \"meshopt_decodeIndexSequence\"\n    };\n    generated = {\n        ready: promise,\n        supported: true,\n        decodeVertexBuffer (target, count, size, source, filter) {\n            decode(instance.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance.exports[filters[filter]]);\n        },\n        decodeIndexBuffer (target, count, size, source) {\n            decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n        },\n        decodeIndexSequence (target, count, size, source) {\n            decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n        },\n        decodeGltfBuffer (target, count, size, source, mode, filter) {\n            decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);\n        }\n    };\n    return generated;\n};\n //# sourceMappingURL=MeshoptDecoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpYnMvTWVzaG9wdERlY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLElBQUlBO0FBQ0osTUFBTUMsaUJBQWlCO0lBQ3JCLElBQUlELFdBQ0YsT0FBT0E7SUFDVCxNQUFNRSxZQUFZO0lBQ2xCLE1BQU1DLFlBQVk7SUFDbEIsTUFBTUMsV0FBVyxJQUFJQyxXQUFXO1FBQzlCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBQ0QsTUFBTUMsV0FBVyxJQUFJRCxXQUFXO1FBQzlCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBQ0QsSUFBSSxPQUFPRSxnQkFBZ0IsVUFBVTtRQUNuQyxPQUFPO1lBQ0xDLFdBQVc7UUFDYjtJQUNGO0lBQ0EsSUFBSUMsT0FBT1A7SUFDWCxJQUFJSyxZQUFZRyxRQUFR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QUFrQjNCLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLE1BQU07WUFDM0NMLE9BQU9oQixTQUFTTSxPQUFPLENBQUN3Qyx5QkFBeUIsRUFBRTVCLFFBQVFDLE9BQU9DLE1BQU1DO1FBQzFFO1FBQ0EwQixxQkFBb0I3QixNQUFNLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxNQUFNO1lBQzdDTCxPQUFPaEIsU0FBU00sT0FBTyxDQUFDMEMsMkJBQTJCLEVBQUU5QixRQUFRQyxPQUFPQyxNQUFNQztRQUM1RTtRQUNBNEIsa0JBQWlCL0IsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFNkIsSUFBSSxFQUFFNUIsTUFBTTtZQUN4RE4sT0FDRWhCLFNBQVNNLE9BQU8sQ0FBQ2dDLFFBQVEsQ0FBQ1ksS0FBSyxDQUFDLEVBQ2hDaEMsUUFDQUMsT0FDQUMsTUFDQUMsUUFDQXJCLFNBQVNNLE9BQU8sQ0FBQzJCLE9BQU8sQ0FBQ1gsT0FBTyxDQUFDO1FBRXJDO0lBQ0Y7SUFDQSxPQUFPakM7QUFDVDtBQUdFLENBQ0YsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vM0QtQUktRW5nbGlzaC8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbGlicy9NZXNob3B0RGVjb2Rlci5qcz9hN2Y0Il0sInNvdXJjZXNDb250ZW50IjpbImxldCBnZW5lcmF0ZWQ7XG5jb25zdCBNZXNob3B0RGVjb2RlciA9ICgpID0+IHtcbiAgaWYgKGdlbmVyYXRlZClcbiAgICByZXR1cm4gZ2VuZXJhdGVkO1xuICBjb25zdCB3YXNtX2Jhc2UgPSBcIkI5aDl6OXRGQkJCRjhmTDlnQkI5Z0xhYWFhYUZhOWdFYWFhQjlnRmFGYTlnRWFhYUZhRU1jQkZGRkdHR0VJSUlMRjl3RkZGTEVGQkZLTkZhRkN4L0lGTU8vTEZWSzl0djl0OXZxOTVHQnQ5ZjlmOTM5aDl6OXQ5ZjlqOWg5czlzOWY5alc5dnE5ekJCcDl0djl6OW85djl3VzlmOWt2OWo5djlrdjlXdnFXdjk0aDkxOW05bXZxQkY4Wjl0djl6OW85djl3VzlmOWt2OWo5djlrdjlKOXU5a3Y5NGg5MTltOW12cUJHeTl0djl6OW85djl3VzlmOWt2OWo5djlrdjlKOXU5a3Y5NDlUdlo5MXY5dTlqdkJFbjl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOVA5aldCSWk5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlSOTE5aFdCTG45dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlGOTQ5d0JLSTl6OWlxbEJPYyt4OHljR0JNL3FRRlRhOGpVVVVVQkNVL0VCbEhMOGtVVVVVQkM5K1JLR1hBR0NGSkFJOUxRQkNhUktBRTJCQkMrZ0Y5SFFCQUxBRUFJSkhPQUdsQUdUa1VVVUJSTkNVb0JBRzl1Qy93Z0JaSEtDVUdBS0NVRzlKeVJWQUVDRkpSSUNCUmNHWEVYQWNBRjlQUUZBVkFGQWNsQWNBVkpBRjlKeVJNR1hHWEFHOUZRQkFNQ2JKSEtDOXdaUlNBS0NJckNFSkNHclJRQU5DVUdKUmZDQlJiQUlSVEVYR1hBT0FUbEFROVBRQkNCUklTRU1BVEFRSlJJR1hBUzlGUUJDQlJ0Q0JSRUVYR1hBT0FJbENpOVBRQkNCUklTTE1BTkNVL0NCSkFFSlJLR1hHWEdYR1hHWEFUQUVDS3JKMkJCQXRDS1pyQ0VaZklCRkdFQk1BS2hCODNFQkFLQ05KaEI4M0VCU0VNQUtBSTJCSUFJMkJCSG1DS3JIWUFZQ0U2SFl5ODZCQkFLQ0ZKQUlDSUpBWUpIWTJCQkFtQ0lyQ0VaSFBBUENFNkhQeTg2QkJBS0NHSkFZQVBKSFkyQkJBbUNHckNFWkhQQVBDRTZIUHk4NkJCQUtDRUpBWUFQSkhZMkJCQW1DRVpIbUFtQ0U2SG15ODZCQkFLQ0lKQVlBbUpIWTJCQkFJMkJGSG1DS3JIUEFQQ0U2SFB5ODZCQkFLQ0xKQVlBUEpIWTJCQkFtQ0lyQ0VaSFBBUENFNkhQeTg2QkJBS0NLSkFZQVBKSFkyQkJBbUNHckNFWkhQQVBDRTZIUHk4NkJCQUtDT0pBWUFQSkhZMkJCQW1DRVpIbUFtQ0U2SG15ODZCQkFLQ05KQVlBbUpIWTJCQkFJMkJHSG1DS3JIUEFQQ0U2SFB5ODZCQkFLQ1ZKQVlBUEpIWTJCQkFtQ0lyQ0VaSFBBUENFNkhQeTg2QkJBS0NjSkFZQVBKSFkyQkJBbUNHckNFWkhQQVBDRTZIUHk4NkJCQUtDTUpBWUFQSkhZMkJCQW1DRVpIbUFtQ0U2SG15ODZCQkFLQ1NKQVlBbUpIbTJCQkFJMkJFSElDS3JIWUFZQ0U2SFl5ODZCQkFLQ1FKQW1BWUpIbTJCQkFJQ0lyQ0VaSFlBWUNFNkhZeTg2QkJBS0NmSkFtQVlKSG0yQkJBSUNHckNFWkhZQVlDRTZIWXk4NkJCQUtDYkpBbUFZSkhLMkJCQUlDRVpISUFJQ0U2SEl5ODZCQkFLQUlKUklTR01BS0FJMkJOQUkyQkJIbUNJckhZQVlDYjZIWXk4NkJCQUtDRkpBSUNOSkFZSkhZMkJCQW1DYlpIbUFtQ2I2SG15ODZCQkFLQ0dKQVlBbUpIbTJCQkFJMkJGSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ0VKQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NJSkFtQVlKSG0yQkJBSTJCR0hZQ0lySFBBUENiNkhQeTg2QkJBS0NMSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDS0pBbUFZSkhtMkJCQUkyQkVIWUNJckhQQVBDYjZIUHk4NkJCQUtDT0pBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ05KQW1BWUpIbTJCQkFJMkJJSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ1ZKQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NjSkFtQVlKSG0yQkJBSTJCTEhZQ0lySFBBUENiNkhQeTg2QkJBS0NNSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDU0pBbUFZSkhtMkJCQUkyQktIWUNJckhQQVBDYjZIUHk4NkJCQUtDUUpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ2ZKQW1BWUpIbTJCQkFJMkJPSElDSXJIWUFZQ2I2SFl5ODZCQkFLQ2JKQW1BWUpISzJCQkFJQ2JaSElBSUNiNkhJeTg2QkJBS0FJSlJJU0ZNQUtBSThwQkI4M0JCQUtDTkpBSUNOSjhwQkI4M0JCQUlDVEpSSU1BdENHSlJ0QUVDVEpIRUFTOUpRQk1NR1hBSVFCQ0JSSVNFTUdYQU05RlFCQU5BYkoyQkJSdENCUktBZlJFRVhBRUFOQ1UvQ0JKQUtKMkJCSFRDRnJDQkFUQ0ZabDl6QXRKSHQ4NkJCQUVBR0pSRUFLQ0ZKSEtBTTlIUUJNTUFmQ0ZKUmZBSVJUQWJDRkpIYkFHOUhRQk1NQUJBY0FHOXNKQU5DVUdKQU1BRzlzVGtVVVVCcEFOQU5DVUdKQU1DYUpBRzlzSkFHVGtVVVVCcE1BTUNCQUl5QWNKUmNBSVFCTUM5K1JLU0ZNQ0JDOTlBT0FJbEFHQ0FBR0NBOUx5NnlSS01BTENVL0VCSjhrVVVVVUJBS00rT21GVGE4alVVVVVCQ29GbEhMOGtVVVVVQkM5K1JLR1hBRkNFOXVIT0N0SkFJOUxRQkNhUktBRTJCQkhOQy93RlpDL2dGOUhRQkFOQ2JaSFZDRjlMUUJBTENvQkpDZ0ZDVUZUK0pVVVVCcEFMQzg0SmhhODNFQkFMQzh3SmhhODNFQkFMQzhvSmhhODNFQkFMQ0FKaGE4M0VCQUxDaUpoYTgzRUJBTENUSmhhODNFQkFMaGE4M0VOQUxoYTgzRUJBRUFJSkM5d0pSY0FFQ0ZKSE5BT0pSTUdYQUY5RlFCQ1FDYkFWQ0Y2eVJTQUJSRUNCUlZDQlJRQ0JSZkNCUklDQlJLRVhHWEFNQWN1UUJDOStSS1NFTUdYR1hBTjJCQkhPQy92RjlMUUJBTENvQkpBT0NJckNhOXpBS0pDYlpDRVdKSGI4b0dJUlRBYjhvR0JSdEdYQU9DYlpIYkFTOVBRQkFMQU9DYTl6QUlKQ2JaQ0dXSjhvR0JBVkFieVJPQWI5RlJiR1hHWEFHQ0c5SFFCQUJBdDg3RkJBQkNJSkFPODdGQkFCQ0dKQVQ4N0ZCU0ZNQUVBdGpHQkFFQ05KQU9qR0JBRUNJSkFUakdCTUFWQWJKUlZBTENvQkpBS0NFV0pIbUFPakdCQW1BVGpHSUFMQUlDR1dKQU9qR0JBTENvQkpBS0NGSkNiWkhLQ0VXSkhUQXRqR0JBVEFPakdJQUlBYkpSSUFLQ0ZKUktTR01HWEdYQWJDYjZRQkFRQWJKQWJDOTg5ekpDRkpSUVNGTUFNMUJCSGJDZ0ZaUk9HWEdYQWJDYTlNUUJBTUNGSlJNU0ZNQU0xQkZIYkNnQlpDT1dBT0NnQlpxUk9HWEFiQ2E5TVFCQU1DR0pSTVNGTUFNMUJHSGJDZ0JaQ2ZXQU9xUk9HWEFiQ2E5TVFCQU1DRUpSTVNGTUFNMUJFSGJDZ0JaQ2RXQU9xUk9HWEFiQ2E5TVFCQU1DSUpSTVNGTUFNMkJJQzhjV0FPcVJPQU1DTEpSTU1BT0NGckNCQU9DRlpsOXpBUUpSUU1HWEdYQUdDRzlIUUJBQkF0ODdGQkFCQ0lKQVE4N0ZCQUJDR0pBVDg3RkJTRk1BRUF0akdCQUVDTkpBUWpHQkFFQ0lKQVRqR0JNQUxDb0JKQUtDRVdKSE9BUWpHQkFPQVRqR0lBTEFJQ0dXSkFRakdCQUxDb0JKQUtDRkpDYlpIS0NFV0pIT0F0akdCQU9BUWpHSUFJQ0ZKUklBS0NGSlJLU0ZNR1hBT0NERjlMUUJBTEFJQWNBT0NiWkoyQkJIYkNJckhUbENiWkNHV0o4b0dCQVZDRkpIdEFUeVJPQUxBSUFibENiWkNHV0o4b0dCQXRBVDlGSG1KSHRBYkNiWkhUeVJiQVQ5RlJUR1hHWEFHQ0c5SFFCQUJBVjg3RkJBQkNJSkFiODdGQkFCQ0dKQU84N0ZCU0ZNQUVBVmpHQkFFQ05KQWJqR0JBRUNJSkFPakdCTUFMQUlDR1dKQVZqR0JBTENvQkpBS0NFV0pIWUFPakdCQVlBVmpHSUFMQUlDRkpISUNiWkNHV0pBT2pHQkFMQ29CSkFLQ0ZKQ2JaQ0VXSkhZQWJqR0JBWUFPakdJQUxBSUFtSkNiWkhJQ0dXSkFiakdCQUxDb0JKQUtDR0pDYlpIS0NFV0pIT0FWakdCQU9BYmpHSUFLQ0ZKUktBSUFUSlJJQXRBVEpSVlNGTUFWQ0JBTTJCQkhZeUhUQU9DLytGNkhQSlJPQVlDYlpSdEdYR1hBWUNJckhtUUJBT0NGSlJiU0ZNQU9SYkFMQUlBbWxDYlpDR1dKOG9HQlJPTUdYR1hBdFFCQWJDRkpSVlNGTUFiUlZBTEFJQVlsQ2JaQ0dXSjhvR0JSYk1HWEdYQVA5RlFCQU1DRkpSWVNGTUFNMUJGSFlDZ0ZaUlRHWEdYQVlDYTlNUUJBTUNHSlJZU0ZNQU0xQkdIWUNnQlpDT1dBVENnQlpxUlRHWEFZQ2E5TVFCQU1DRUpSWVNGTUFNMUJFSFlDZ0JaQ2ZXQVRxUlRHWEFZQ2E5TVFCQU1DSUpSWVNGTUFNMUJJSFlDZ0JaQ2RXQVRxUlRHWEFZQ2E5TVFCQU1DTEpSWVNGTUFNQ0tKUllBTTJCTEM4Y1dBVHFSVE1BVENGckNCQVRDRlpsOXpBUUpIUVJUTUdYR1hBbUNiNlFCQVlSUFNGTUFZMUJCSE1DZ0ZaUk9HWEdYQU1DYTlNUUJBWUNGSlJQU0ZNQVkxQkZITUNnQlpDT1dBT0NnQlpxUk9HWEFNQ2E5TVFCQVlDR0pSUFNGTUFZMUJHSE1DZ0JaQ2ZXQU9xUk9HWEFNQ2E5TVFCQVlDRUpSUFNGTUFZMUJFSE1DZ0JaQ2RXQU9xUk9HWEFNQ2E5TVFCQVlDSUpSUFNGTUFZQ0xKUlBBWTJCSUM4Y1dBT3FST01BT0NGckNCQU9DRlpsOXpBUUpIUVJPTUdYR1hBdENiNlFCQVBSTVNGTUFQMUJCSE1DZ0ZaUmJHWEdYQU1DYTlNUUJBUENGSlJNU0ZNQVAxQkZITUNnQlpDT1dBYkNnQlpxUmJHWEFNQ2E5TVFCQVBDR0pSTVNGTUFQMUJHSE1DZ0JaQ2ZXQWJxUmJHWEFNQ2E5TVFCQVBDRUpSTVNGTUFQMUJFSE1DZ0JaQ2RXQWJxUmJHWEFNQ2E5TVFCQVBDSUpSTVNGTUFQQ0xKUk1BUDJCSUM4Y1dBYnFSYk1BYkNGckNCQWJDRlpsOXpBUUpIUVJiTUdYR1hBR0NHOUhRQkFCQVQ4N0ZCQUJDSUpBYjg3RkJBQkNHSkFPODdGQlNGTUFFQVRqR0JBRUNOSkFiakdCQUVDSUpBT2pHQk1BTENvQkpBS0NFV0pIWUFPakdCQVlBVGpHSUFMQUlDR1dKQVRqR0JBTENvQkpBS0NGSkNiWkNFV0pIWUFiakdCQVlBT2pHSUFMQUlDRkpISUNiWkNHV0pBT2pHQkFMQ29CSkFLQ0dKQ2JaQ0VXSkhPQVRqR0JBT0FiakdJQUxBSUFtOUZBbUNiNnFKSElDYlpDR1dKQWJqR0JBSUF0OUZBdENiNnFKUklBS0NFSlJLTUFOQ0ZKUk5BQkNLSlJCQUVDU0pSRUFLQ2JaUktBSUNiWlJJQWZDRUpIZkFGOUpRQk1NQ0JDOTlBTUFjNnlSS01BTENvRko4a1VVVVVCQUtNL3RJRkdhOGpVVVVVQkNUbFJMQzkrUktHWEFGQ0xKQUk5TFFCQ2FSS0FFMkJCQy8rRlpDL1FGOUhRQkFMaEI4M0VOQUVDRkpSS0FFQUlKQzk4SlJFR1hBRjlGUUJHWEFHQ0c2UUJFWEdYQUtBRTlKUUJDOStiTUFLMUJCSEdDZ0ZaUklHWEdYQUdDYTlNUUJBS0NGSlJLU0ZNQUsxQkZIR0NnQlpDT1dBSUNnQlpxUklHWEFHQ2E5TVFCQUtDR0pSS1NGTUFLMUJHSEdDZ0JaQ2ZXQUlxUklHWEFHQ2E5TVFCQUtDRUpSS1NGTUFLMUJFSEdDZ0JaQ2RXQUlxUklHWEFHQ2E5TVFCQUtDSUpSS1NGTUFLMkJJQzhjV0FJcVJJQUtDTEpSS01BTENOSkFJQ0ZaQ0dXcUhHQUlDR3JDQkFJQ0ZyQ0ZabDl6QUc4b0dCSkhJakdCQUJBSWpHQkFCQ0lKUkJBRkNhSkhGUUJTR01NRVhHWEFLQUU5SlFCQzkrYk1BSzFCQkhHQ2dGWlJJR1hHWEFHQ2E5TVFCQUtDRkpSS1NGTUFLMUJGSEdDZ0JaQ09XQUlDZ0JacVJJR1hBR0NhOU1RQkFLQ0dKUktTRk1BSzFCR0hHQ2dCWkNmV0FJcVJJR1hBR0NhOU1RQkFLQ0VKUktTRk1BSzFCRUhHQ2dCWkNkV0FJcVJJR1hBR0NhOU1RQkFLQ0lKUktTRk1BSzJCSUM4Y1dBSXFSSUFLQ0xKUktNQUJBSUNHckNCQUlDRnJDRlpsOXpBTENOSkFJQ0ZaQ0dXcUhJOG9HQkpIRzg3RkJBSUFHakdCQUJDR0pSQkFGQ2FKSEZRQk1NQ0JDOTlBS0FFNnlSS01BS00rbExLRmFGOTlHYUc5OUZhRzk5R1hHWEFHQ0k5SFFCQUY5RlFGRVhHWEdYOURCQkI4LzlEQkJCKy9BQkNHSkhHMUJCK3lBQjFCQkhFK3lISStMK1RBQkNGSkhMMUJCSEsreUhPK0wrVEhOOURCQkJCOWdIVnlBTjlEQkIvK2hBTkFOK1U5REJCQkJBTkFWeUhjQWMrTUhNQUVDYTN5QUkrU0hJQUkrVUFjQU1BS0NhM3lBTytTSGNBYytVK1MrUytSK1ZITytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SRVNGTUNVVVVVOTRSRU1BR0FFODZCQkdYR1g5REJCQjgvOURCQkIrL0FjOURCQkJCOWd5QWNBTytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SR1NGTUNVVVVVOTRSR01BTEFHODZCQkdYR1g5REJCQjgvOURCQkIrL0FJOURCQkJCOWd5QUlBTytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SR1NGTUNVVVVVOTRSR01BQkFHODZCQkFCQ0lKUkJBRkNhSkhGUUJTR01NQUY5RlFCRVhHWEdYOURCQkI4LzlEQkJCKy9BQkNJSkhHOHVGQit5QUI4dUZCSEUreUhJK0wrVEFCQ0dKSEw4dUZCSEsreUhPK0wrVEhOOURCQkJCOWdIVnlBTjlEQi8rZzZBTkFOK1U5REJCQkJBTkFWeUhjQWMrTUhNQUVDYTN5QUkrU0hJQUkrVUFjQU1BS0NhM3lBTytTSGNBYytVK1MrUytSK1ZITytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SRVNGTUNVVVVVOTRSRU1BR0FFODdGQkdYR1g5REJCQjgvOURCQkIrL0FjOURCQkJCOWd5QWNBTytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SR1NGTUNVVVVVOTRSR01BTEFHODdGQkdYR1g5REJCQjgvOURCQkIrL0FJOURCQkJCOWd5QUlBTytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SR1NGTUNVVVVVOTRSR01BQkFHODdGQkFCQ05KUkJBRkNhSkhGUUJNTU0vU0VJRWFFOTlFYUY5OUdYQUY5RlFCQ0JSRUFCUklFWEdYR1g5RC96STgxOC9BSUNLSjh1RkJITENFcSt5K1ZIS0FJOHVGQit5K1VITzlEQi8rZzYrVTlEQkJCOC85REJCQisvQU85REJCQkI5Z3krU0hOK0w5REJCQjlQOWQ5RlFCQU4rb1JWU0ZNQ1VVVVU5NFJWTUFJQ0lKOHVGQlJjQUlDR0o4dUZCUk1BQkFMQ0ZKQ0VaQUVxQ0ZXSkFWODdGQkdYR1hBS0FNK3krVUhOOURCLytnNitVOURCQkI4LzlEQkJCKy9BTjlEQkJCQjlneStTSFMrTDlEQkJCOVA5ZDlGUUJBUytvUk1TRk1DVVVVVTk0Uk1NQUJBTENHSkNFWkFFcUNGV0pBTTg3RkJHWEdYQUtBYyt5K1VISzlEQi8rZzYrVTlEQkJCOC85REJCQisvQUs5REJCQkI5Z3krU0hTK0w5REJCQjlQOWQ5RlFCQVMrb1JjU0ZNQ1VVVVU5NFJjTUFCQUxDYUpDRVpBRXFDRldKQWM4N0ZCR1hHWDlEQkJVOC9BT0FPK1UrVEFOQU4rVStUQUtBSytVK1RITzlEQkJCQkFPOURCQkJCOWd5K1I5REIvK2c2K1U5REJCQjgvK1NITytMOURCQkI5UDlkOUZRQkFPK29SY1NGTUNVVVVVOTRSY01BQkFMQ0VaQUVxQ0ZXSkFjODdGQkFJQ05KUklBRUNJSlJFQUZDYUpIRlFCTU1NOUpCR1hBR0NHckFGOXNIRjlGUUJFWEFCQUI4b0dCSEdDTldDTjkxK3lBR0NpOTFDbldDVVVVLzhFSisrK1U4NEdCQUJDSUpSQkFGQ2FKSEZRQk1NTTlURkVhQ0JDQjhvR1VrVVVCSEZBQkNFSkM5OFpKSEJqR1VrVVVCR1hHWEFCOC9CQ1RXSEd1UUJDYVJFQUJBR2xDZ2dFSkNUclhCQ2E2UUZNQUZSRU1BRU0vbEZGRmFHWEdYQUZBQnFDRVo5RlFCQUJSRVNGTUdYR1hBR0NUOVBRQkFCUkVTRk1BQlJFRVhBRUFGOG9HQmpHQkFFQ0lKQUZDSUo4b0dCakdCQUVDTkpBRkNOSjhvR0JqR0JBRUNTSkFGQ1NKOG9HQmpHQkFFQ1RKUkVBRkNUSlJGQUdDOXdKSEdDYjlMUUJNTUFHQ0k5SlFCRVhBRUFGOG9HQmpHQkFGQ0lKUkZBRUNJSlJFQUdDOThKSEdDRTlMUUJNTUdYQUc5RlFCRVhBRUFGMkJCODZCQkFFQ0ZKUkVBRkNGSlJGQUdDYUpIR1FCTU1BQk1vRkZHYUdYR1hBQkNFWjlGUUJBQlJFU0ZNQUZDZ0ZaQytCd3NOOXNSSUdYR1hBR0NUOVBRQkFCUkVTRk1BQlJFRVhBRUFJakdCQUVDU0pBSWpHQkFFQ05KQUlqR0JBRUNJSkFJakdCQUVDVEpSRUFHQzl3SkhHQ2I5TFFCTU1BR0NJOUpRQkVYQUVBSWpHQkFFQ0lKUkVBR0M5OEpIR0NFOUxRQk1NR1hBRzlGUUJFWEFFQUY4NkJCQUVDRkpSRUFHQ2FKSEdRQk1NQUJNTU1GQkNVTk1JVDlrQkJcIjtcbiAgY29uc3Qgd2FzbV9zaW1kID0gXCJCOWg5ejl0RkJCQkZpSTlnQkI5Z0xhYWFhYUZhOWdFYWFhQjlnRmFGYUVNY0JCRkJGRkdHR0VJTEY5d0ZGRkxFRkJGS05GYUZDeC9hRk1PL0xGVks5dHY5dDl2cTk1R0J0OWY5ZjkzOWg5ejl0OWY5ajloOXM5czlmOWpXOXZxOXpCQnA5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5V3ZxV3Y5NGg5MTltOW12cUJHOFo5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTRoOTE5bTltdnFCSXk5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTQ5VHZaOTF2OXU5anZCTG45dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlQOWpXQktpOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UjkxOWhXQk9uOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5Rjk0OXdCTkk5ejlpcWxCVmMrTjlJY0lCVEVNOStGTGE4alVVVVVCQ1RsUkJDQlJGRVhDQlJHQ0JSRUVYQUJDTkpBR0pBRUNVYUFGQUdyQ0ZaSEl5ODZCQkFFQUlKUkVBR0NGSkhHQ045SFFCTUFGQ3grWVVVQkpBRTg2QkJBRkNFV0N4a1VVQkpBQjhwRU44M0VCQUZDRkpIRkNVRzlIUUJNTWs4bExiYUU5N0Y5K0ZhTDk3OGpVVVVVQkNVL0tCbEhMOGtVVVVVQkM5K1JLR1hBR0NGSkFJOUxRQkNhUktBRTJCQkMrZ0Y5SFFCQUxBRUFJSkhPQUdsQUcvOGNCQkNVb0JBRzl1Qy93Z0JaSEtDVUdBS0NVRzlKeVJOQUVDRkpSS0NCUlZHWEVYQVZBRjlQUUZBTkFGQVZsQVZBTkpBRjlKeVJjR1hHWEFHOUZRQkFjQ2JKSElDOXdaSE1DRTlzUlNBTUNGV1JRQUlDSXJDRUpDR3JSZkNCUmJFWEFLUlRDQlJ0R1hFWEdYQU9BVGxBZjlQUUJDQlJLU0xNQUxDVS9DQkpBdEFNOXNKUm1BVEFmSlJLQ0JSRUdYQU1Db0I5SlFCQU9BS2xDL2dCOUpRQkNCUklFWEFtQUlKUkVHWEdYR1hHWEdYQVRBSUNLckoyQkJIWUNFWmZJQkZHRUJNQUVDQkR0RE1JQlNFTUFFQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BRUFLREJCQkRNSUJBS0NUSlJLTUdYR1hHWEdYR1hBWUNHckNFWmZJQkZHRUJNQUVDQkR0RE1JVFNFTUFFQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSVRBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSVRBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BRUFLREJCQkRNSVRBS0NUSlJLTUdYR1hHWEdYR1hBWUNJckNFWmZJQkZHRUJNQUVDQkR0RE1JQVNFTUFFQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUFBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUFBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BRUFLREJCQkRNSUFBS0NUSlJLTUdYR1hHWEdYR1hBWUNLcmZJQkZHRUJNQUVDQkR0RE1JOHdTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIWUNFV0N4a1VVQkpEQkVCQVlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhZQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUk4d0FLQ0lKQWVEZUJKQVlDeCtZVVVCSjJCQkpSS1NHTUFFQUtEQkJOQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMrUCtlKzgvNEJEdEQ5T0hkQ2JEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSFlDRVdDeGtVVUJKREJFQkFZQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIWUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JOHdBS0NOSkFlRGVCSkFZQ3grWVVVQkoyQkJKUktTRk1BRUFLREJCQkRNSTh3QUtDVEpSS01BSUNvQkpSRUFJQ1VGSkFNOUxRRkFFUklBT0FLbEMvZkI5TFFCTU1HWEFFQU05UFFCQUVDRXJSSUVYR1hBT0FLbENpOVBRQkNCUktTT01BbUFFSlJZR1hHWEdYR1hHWEFUQUVDS3JKMkJCQUlDS1pyQ0VaZklCRkdFQk1BWUNCRHRETUlCU0VNQVlBS0RCQklBS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uSFBDR0QrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMwK0crTWlEdEQ5T0hkQ0VEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSGlDRVdDeGtVVUJKREJFQkFpQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIaUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JQkFLQ0lKQWVEZUJKQWlDeCtZVVVCSjJCQkpSS1NHTUFZQUtEQkJOQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMrUCtlKzgvNEJEdEQ5T0hkQ2JEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSGlDRVdDeGtVVUJKREJFQkFpQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIaUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JQkFLQ05KQWVEZUJKQWlDeCtZVVVCSjJCQkpSS1NGTUFZQUtEQkJCRE1JQkFLQ1RKUktNQUlDR0pSSUFFQ1RKSEVBTTlKUUJNTUdYQUs5RlFCQUtSVEF0Q0ZKSHRDSTZRR1NGTU1DQlJLU0VNR1hBTTlGUUJBTENVR0pBYkpSRUFMQWJKREJHQlJlQ0JSWUVYQUVBTENVL0NCSkFZSkhJREJJQkhkQ0ZEOXRBZENGRGJIUEQ5T0Q5aEQ5UkhkQUlBTUpEQklCSDhaQ0ZEOXRBOFpBUEQ5T0Q5aEQ5Ukg4WkRRQlRGdEdtRVlJUExkS2VPbkhwQUlBUUpEQklCSHlDRkQ5dEF5QVBEOU9EOWhEOVJIeUFJQVNKREJJQkg4Y0NGRDl0QThjQVBEOU9EOWhEOVJIOGNEUUJURnRHbUVZSVBMZEtlT25IOGREUUJGVHRHRW1ZSUxQZEtPZW5IUEFQRFFCRkdFQkZHRUJGR0VCRkdFQWVEOXVIZUR5QmpHQkFFQUdKSElBZUFQQVBEUUlMS09JTEtPSUxLT0lMS09EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUU5WY01OVmNNTlZjTU5WY01EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUVNRZmJTUWZiU1FmYlNRZmJEOXVIZUR5QmpHQkFJQUdKSElBZUFwQThkRFFOVmk4WmNNcHlTUThjOGRmYjhlOGZIUEFQRFFCRkdFQkZHRUJGR0VCRkdFRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SGVEeUJqR0JBSUFHSkhJQWVBZEE4WkRRTmlWOFpjcE15UzhjUThkZjhlYjhmSGRBeUE4Y0RRTmlWOFpjcE15UzhjUThkZjhlYjhmSDhaRFFCRlR0R0VtWUlMUGRLT2VuSFBBUERRQkZHRUJGR0VCRkdFQkZHRUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRSUxLT0lMS09JTEtPSUxLT0Q5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRTlZjTU5WY01OVmNNTlZjTUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRU1FmYlNRZmJTUWZiU1FmYkQ5dUhlRHlCakdCQUlBR0pISUFlQWRBOFpEUU5WaThaY01weVNROGM4ZGZiOGU4ZkhQQVBEUUJGR0VCRkdFQkZHRUJGR0VEOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUUlMS09JTEtPSUxLT0lMS09EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUU5WY01OVmNNTlZjTU5WY01EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUVNRZmJTUWZiU1FmYlNRZmJEOXVIZUR5QmpHQkFJQUdKUkVBWUNUSkhZQU05SlFCTU1BYkNJSkhiQUc5SlFCTU1BQkFWQUc5c0pBTENVR0pBY0FHOXMvOGNCQkFMQUxDVUdKQWNDYUpBRzlzSkFHLzhjQkJNQWNDQkFLeUFWSlJWQUtRQk1DOStSS1NGTUNCQzk5QU9BS2xBR0NBQUdDQTlMeTZ5UktNQUxDVS9LQko4a1VVVVVCQUtNTkJUK0JVVVVCTStLbUZUYThqVVVVVUJDb0ZsSEw4a1VVVVVCQzkrUktHWEFGQ0U5dUhPQ3RKQUk5TFFCQ2FSS0FFMkJCSE5DL3dGWkMvZ0Y5SFFCQU5DYlpIVkNGOUxRQkFMQ29CSkNnRkNVRi84TUJBTEM4NEpoYTgzRUJBTEM4d0poYTgzRUJBTEM4b0poYTgzRUJBTENBSmhhODNFQkFMQ2lKaGE4M0VCQUxDVEpoYTgzRUJBTGhhODNFTkFMaGE4M0VCQUVBSUpDOXdKUmNBRUNGSkhOQU9KUk1HWEFGOUZRQkNRQ2JBVkNGNnlSU0FCUkVDQlJWQ0JSUUNCUmZDQlJJQ0JSS0VYR1hBTUFjdVFCQzkrUktTRU1HWEdYQU4yQkJIT0MvdkY5TFFCQUxDb0JKQU9DSXJDYTl6QUtKQ2JaQ0VXSkhiOG9HSVJUQWI4b0dCUnRHWEFPQ2JaSGJBUzlQUUJBTEFPQ2E5ekFJSkNiWkNHV0o4b0dCQVZBYnlST0FiOUZSYkdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBTzg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFPakdCQUVDSUpBVGpHQk1BVkFiSlJWQUxDb0JKQUtDRVdKSG1BT2pHQkFtQVRqR0lBTEFJQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpIS0NFV0pIVEF0akdCQVRBT2pHSUFJQWJKUklBS0NGSlJLU0dNR1hHWEFiQ2I2UUJBUUFiSkFiQzk4OXpKQ0ZKUlFTRk1BTTFCQkhiQ2dGWlJPR1hHWEFiQ2E5TVFCQU1DRkpSTVNGTUFNMUJGSGJDZ0JaQ09XQU9DZ0JacVJPR1hBYkNhOU1RQkFNQ0dKUk1TRk1BTTFCR0hiQ2dCWkNmV0FPcVJPR1hBYkNhOU1RQkFNQ0VKUk1TRk1BTTFCRUhiQ2dCWkNkV0FPcVJPR1hBYkNhOU1RQkFNQ0lKUk1TRk1BTTJCSUM4Y1dBT3FST0FNQ0xKUk1NQU9DRnJDQkFPQ0ZabDl6QVFKUlFNR1hHWEFHQ0c5SFFCQUJBdDg3RkJBQkNJSkFRODdGQkFCQ0dKQVQ4N0ZCU0ZNQUVBdGpHQkFFQ05KQVFqR0JBRUNJSkFUakdCTUFMQ29CSkFLQ0VXSkhPQVFqR0JBT0FUakdJQUxBSUNHV0pBUWpHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSE9BdGpHQkFPQVFqR0lBSUNGSlJJQUtDRkpSS1NGTUdYQU9DREY5TFFCQUxBSUFjQU9DYlpKMkJCSGJDSXJIVGxDYlpDR1dKOG9HQkFWQ0ZKSHRBVHlST0FMQUlBYmxDYlpDR1dKOG9HQkF0QVQ5RkhtSkh0QWJDYlpIVHlSYkFUOUZSVEdYR1hBR0NHOUhRQkFCQVY4N0ZCQUJDSUpBYjg3RkJBQkNHSkFPODdGQlNGTUFFQVZqR0JBRUNOSkFiakdCQUVDSUpBT2pHQk1BTEFJQ0dXSkFWakdCQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVZqR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NGSkNiWkNFV0pIWUFiakdCQVlBT2pHSUFMQUlBbUpDYlpISUNHV0pBYmpHQkFMQ29CSkFLQ0dKQ2JaSEtDRVdKSE9BVmpHQkFPQWJqR0lBS0NGSlJLQUlBVEpSSUF0QVRKUlZTRk1BVkNCQU0yQkJIWXlIVEFPQy8rRjZIUEpST0FZQ2JaUnRHWEdYQVlDSXJIbVFCQU9DRkpSYlNGTUFPUmJBTEFJQW1sQ2JaQ0dXSjhvR0JST01HWEdYQXRRQkFiQ0ZKUlZTRk1BYlJWQUxBSUFZbENiWkNHV0o4b0dCUmJNR1hHWEFQOUZRQkFNQ0ZKUllTRk1BTTFCRkhZQ2dGWlJUR1hHWEFZQ2E5TVFCQU1DR0pSWVNGTUFNMUJHSFlDZ0JaQ09XQVRDZ0JacVJUR1hBWUNhOU1RQkFNQ0VKUllTRk1BTTFCRUhZQ2dCWkNmV0FUcVJUR1hBWUNhOU1RQkFNQ0lKUllTRk1BTTFCSUhZQ2dCWkNkV0FUcVJUR1hBWUNhOU1RQkFNQ0xKUllTRk1BTUNLSlJZQU0yQkxDOGNXQVRxUlRNQVRDRnJDQkFUQ0ZabDl6QVFKSFFSVE1HWEdYQW1DYjZRQkFZUlBTRk1BWTFCQkhNQ2dGWlJPR1hHWEFNQ2E5TVFCQVlDRkpSUFNGTUFZMUJGSE1DZ0JaQ09XQU9DZ0JacVJPR1hBTUNhOU1RQkFZQ0dKUlBTRk1BWTFCR0hNQ2dCWkNmV0FPcVJPR1hBTUNhOU1RQkFZQ0VKUlBTRk1BWTFCRUhNQ2dCWkNkV0FPcVJPR1hBTUNhOU1RQkFZQ0lKUlBTRk1BWUNMSlJQQVkyQklDOGNXQU9xUk9NQU9DRnJDQkFPQ0ZabDl6QVFKSFFST01HWEdYQXRDYjZRQkFQUk1TRk1BUDFCQkhNQ2dGWlJiR1hHWEFNQ2E5TVFCQVBDRkpSTVNGTUFQMUJGSE1DZ0JaQ09XQWJDZ0JacVJiR1hBTUNhOU1RQkFQQ0dKUk1TRk1BUDFCR0hNQ2dCWkNmV0FicVJiR1hBTUNhOU1RQkFQQ0VKUk1TRk1BUDFCRUhNQ2dCWkNkV0FicVJiR1hBTUNhOU1RQkFQQ0lKUk1TRk1BUENMSlJNQVAyQklDOGNXQWJxUmJNQWJDRnJDQkFiQ0ZabDl6QVFKSFFSYk1HWEdYQUdDRzlIUUJBQkFUODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFUakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVRqR0lBTEFJQ0dXSkFUakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NHSkNiWkNFV0pIT0FUakdCQU9BYmpHSUFMQUlBbTlGQW1DYjZxSkhJQ2JaQ0dXSkFiakdCQUlBdDlGQXRDYjZxSlJJQUtDRUpSS01BTkNGSlJOQUJDS0pSQkFFQ1NKUkVBS0NiWlJLQUlDYlpSSUFmQ0VKSGZBRjlKUUJNTUNCQzk5QU1BYzZ5UktNQUxDb0ZKOGtVVVVVQkFLTS90SUZHYThqVVVVVUJDVGxSTEM5K1JLR1hBRkNMSkFJOUxRQkNhUktBRTJCQkMvK0ZaQy9RRjlIUUJBTGhCODNFTkFFQ0ZKUktBRUFJSkM5OEpSRUdYQUY5RlFCR1hBR0NHNlFCRVhHWEFLQUU5SlFCQzkrYk1BSzFCQkhHQ2dGWlJJR1hHWEFHQ2E5TVFCQUtDRkpSS1NGTUFLMUJGSEdDZ0JaQ09XQUlDZ0JacVJJR1hBR0NhOU1RQkFLQ0dKUktTRk1BSzFCR0hHQ2dCWkNmV0FJcVJJR1hBR0NhOU1RQkFLQ0VKUktTRk1BSzFCRUhHQ2dCWkNkV0FJcVJJR1hBR0NhOU1RQkFLQ0lKUktTRk1BSzJCSUM4Y1dBSXFSSUFLQ0xKUktNQUxDTkpBSUNGWkNHV3FIR0FJQ0dyQ0JBSUNGckNGWmw5ekFHOG9HQkpISWpHQkFCQUlqR0JBQkNJSlJCQUZDYUpIRlFCU0dNTUVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFCQUlDR3JDQkFJQ0ZyQ0ZabDl6QUxDTkpBSUNGWkNHV3FISThvR0JKSEc4N0ZCQUlBR2pHQkFCQ0dKUkJBRkNhSkhGUUJNTUNCQzk5QUtBRTZ5UktNQUtNL2RMRUs5N0ZhRjk3R1hHWEFHQ0k5SFFCQUY5RlFGQ0JSR0VYQUJBQkRCQkJIRUNpRCtyRkNpRCtzRkQvNkZISUFFQ05EK3JGQ2lEK3NGRC82RkFJRC9nRkFFQ1REK3JGQ2lEK3NGRC82RkhMRC9nRkQva0ZEL2xGSEtDQkR0RCsyRkhPQUlDVVVVVTk0RHRITkQ5T0Q5UkQva0ZISTlEQkIvK2hEWUFJQUlEL21GQUtBS0QvbUZBTEFPQUxBTkQ5T0Q5UkQva0ZISUFJRC9tRkQva0ZEL2tGRC9qRkQvbkZITEQvbUY5REJCWDlMRFlIT0Qva0ZDZ0ZEdEQ5T0FFQ1VVVTk0RHREOU9EOVFBSUFMRC9tRkFPRC9rRkNORCtyRkNVLytFRHREOU9EOVFBS0FMRC9tRkFPRC9rRkNURCtyRkNVVS84T0R0RDlPRDlRRE1CQkFCQ1RKUkJBR0NJSkhHQUY5SlFCU0dNTUFGOUZRQkNCUkdFWEFCQ1RKSFZBVkRCQkJIRUNCRHRIT0NVVTk4RDhjRkNVVTk4RDhjRUhORDlPQUJEQkJCSEtBRURRSUxLT1NRZmJQZGVuOGM4ZDhlOGZDZ2dGRHREOU9ELzZGQUtBRURRQkZHRU5WY01UdG1ZaThacHlIRUNURCtzRkQvNkZISUQvZ0ZBRUNURCtyRkNURCtzRkQvNkZITEQvZ0ZEL2tGRC9sRkhFOURCLytnNkRZQUxBRUFPRCsyRkhPQUxDVVVVVTk0RHRIY0Q5T0Q5UkQva0ZITEFMRC9tRkFFQUVEL21GQUlBT0FJQWNEOU9EOVJEL2tGSEVBRUQvbUZEL2tGRC9rRkQvakZEL25GSElEL21GOURCQlg5TERZSE9EL2tGQ1REK3JGQUxBSUQvbUZBT0Qva0ZDZ2dFRHREOU9EOVFITEFFQUlEL21GQU9EL2tGQ2FEYkNCRG5HQ0JEbkVDQkRuS0NCRG5PQ0JEbmNDQkRuTUNCRG5mQ0JEbmJEOU9IRURRTlZpOFpjTXB5U1E4YzhkZmI4ZThmRDlRRE1CQkFCQUtBTkQ5T0FMQUVEUUJGVHRHRW1ZSUxQZEtPZW5EOVFETUJCQUJDQUpSQkFHQ0lKSEdBRjlKUUJNTU0vaEVJR2FGOTdGYUw5NzhqVVVVVUJDVGxSRUdYQUY5RlFCQ0JSSUVYQUVBQkRCQkJITEFCQ1RKSEtEQkJCSE9EUUlMS09TUWZiUGRlbjhjOGQ4ZThmSE5DVEQrc0ZIVkNJRCtyRkRNSUJBQjlEQkJVOC9EWTlEL3pJODE4L0RZQVZDRUR0RDlRRC82RkQvbkZIVkFMQU9EUUJGR0VOVmNNVHRtWWk4WnB5SExDVEQrckZDVEQrc0ZELzZGRC9tRkhPQU9EL21GQVZBTENURCtzRkQvNkZEL21GSGNBY0QvbUZBVkFOQ1REK3JGQ1REK3NGRC82RkQvbUZITkFORC9tRkQva0ZEL2tGRC9sRkNCRHREKzRGRC9qRjlEQi8rZzZEWUhWRC9tRjlEQkJYOUxEWUhMRC9rRkNnZ0VEdEhNRDlPQWNBVkQvbUZBTEQva0ZDVEQrckZEOVFIY0FOQVZEL21GQUxEL2tGQ1REK3JGQU9BVkQvbUZBTEQva0ZBTUQ5T0Q5UUhWRFFCRlR0R0VtWUlMUGRLT2VuSExEOGRCQUVEQklCRHlCK3QrSjgzRUJBQkNOSkFMRDhkRkFFREJJQkR5Rit0K0o4M0VCQUtBY0FWRFFOVmk4WmNNcHlTUThjOGRmYjhlOGZIVkQ4ZEJBRURCSUJEeUcrdCtKODNFQkFCQ2lKQVZEOGRGQUVEQklCRHlFK3QrSjgzRUJBQkNBSlJCQUlDSUpISUFGOUpRQk1NTTlqRkY5N0dYQUdDR3JBRjlzSEc5RlFCQ0JSRkVYQUJBQkRCQkJIRUNORCtyRkNORCtzRkQvNkZBRUNpRCtzRkNuRCtyRkNVVVUvOEVEdEQrdUZEL21GRE1CQkFCQ1RKUkJBRkNJSkhGQUc5SlFCTU1NOVRGRWFDQkNCOG9HVWtVVUJIRkFCQ0VKQzk4WkpIQmpHVWtVVUJHWEdYQUI4L0JDVFdIR3VRQkNhUkVBQkFHbENnZ0VKQ1RyWEJDYTZRRk1BRlJFTUFFTU1NRkJDVU5NSVQ5dEJCXCI7XG4gIGNvbnN0IGRldGVjdG9yID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDAsXG4gICAgOTcsXG4gICAgMTE1LFxuICAgIDEwOSxcbiAgICAxLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDEsXG4gICAgNCxcbiAgICAxLFxuICAgIDk2LFxuICAgIDAsXG4gICAgMCxcbiAgICAzLFxuICAgIDMsXG4gICAgMixcbiAgICAwLFxuICAgIDAsXG4gICAgNSxcbiAgICAzLFxuICAgIDEsXG4gICAgMCxcbiAgICAxLFxuICAgIDEyLFxuICAgIDEsXG4gICAgMCxcbiAgICAxMCxcbiAgICAyMixcbiAgICAyLFxuICAgIDEyLFxuICAgIDAsXG4gICAgNjUsXG4gICAgMCxcbiAgICA2NSxcbiAgICAwLFxuICAgIDY1LFxuICAgIDAsXG4gICAgMjUyLFxuICAgIDEwLFxuICAgIDAsXG4gICAgMCxcbiAgICAxMSxcbiAgICA3LFxuICAgIDAsXG4gICAgNjUsXG4gICAgMCxcbiAgICAyNTMsXG4gICAgMTUsXG4gICAgMjYsXG4gICAgMTFcbiAgXSk7XG4gIGNvbnN0IHdhc21wYWNrID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDMyLFxuICAgIDAsXG4gICAgNjUsXG4gICAgMjUzLFxuICAgIDMsXG4gICAgMSxcbiAgICAyLFxuICAgIDM0LFxuICAgIDQsXG4gICAgMTA2LFxuICAgIDYsXG4gICAgNSxcbiAgICAxMSxcbiAgICA4LFxuICAgIDcsXG4gICAgMjAsXG4gICAgMTMsXG4gICAgMzMsXG4gICAgMTIsXG4gICAgMTYsXG4gICAgMTI4LFxuICAgIDksXG4gICAgMTE2LFxuICAgIDY0LFxuICAgIDE5LFxuICAgIDExMyxcbiAgICAxMjcsXG4gICAgMTUsXG4gICAgMTAsXG4gICAgMjEsXG4gICAgMjIsXG4gICAgMTQsXG4gICAgMjU1LFxuICAgIDY2LFxuICAgIDI0LFxuICAgIDU0LFxuICAgIDEzNixcbiAgICAxMDcsXG4gICAgMTgsXG4gICAgMjMsXG4gICAgMTkyLFxuICAgIDI2LFxuICAgIDExNCxcbiAgICAxMTgsXG4gICAgMTMyLFxuICAgIDE3LFxuICAgIDc3LFxuICAgIDEwMSxcbiAgICAxMzAsXG4gICAgMTQ0LFxuICAgIDI3LFxuICAgIDg3LFxuICAgIDEzMSxcbiAgICA0NCxcbiAgICA0NSxcbiAgICA3NCxcbiAgICAxNTYsXG4gICAgMTU0LFxuICAgIDcwLFxuICAgIDE2N1xuICBdKTtcbiAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiB7XG4gICAgICBzdXBwb3J0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBsZXQgd2FzbSA9IHdhc21fYmFzZTtcbiAgaWYgKFdlYkFzc2VtYmx5LnZhbGlkYXRlKGRldGVjdG9yKSkge1xuICAgIHdhc20gPSB3YXNtX3NpbWQ7XG4gIH1cbiAgbGV0IGluc3RhbmNlO1xuICBjb25zdCBwcm9taXNlID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUodW5wYWNrKHdhc20pLCB7fSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgaW5zdGFuY2UgPSByZXN1bHQuaW5zdGFuY2U7XG4gICAgaW5zdGFuY2UuZXhwb3J0cy5fX3dhc21fY2FsbF9jdG9ycygpO1xuICB9KTtcbiAgZnVuY3Rpb24gdW5wYWNrKGRhdGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBjaCA9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgIHJlc3VsdFtpXSA9IGNoID4gOTYgPyBjaCAtIDcxIDogY2ggPiA2NCA/IGNoIC0gNjUgOiBjaCA+IDQ3ID8gY2ggKyA0IDogY2ggPiA0NiA/IDYzIDogNjI7XG4gICAgfVxuICAgIGxldCB3cml0ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICByZXN1bHRbd3JpdGUrK10gPSByZXN1bHRbaV0gPCA2MCA/IHdhc21wYWNrW3Jlc3VsdFtpXV0gOiAocmVzdWx0W2ldIC0gNjApICogNjQgKyByZXN1bHRbKytpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5idWZmZXIuc2xpY2UoMCwgd3JpdGUpO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZShmdW4sIHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSwgZmlsdGVyKSB7XG4gICAgY29uc3Qgc2JyayA9IGluc3RhbmNlLmV4cG9ydHMuc2JyaztcbiAgICBjb25zdCBjb3VudDQgPSBjb3VudCArIDMgJiB+MztcbiAgICBjb25zdCB0cCA9IHNicmsoY291bnQ0ICogc2l6ZSk7XG4gICAgY29uc3Qgc3AgPSBzYnJrKHNvdXJjZS5sZW5ndGgpO1xuICAgIGNvbnN0IGhlYXAgPSBuZXcgVWludDhBcnJheShpbnN0YW5jZS5leHBvcnRzLm1lbW9yeS5idWZmZXIpO1xuICAgIGhlYXAuc2V0KHNvdXJjZSwgc3ApO1xuICAgIGNvbnN0IHJlcyA9IGZ1bih0cCwgY291bnQsIHNpemUsIHNwLCBzb3VyY2UubGVuZ3RoKTtcbiAgICBpZiAocmVzID09PSAwICYmIGZpbHRlcikge1xuICAgICAgZmlsdGVyKHRwLCBjb3VudDQsIHNpemUpO1xuICAgIH1cbiAgICB0YXJnZXQuc2V0KGhlYXAuc3ViYXJyYXkodHAsIHRwICsgY291bnQgKiBzaXplKSk7XG4gICAgc2Jyayh0cCAtIHNicmsoMCkpO1xuICAgIGlmIChyZXMgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkIGJ1ZmZlciBkYXRhOiAke3Jlc31gKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZmlsdGVycyA9IHtcbiAgICAvLyBsZWdhY3kgaW5kZXgtYmFzZWQgZW51bXMgZm9yIGdsVEZcbiAgICAwOiBcIlwiLFxuICAgIDE6IFwibWVzaG9wdF9kZWNvZGVGaWx0ZXJPY3RcIixcbiAgICAyOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyUXVhdFwiLFxuICAgIDM6IFwibWVzaG9wdF9kZWNvZGVGaWx0ZXJFeHBcIixcbiAgICAvLyBzdHJpbmctYmFzZWQgZW51bXMgZm9yIGdsVEZcbiAgICBOT05FOiBcIlwiLFxuICAgIE9DVEFIRURSQUw6IFwibWVzaG9wdF9kZWNvZGVGaWx0ZXJPY3RcIixcbiAgICBRVUFURVJOSU9OOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyUXVhdFwiLFxuICAgIEVYUE9ORU5USUFMOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyRXhwXCJcbiAgfTtcbiAgY29uc3QgZGVjb2RlcnMgPSB7XG4gICAgLy8gbGVnYWN5IGluZGV4LWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgMDogXCJtZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlclwiLFxuICAgIDE6IFwibWVzaG9wdF9kZWNvZGVJbmRleEJ1ZmZlclwiLFxuICAgIDI6IFwibWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlXCIsXG4gICAgLy8gc3RyaW5nLWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgQVRUUklCVVRFUzogXCJtZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlclwiLFxuICAgIFRSSUFOR0xFUzogXCJtZXNob3B0X2RlY29kZUluZGV4QnVmZmVyXCIsXG4gICAgSU5ESUNFUzogXCJtZXNob3B0X2RlY29kZUluZGV4U2VxdWVuY2VcIlxuICB9O1xuICBnZW5lcmF0ZWQgPSB7XG4gICAgcmVhZHk6IHByb21pc2UsXG4gICAgc3VwcG9ydGVkOiB0cnVlLFxuICAgIGRlY29kZVZlcnRleEJ1ZmZlcih0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UsIGZpbHRlcikge1xuICAgICAgZGVjb2RlKFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzLm1lc2hvcHRfZGVjb2RlVmVydGV4QnVmZmVyLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGNvdW50LFxuICAgICAgICBzaXplLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbZmlsdGVyc1tmaWx0ZXJdXVxuICAgICAgKTtcbiAgICB9LFxuICAgIGRlY29kZUluZGV4QnVmZmVyKHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSkge1xuICAgICAgZGVjb2RlKGluc3RhbmNlLmV4cG9ydHMubWVzaG9wdF9kZWNvZGVJbmRleEJ1ZmZlciwgdGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlKTtcbiAgICB9LFxuICAgIGRlY29kZUluZGV4U2VxdWVuY2UodGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlKSB7XG4gICAgICBkZWNvZGUoaW5zdGFuY2UuZXhwb3J0cy5tZXNob3B0X2RlY29kZUluZGV4U2VxdWVuY2UsIHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSk7XG4gICAgfSxcbiAgICBkZWNvZGVHbHRmQnVmZmVyKHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSwgbW9kZSwgZmlsdGVyKSB7XG4gICAgICBkZWNvZGUoXG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbZGVjb2RlcnNbbW9kZV1dLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGNvdW50LFxuICAgICAgICBzaXplLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbZmlsdGVyc1tmaWx0ZXJdXVxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBnZW5lcmF0ZWQ7XG59O1xuZXhwb3J0IHtcbiAgTWVzaG9wdERlY29kZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNob3B0RGVjb2Rlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJnZW5lcmF0ZWQiLCJNZXNob3B0RGVjb2RlciIsIndhc21fYmFzZSIsIndhc21fc2ltZCIsImRldGVjdG9yIiwiVWludDhBcnJheSIsIndhc21wYWNrIiwiV2ViQXNzZW1ibHkiLCJzdXBwb3J0ZWQiLCJ3YXNtIiwidmFsaWRhdGUiLCJpbnN0YW5jZSIsInByb21pc2UiLCJpbnN0YW50aWF0ZSIsInVucGFjayIsInRoZW4iLCJyZXN1bHQiLCJleHBvcnRzIiwiX193YXNtX2NhbGxfY3RvcnMiLCJkYXRhIiwibGVuZ3RoIiwiaSIsImNoIiwiY2hhckNvZGVBdCIsIndyaXRlIiwiYnVmZmVyIiwic2xpY2UiLCJkZWNvZGUiLCJmdW4iLCJ0YXJnZXQiLCJjb3VudCIsInNpemUiLCJzb3VyY2UiLCJmaWx0ZXIiLCJzYnJrIiwiY291bnQ0IiwidHAiLCJzcCIsImhlYXAiLCJtZW1vcnkiLCJzZXQiLCJyZXMiLCJzdWJhcnJheSIsIkVycm9yIiwiZmlsdGVycyIsIk5PTkUiLCJPQ1RBSEVEUkFMIiwiUVVBVEVSTklPTiIsIkVYUE9ORU5USUFMIiwiZGVjb2RlcnMiLCJBVFRSSUJVVEVTIiwiVFJJQU5HTEVTIiwiSU5ESUNFUyIsInJlYWR5IiwiZGVjb2RlVmVydGV4QnVmZmVyIiwibWVzaG9wdF9kZWNvZGVWZXJ0ZXhCdWZmZXIiLCJkZWNvZGVJbmRleEJ1ZmZlciIsIm1lc2hvcHRfZGVjb2RlSW5kZXhCdWZmZXIiLCJkZWNvZGVJbmRleFNlcXVlbmNlIiwibWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlIiwiZGVjb2RlR2x0ZkJ1ZmZlciIsIm1vZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/DRACOLoader.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DRACOLoader: () => (/* binding */ DRACOLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(manager){\n        super(manager);\n        this.decoderPath = \"\";\n        this.decoderConfig = {};\n        this.decoderBinary = null;\n        this.decoderPending = null;\n        this.workerLimit = 4;\n        this.workerPool = [];\n        this.workerNextTaskID = 1;\n        this.workerSourceURL = \"\";\n        this.defaultAttributeIDs = {\n            position: \"POSITION\",\n            normal: \"NORMAL\",\n            color: \"COLOR\",\n            uv: \"TEX_COORD\"\n        };\n        this.defaultAttributeTypes = {\n            position: \"Float32Array\",\n            normal: \"Float32Array\",\n            color: \"Float32Array\",\n            uv: \"Float32Array\"\n        };\n    }\n    setDecoderPath(path) {\n        this.decoderPath = path;\n        return this;\n    }\n    setDecoderConfig(config) {\n        this.decoderConfig = config;\n        return this;\n    }\n    setWorkerLimit(workerLimit) {\n        this.workerLimit = workerLimit;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(url, (buffer)=>{\n            const taskConfig = {\n                attributeIDs: this.defaultAttributeIDs,\n                attributeTypes: this.defaultAttributeTypes,\n                useUniqueIDs: false\n            };\n            this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n        }, onProgress, onError);\n    }\n    /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */ decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n        const taskConfig = {\n            attributeIDs: attributeIDs || this.defaultAttributeIDs,\n            attributeTypes: attributeTypes || this.defaultAttributeTypes,\n            useUniqueIDs: !!attributeIDs\n        };\n        this.decodeGeometry(buffer, taskConfig).then(callback);\n    }\n    decodeGeometry(buffer, taskConfig) {\n        for(const attribute in taskConfig.attributeTypes){\n            const type = taskConfig.attributeTypes[attribute];\n            if (type.BYTES_PER_ELEMENT !== void 0) {\n                taskConfig.attributeTypes[attribute] = type.name;\n            }\n        }\n        const taskKey = JSON.stringify(taskConfig);\n        if (_taskCache.has(buffer)) {\n            const cachedTask = _taskCache.get(buffer);\n            if (cachedTask.key === taskKey) {\n                return cachedTask.promise;\n            } else if (buffer.byteLength === 0) {\n                throw new Error(\"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\");\n            }\n        }\n        let worker;\n        const taskID = this.workerNextTaskID++;\n        const taskCost = buffer.byteLength;\n        const geometryPending = this._getWorker(taskID, taskCost).then((_worker)=>{\n            worker = _worker;\n            return new Promise((resolve, reject)=>{\n                worker._callbacks[taskID] = {\n                    resolve,\n                    reject\n                };\n                worker.postMessage({\n                    type: \"decode\",\n                    id: taskID,\n                    taskConfig,\n                    buffer\n                }, [\n                    buffer\n                ]);\n            });\n        }).then((message)=>this._createGeometry(message.geometry));\n        geometryPending.catch(()=>true).then(()=>{\n            if (worker && taskID) {\n                this._releaseTask(worker, taskID);\n            }\n        });\n        _taskCache.set(buffer, {\n            key: taskKey,\n            promise: geometryPending\n        });\n        return geometryPending;\n    }\n    _createGeometry(geometryData) {\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n        if (geometryData.index) {\n            geometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(geometryData.index.array, 1));\n        }\n        for(let i = 0; i < geometryData.attributes.length; i++){\n            const attribute = geometryData.attributes[i];\n            const name = attribute.name;\n            const array = attribute.array;\n            const itemSize = attribute.itemSize;\n            geometry.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize));\n        }\n        return geometry;\n    }\n    _loadLibrary(url, responseType) {\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.decoderPath);\n        loader.setResponseType(responseType);\n        loader.setWithCredentials(this.withCredentials);\n        return new Promise((resolve, reject)=>{\n            loader.load(url, resolve, void 0, reject);\n        });\n    }\n    preload() {\n        this._initDecoder();\n        return this;\n    }\n    _initDecoder() {\n        if (this.decoderPending) return this.decoderPending;\n        const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n        const librariesPending = [];\n        if (useJS) {\n            librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n        } else {\n            librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n            librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n        }\n        this.decoderPending = Promise.all(librariesPending).then((libraries)=>{\n            const jsContent = libraries[0];\n            if (!useJS) {\n                this.decoderConfig.wasmBinary = libraries[1];\n            }\n            const fn = DRACOWorker.toString();\n            const body = [\n                \"/* draco decoder */\",\n                jsContent,\n                \"\",\n                \"/* worker */\",\n                fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n            ].join(\"\\n\");\n            this.workerSourceURL = URL.createObjectURL(new Blob([\n                body\n            ]));\n        });\n        return this.decoderPending;\n    }\n    _getWorker(taskID, taskCost) {\n        return this._initDecoder().then(()=>{\n            if (this.workerPool.length < this.workerLimit) {\n                const worker2 = new Worker(this.workerSourceURL);\n                worker2._callbacks = {};\n                worker2._taskCosts = {};\n                worker2._taskLoad = 0;\n                worker2.postMessage({\n                    type: \"init\",\n                    decoderConfig: this.decoderConfig\n                });\n                worker2.onmessage = function(e) {\n                    const message = e.data;\n                    switch(message.type){\n                        case \"decode\":\n                            worker2._callbacks[message.id].resolve(message);\n                            break;\n                        case \"error\":\n                            worker2._callbacks[message.id].reject(message);\n                            break;\n                        default:\n                            console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n                    }\n                };\n                this.workerPool.push(worker2);\n            } else {\n                this.workerPool.sort(function(a, b) {\n                    return a._taskLoad > b._taskLoad ? -1 : 1;\n                });\n            }\n            const worker = this.workerPool[this.workerPool.length - 1];\n            worker._taskCosts[taskID] = taskCost;\n            worker._taskLoad += taskCost;\n            return worker;\n        });\n    }\n    _releaseTask(worker, taskID) {\n        worker._taskLoad -= worker._taskCosts[taskID];\n        delete worker._callbacks[taskID];\n        delete worker._taskCosts[taskID];\n    }\n    debug() {\n        console.log(\"Task load: \", this.workerPool.map((worker)=>worker._taskLoad));\n    }\n    dispose() {\n        for(let i = 0; i < this.workerPool.length; ++i){\n            this.workerPool[i].terminate();\n        }\n        this.workerPool.length = 0;\n        return this;\n    }\n}\nfunction DRACOWorker() {\n    let decoderConfig;\n    let decoderPending;\n    onmessage = function(e) {\n        const message = e.data;\n        switch(message.type){\n            case \"init\":\n                decoderConfig = message.decoderConfig;\n                decoderPending = new Promise(function(resolve) {\n                    decoderConfig.onModuleLoaded = function(draco) {\n                        resolve({\n                            draco\n                        });\n                    };\n                    DracoDecoderModule(decoderConfig);\n                });\n                break;\n            case \"decode\":\n                const buffer = message.buffer;\n                const taskConfig = message.taskConfig;\n                decoderPending.then((module)=>{\n                    const draco = module.draco;\n                    const decoder = new draco.Decoder();\n                    const decoderBuffer = new draco.DecoderBuffer();\n                    decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n                    try {\n                        const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n                        const buffers = geometry.attributes.map((attr)=>attr.array.buffer);\n                        if (geometry.index) buffers.push(geometry.index.array.buffer);\n                        self.postMessage({\n                            type: \"decode\",\n                            id: message.id,\n                            geometry\n                        }, buffers);\n                    } catch (error) {\n                        console.error(error);\n                        self.postMessage({\n                            type: \"error\",\n                            id: message.id,\n                            error: error.message\n                        });\n                    } finally{\n                        draco.destroy(decoderBuffer);\n                        draco.destroy(decoder);\n                    }\n                });\n                break;\n        }\n    };\n    function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n        const attributeIDs = taskConfig.attributeIDs;\n        const attributeTypes = taskConfig.attributeTypes;\n        let dracoGeometry;\n        let decodingStatus;\n        const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n        if (geometryType === draco.TRIANGULAR_MESH) {\n            dracoGeometry = new draco.Mesh();\n            decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n        } else if (geometryType === draco.POINT_CLOUD) {\n            dracoGeometry = new draco.PointCloud();\n            decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n        } else {\n            throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n        }\n        if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n            throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n        }\n        const geometry = {\n            index: null,\n            attributes: []\n        };\n        for(const attributeName in attributeIDs){\n            const attributeType = self[attributeTypes[attributeName]];\n            let attribute;\n            let attributeID;\n            if (taskConfig.useUniqueIDs) {\n                attributeID = attributeIDs[attributeName];\n                attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n            } else {\n                attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n                if (attributeID === -1) continue;\n                attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n            }\n            geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n        }\n        if (geometryType === draco.TRIANGULAR_MESH) {\n            geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n        }\n        draco.destroy(dracoGeometry);\n        return geometry;\n    }\n    function decodeIndex(draco, decoder, dracoGeometry) {\n        const numFaces = dracoGeometry.num_faces();\n        const numIndices = numFaces * 3;\n        const byteLength = numIndices * 4;\n        const ptr = draco._malloc(byteLength);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n        const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        return {\n            array: index,\n            itemSize: 1\n        };\n    }\n    function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n        const numComponents = attribute.num_components();\n        const numPoints = dracoGeometry.num_points();\n        const numValues = numPoints * numComponents;\n        const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n        const dataType = getDracoDataType(draco, attributeType);\n        const ptr = draco._malloc(byteLength);\n        decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n        const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n        draco._free(ptr);\n        return {\n            name: attributeName,\n            array,\n            itemSize: numComponents\n        };\n    }\n    function getDracoDataType(draco, attributeType) {\n        switch(attributeType){\n            case Float32Array:\n                return draco.DT_FLOAT32;\n            case Int8Array:\n                return draco.DT_INT8;\n            case Int16Array:\n                return draco.DT_INT16;\n            case Int32Array:\n                return draco.DT_INT32;\n            case Uint8Array:\n                return draco.DT_UINT8;\n            case Uint16Array:\n                return draco.DT_UINT16;\n            case Uint32Array:\n                return draco.DT_UINT32;\n        }\n    }\n}\n //# sourceMappingURL=DRACOLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRFJBQ09Mb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEU7QUFDNUUsTUFBTUksYUFBYSxhQUFhLEdBQUcsSUFBSUM7QUFDdkMsTUFBTUMsb0JBQW9CTix5Q0FBTUE7SUFDOUJPLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsQ0FBQztRQUN0QixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLFVBQVUsR0FBRyxFQUFFO1FBQ3BCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztZQUN6QkMsVUFBVTtZQUNWQyxRQUFRO1lBQ1JDLE9BQU87WUFDUEMsSUFBSTtRQUNOO1FBQ0EsSUFBSSxDQUFDQyxxQkFBcUIsR0FBRztZQUMzQkosVUFBVTtZQUNWQyxRQUFRO1lBQ1JDLE9BQU87WUFDUEMsSUFBSTtRQUNOO0lBQ0Y7SUFDQUUsZUFBZUMsSUFBSSxFQUFFO1FBQ25CLElBQUksQ0FBQ2YsV0FBVyxHQUFHZTtRQUNuQixPQUFPLElBQUk7SUFDYjtJQUNBQyxpQkFBaUJDLE1BQU0sRUFBRTtRQUN2QixJQUFJLENBQUNoQixhQUFhLEdBQUdnQjtRQUNyQixPQUFPLElBQUk7SUFDYjtJQUNBQyxlQUFlZCxXQUFXLEVBQUU7UUFDMUIsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO1FBQ25CLE9BQU8sSUFBSTtJQUNiO0lBQ0FlLEtBQUtDLEdBQUcsRUFBRUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLE9BQU8sRUFBRTtRQUNyQyxNQUFNQyxTQUFTLElBQUloQyw2Q0FBVUEsQ0FBQyxJ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QUtDO2dCQUNILE9BQU94RCxNQUFNeUQsUUFBUTtZQUN2QixLQUFLQztnQkFDSCxPQUFPMUQsTUFBTTJELFFBQVE7WUFDdkIsS0FBS0M7Z0JBQ0gsT0FBTzVELE1BQU02RCxTQUFTO1lBQ3hCLEtBQUt0QjtnQkFDSCxPQUFPdkMsTUFBTThELFNBQVM7UUFDMUI7SUFDRjtBQUNGO0FBR0UsQ0FDRix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8zRC1BSS1FbmdsaXNoLy4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL0RSQUNPTG9hZGVyLmpzPzc0ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9hZGVyLCBGaWxlTG9hZGVyLCBCdWZmZXJHZW9tZXRyeSwgQnVmZmVyQXR0cmlidXRlIH0gZnJvbSBcInRocmVlXCI7XG5jb25zdCBfdGFza0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jbGFzcyBEUkFDT0xvYWRlciBleHRlbmRzIExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICB0aGlzLmRlY29kZXJQYXRoID0gXCJcIjtcbiAgICB0aGlzLmRlY29kZXJDb25maWcgPSB7fTtcbiAgICB0aGlzLmRlY29kZXJCaW5hcnkgPSBudWxsO1xuICAgIHRoaXMuZGVjb2RlclBlbmRpbmcgPSBudWxsO1xuICAgIHRoaXMud29ya2VyTGltaXQgPSA0O1xuICAgIHRoaXMud29ya2VyUG9vbCA9IFtdO1xuICAgIHRoaXMud29ya2VyTmV4dFRhc2tJRCA9IDE7XG4gICAgdGhpcy53b3JrZXJTb3VyY2VVUkwgPSBcIlwiO1xuICAgIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyA9IHtcbiAgICAgIHBvc2l0aW9uOiBcIlBPU0lUSU9OXCIsXG4gICAgICBub3JtYWw6IFwiTk9STUFMXCIsXG4gICAgICBjb2xvcjogXCJDT0xPUlwiLFxuICAgICAgdXY6IFwiVEVYX0NPT1JEXCJcbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVR5cGVzID0ge1xuICAgICAgcG9zaXRpb246IFwiRmxvYXQzMkFycmF5XCIsXG4gICAgICBub3JtYWw6IFwiRmxvYXQzMkFycmF5XCIsXG4gICAgICBjb2xvcjogXCJGbG9hdDMyQXJyYXlcIixcbiAgICAgIHV2OiBcIkZsb2F0MzJBcnJheVwiXG4gICAgfTtcbiAgfVxuICBzZXREZWNvZGVyUGF0aChwYXRoKSB7XG4gICAgdGhpcy5kZWNvZGVyUGF0aCA9IHBhdGg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0RGVjb2RlckNvbmZpZyhjb25maWcpIHtcbiAgICB0aGlzLmRlY29kZXJDb25maWcgPSBjb25maWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0V29ya2VyTGltaXQod29ya2VyTGltaXQpIHtcbiAgICB0aGlzLndvcmtlckxpbWl0ID0gd29ya2VyTGltaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG4gICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICBsb2FkZXIubG9hZChcbiAgICAgIHVybCxcbiAgICAgIChidWZmZXIpID0+IHtcbiAgICAgICAgY29uc3QgdGFza0NvbmZpZyA9IHtcbiAgICAgICAgICBhdHRyaWJ1dGVJRHM6IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyxcbiAgICAgICAgICBhdHRyaWJ1dGVUeXBlczogdGhpcy5kZWZhdWx0QXR0cmlidXRlVHlwZXMsXG4gICAgICAgICAgdXNlVW5pcXVlSURzOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlY29kZUdlb21ldHJ5KGJ1ZmZlciwgdGFza0NvbmZpZykudGhlbihvbkxvYWQpLmNhdGNoKG9uRXJyb3IpO1xuICAgICAgfSxcbiAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICBvbkVycm9yXG4gICAgKTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgS2VwdCBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eSB3aXRoIHByZXZpb3VzIERSQUNPTG9hZGVyIHZlcnNpb25zLiAqL1xuICBkZWNvZGVEcmFjb0ZpbGUoYnVmZmVyLCBjYWxsYmFjaywgYXR0cmlidXRlSURzLCBhdHRyaWJ1dGVUeXBlcykge1xuICAgIGNvbnN0IHRhc2tDb25maWcgPSB7XG4gICAgICBhdHRyaWJ1dGVJRHM6IGF0dHJpYnV0ZUlEcyB8fCB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVJRHMsXG4gICAgICBhdHRyaWJ1dGVUeXBlczogYXR0cmlidXRlVHlwZXMgfHwgdGhpcy5kZWZhdWx0QXR0cmlidXRlVHlwZXMsXG4gICAgICB1c2VVbmlxdWVJRHM6ICEhYXR0cmlidXRlSURzXG4gICAgfTtcbiAgICB0aGlzLmRlY29kZUdlb21ldHJ5KGJ1ZmZlciwgdGFza0NvbmZpZykudGhlbihjYWxsYmFjayk7XG4gIH1cbiAgZGVjb2RlR2VvbWV0cnkoYnVmZmVyLCB0YXNrQ29uZmlnKSB7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgaW4gdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlcykge1xuICAgICAgY29uc3QgdHlwZSA9IHRhc2tDb25maWcuYXR0cmlidXRlVHlwZXNbYXR0cmlidXRlXTtcbiAgICAgIGlmICh0eXBlLkJZVEVTX1BFUl9FTEVNRU5UICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlc1thdHRyaWJ1dGVdID0gdHlwZS5uYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YXNrS2V5ID0gSlNPTi5zdHJpbmdpZnkodGFza0NvbmZpZyk7XG4gICAgaWYgKF90YXNrQ2FjaGUuaGFzKGJ1ZmZlcikpIHtcbiAgICAgIGNvbnN0IGNhY2hlZFRhc2sgPSBfdGFza0NhY2hlLmdldChidWZmZXIpO1xuICAgICAgaWYgKGNhY2hlZFRhc2sua2V5ID09PSB0YXNrS2V5KSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRUYXNrLnByb21pc2U7XG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkRSQUNPTG9hZGVyOiBVbmFibGUgdG8gcmUtZGVjb2RlIGEgYnVmZmVyIHdpdGggZGlmZmVyZW50IHNldHRpbmdzLiBCdWZmZXIgaGFzIGFscmVhZHkgYmVlbiB0cmFuc2ZlcnJlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgd29ya2VyO1xuICAgIGNvbnN0IHRhc2tJRCA9IHRoaXMud29ya2VyTmV4dFRhc2tJRCsrO1xuICAgIGNvbnN0IHRhc2tDb3N0ID0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgZ2VvbWV0cnlQZW5kaW5nID0gdGhpcy5fZ2V0V29ya2VyKHRhc2tJRCwgdGFza0Nvc3QpLnRoZW4oKF93b3JrZXIpID0+IHtcbiAgICAgIHdvcmtlciA9IF93b3JrZXI7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB3b3JrZXIuX2NhbGxiYWNrc1t0YXNrSURdID0geyByZXNvbHZlLCByZWplY3QgfTtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJkZWNvZGVcIiwgaWQ6IHRhc2tJRCwgdGFza0NvbmZpZywgYnVmZmVyIH0sIFtidWZmZXJdKTtcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oKG1lc3NhZ2UpID0+IHRoaXMuX2NyZWF0ZUdlb21ldHJ5KG1lc3NhZ2UuZ2VvbWV0cnkpKTtcbiAgICBnZW9tZXRyeVBlbmRpbmcuY2F0Y2goKCkgPT4gdHJ1ZSkudGhlbigoKSA9PiB7XG4gICAgICBpZiAod29ya2VyICYmIHRhc2tJRCkge1xuICAgICAgICB0aGlzLl9yZWxlYXNlVGFzayh3b3JrZXIsIHRhc2tJRCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3Rhc2tDYWNoZS5zZXQoYnVmZmVyLCB7XG4gICAgICBrZXk6IHRhc2tLZXksXG4gICAgICBwcm9taXNlOiBnZW9tZXRyeVBlbmRpbmdcbiAgICB9KTtcbiAgICByZXR1cm4gZ2VvbWV0cnlQZW5kaW5nO1xuICB9XG4gIF9jcmVhdGVHZW9tZXRyeShnZW9tZXRyeURhdGEpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeURhdGEuaW5kZXgpIHtcbiAgICAgIGdlb21ldHJ5LnNldEluZGV4KG5ldyBCdWZmZXJBdHRyaWJ1dGUoZ2VvbWV0cnlEYXRhLmluZGV4LmFycmF5LCAxKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cnlEYXRhLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5RGF0YS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgY29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShuYW1lLCBuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbiAgX2xvYWRMaWJyYXJ5KHVybCwgcmVzcG9uc2VUeXBlKSB7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcbiAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLmRlY29kZXJQYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKHJlc3BvbnNlVHlwZSk7XG4gICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxvYWRlci5sb2FkKHVybCwgcmVzb2x2ZSwgdm9pZCAwLCByZWplY3QpO1xuICAgIH0pO1xuICB9XG4gIHByZWxvYWQoKSB7XG4gICAgdGhpcy5faW5pdERlY29kZXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfaW5pdERlY29kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGVjb2RlclBlbmRpbmcpXG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGVyUGVuZGluZztcbiAgICBjb25zdCB1c2VKUyA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gXCJvYmplY3RcIiB8fCB0aGlzLmRlY29kZXJDb25maWcudHlwZSA9PT0gXCJqc1wiO1xuICAgIGNvbnN0IGxpYnJhcmllc1BlbmRpbmcgPSBbXTtcbiAgICBpZiAodXNlSlMpIHtcbiAgICAgIGxpYnJhcmllc1BlbmRpbmcucHVzaCh0aGlzLl9sb2FkTGlicmFyeShcImRyYWNvX2RlY29kZXIuanNcIiwgXCJ0ZXh0XCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlicmFyaWVzUGVuZGluZy5wdXNoKHRoaXMuX2xvYWRMaWJyYXJ5KFwiZHJhY29fd2FzbV93cmFwcGVyLmpzXCIsIFwidGV4dFwiKSk7XG4gICAgICBsaWJyYXJpZXNQZW5kaW5nLnB1c2godGhpcy5fbG9hZExpYnJhcnkoXCJkcmFjb19kZWNvZGVyLndhc21cIiwgXCJhcnJheWJ1ZmZlclwiKSk7XG4gICAgfVxuICAgIHRoaXMuZGVjb2RlclBlbmRpbmcgPSBQcm9taXNlLmFsbChsaWJyYXJpZXNQZW5kaW5nKS50aGVuKChsaWJyYXJpZXMpID0+IHtcbiAgICAgIGNvbnN0IGpzQ29udGVudCA9IGxpYnJhcmllc1swXTtcbiAgICAgIGlmICghdXNlSlMpIHtcbiAgICAgICAgdGhpcy5kZWNvZGVyQ29uZmlnLndhc21CaW5hcnkgPSBsaWJyYXJpZXNbMV07XG4gICAgICB9XG4gICAgICBjb25zdCBmbiA9IERSQUNPV29ya2VyLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCBib2R5ID0gW1xuICAgICAgICBcIi8qIGRyYWNvIGRlY29kZXIgKi9cIixcbiAgICAgICAganNDb250ZW50LFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIi8qIHdvcmtlciAqL1wiLFxuICAgICAgICBmbi5zdWJzdHJpbmcoZm4uaW5kZXhPZihcIntcIikgKyAxLCBmbi5sYXN0SW5kZXhPZihcIn1cIikpXG4gICAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgICB0aGlzLndvcmtlclNvdXJjZVVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2JvZHldKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlclBlbmRpbmc7XG4gIH1cbiAgX2dldFdvcmtlcih0YXNrSUQsIHRhc2tDb3N0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXREZWNvZGVyKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAodGhpcy53b3JrZXJQb29sLmxlbmd0aCA8IHRoaXMud29ya2VyTGltaXQpIHtcbiAgICAgICAgY29uc3Qgd29ya2VyMiA9IG5ldyBXb3JrZXIodGhpcy53b3JrZXJTb3VyY2VVUkwpO1xuICAgICAgICB3b3JrZXIyLl9jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgd29ya2VyMi5fdGFza0Nvc3RzID0ge307XG4gICAgICAgIHdvcmtlcjIuX3Rhc2tMb2FkID0gMDtcbiAgICAgICAgd29ya2VyMi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiaW5pdFwiLCBkZWNvZGVyQ29uZmlnOiB0aGlzLmRlY29kZXJDb25maWcgfSk7XG4gICAgICAgIHdvcmtlcjIub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlLmRhdGE7XG4gICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkZWNvZGVcIjpcbiAgICAgICAgICAgICAgd29ya2VyMi5fY2FsbGJhY2tzW21lc3NhZ2UuaWRdLnJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgIHdvcmtlcjIuX2NhbGxiYWNrc1ttZXNzYWdlLmlkXS5yZWplY3QobWVzc2FnZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuRFJBQ09Mb2FkZXI6IFVuZXhwZWN0ZWQgbWVzc2FnZSwgXCInICsgbWVzc2FnZS50eXBlICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlclBvb2wucHVzaCh3b3JrZXIyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29ya2VyUG9vbC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5fdGFza0xvYWQgPiBiLl90YXNrTG9hZCA/IC0xIDogMTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrZXIgPSB0aGlzLndvcmtlclBvb2xbdGhpcy53b3JrZXJQb29sLmxlbmd0aCAtIDFdO1xuICAgICAgd29ya2VyLl90YXNrQ29zdHNbdGFza0lEXSA9IHRhc2tDb3N0O1xuICAgICAgd29ya2VyLl90YXNrTG9hZCArPSB0YXNrQ29zdDtcbiAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgfSk7XG4gIH1cbiAgX3JlbGVhc2VUYXNrKHdvcmtlciwgdGFza0lEKSB7XG4gICAgd29ya2VyLl90YXNrTG9hZCAtPSB3b3JrZXIuX3Rhc2tDb3N0c1t0YXNrSURdO1xuICAgIGRlbGV0ZSB3b3JrZXIuX2NhbGxiYWNrc1t0YXNrSURdO1xuICAgIGRlbGV0ZSB3b3JrZXIuX3Rhc2tDb3N0c1t0YXNrSURdO1xuICB9XG4gIGRlYnVnKCkge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgXCJUYXNrIGxvYWQ6IFwiLFxuICAgICAgdGhpcy53b3JrZXJQb29sLm1hcCgod29ya2VyKSA9PiB3b3JrZXIuX3Rhc2tMb2FkKVxuICAgICk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud29ya2VyUG9vbC5sZW5ndGg7ICsraSkge1xuICAgICAgdGhpcy53b3JrZXJQb29sW2ldLnRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLndvcmtlclBvb2wubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuZnVuY3Rpb24gRFJBQ09Xb3JrZXIoKSB7XG4gIGxldCBkZWNvZGVyQ29uZmlnO1xuICBsZXQgZGVjb2RlclBlbmRpbmc7XG4gIG9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZS5kYXRhO1xuICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICBjYXNlIFwiaW5pdFwiOlxuICAgICAgICBkZWNvZGVyQ29uZmlnID0gbWVzc2FnZS5kZWNvZGVyQ29uZmlnO1xuICAgICAgICBkZWNvZGVyUGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICBkZWNvZGVyQ29uZmlnLm9uTW9kdWxlTG9hZGVkID0gZnVuY3Rpb24oZHJhY28pIHtcbiAgICAgICAgICAgIHJlc29sdmUoeyBkcmFjbyB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIERyYWNvRGVjb2Rlck1vZHVsZShkZWNvZGVyQ29uZmlnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRlY29kZVwiOlxuICAgICAgICBjb25zdCBidWZmZXIgPSBtZXNzYWdlLmJ1ZmZlcjtcbiAgICAgICAgY29uc3QgdGFza0NvbmZpZyA9IG1lc3NhZ2UudGFza0NvbmZpZztcbiAgICAgICAgZGVjb2RlclBlbmRpbmcudGhlbigobW9kdWxlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZHJhY28gPSBtb2R1bGUuZHJhY287XG4gICAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBkcmFjby5EZWNvZGVyKCk7XG4gICAgICAgICAgY29uc3QgZGVjb2RlckJ1ZmZlciA9IG5ldyBkcmFjby5EZWNvZGVyQnVmZmVyKCk7XG4gICAgICAgICAgZGVjb2RlckJ1ZmZlci5Jbml0KG5ldyBJbnQ4QXJyYXkoYnVmZmVyKSwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IGRlY29kZUdlb21ldHJ5KGRyYWNvLCBkZWNvZGVyLCBkZWNvZGVyQnVmZmVyLCB0YXNrQ29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT4gYXR0ci5hcnJheS5idWZmZXIpO1xuICAgICAgICAgICAgaWYgKGdlb21ldHJ5LmluZGV4KVxuICAgICAgICAgICAgICBidWZmZXJzLnB1c2goZ2VvbWV0cnkuaW5kZXguYXJyYXkuYnVmZmVyKTtcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImRlY29kZVwiLCBpZDogbWVzc2FnZS5pZCwgZ2VvbWV0cnkgfSwgYnVmZmVycyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZXJyb3JcIiwgaWQ6IG1lc3NhZ2UuaWQsIGVycm9yOiBlcnJvci5tZXNzYWdlIH0pO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBkcmFjby5kZXN0cm95KGRlY29kZXJCdWZmZXIpO1xuICAgICAgICAgICAgZHJhY28uZGVzdHJveShkZWNvZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGRlY29kZUdlb21ldHJ5KGRyYWNvLCBkZWNvZGVyLCBkZWNvZGVyQnVmZmVyLCB0YXNrQ29uZmlnKSB7XG4gICAgY29uc3QgYXR0cmlidXRlSURzID0gdGFza0NvbmZpZy5hdHRyaWJ1dGVJRHM7XG4gICAgY29uc3QgYXR0cmlidXRlVHlwZXMgPSB0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzO1xuICAgIGxldCBkcmFjb0dlb21ldHJ5O1xuICAgIGxldCBkZWNvZGluZ1N0YXR1cztcbiAgICBjb25zdCBnZW9tZXRyeVR5cGUgPSBkZWNvZGVyLkdldEVuY29kZWRHZW9tZXRyeVR5cGUoZGVjb2RlckJ1ZmZlcik7XG4gICAgaWYgKGdlb21ldHJ5VHlwZSA9PT0gZHJhY28uVFJJQU5HVUxBUl9NRVNIKSB7XG4gICAgICBkcmFjb0dlb21ldHJ5ID0gbmV3IGRyYWNvLk1lc2goKTtcbiAgICAgIGRlY29kaW5nU3RhdHVzID0gZGVjb2Rlci5EZWNvZGVCdWZmZXJUb01lc2goZGVjb2RlckJ1ZmZlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeVR5cGUgPT09IGRyYWNvLlBPSU5UX0NMT1VEKSB7XG4gICAgICBkcmFjb0dlb21ldHJ5ID0gbmV3IGRyYWNvLlBvaW50Q2xvdWQoKTtcbiAgICAgIGRlY29kaW5nU3RhdHVzID0gZGVjb2Rlci5EZWNvZGVCdWZmZXJUb1BvaW50Q2xvdWQoZGVjb2RlckJ1ZmZlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkRSQUNPTG9hZGVyOiBVbmV4cGVjdGVkIGdlb21ldHJ5IHR5cGUuXCIpO1xuICAgIH1cbiAgICBpZiAoIWRlY29kaW5nU3RhdHVzLm9rKCkgfHwgZHJhY29HZW9tZXRyeS5wdHIgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkRSQUNPTG9hZGVyOiBEZWNvZGluZyBmYWlsZWQ6IFwiICsgZGVjb2RpbmdTdGF0dXMuZXJyb3JfbXNnKCkpO1xuICAgIH1cbiAgICBjb25zdCBnZW9tZXRyeSA9IHsgaW5kZXg6IG51bGwsIGF0dHJpYnV0ZXM6IFtdIH07XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZUlEcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlVHlwZSA9IHNlbGZbYXR0cmlidXRlVHlwZXNbYXR0cmlidXRlTmFtZV1dO1xuICAgICAgbGV0IGF0dHJpYnV0ZTtcbiAgICAgIGxldCBhdHRyaWJ1dGVJRDtcbiAgICAgIGlmICh0YXNrQ29uZmlnLnVzZVVuaXF1ZUlEcykge1xuICAgICAgICBhdHRyaWJ1dGVJRCA9IGF0dHJpYnV0ZUlEc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgYXR0cmlidXRlID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGVCeVVuaXF1ZUlkKGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZUlEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZUlEID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGVJZChkcmFjb0dlb21ldHJ5LCBkcmFjb1thdHRyaWJ1dGVJRHNbYXR0cmlidXRlTmFtZV1dKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZUlEID09PSAtMSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXR0cmlidXRlID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGUoZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlSUQpO1xuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wdXNoKGRlY29kZUF0dHJpYnV0ZShkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgYXR0cmlidXRlKSk7XG4gICAgfVxuICAgIGlmIChnZW9tZXRyeVR5cGUgPT09IGRyYWNvLlRSSUFOR1VMQVJfTUVTSCkge1xuICAgICAgZ2VvbWV0cnkuaW5kZXggPSBkZWNvZGVJbmRleChkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfVxuICAgIGRyYWNvLmRlc3Ryb3koZHJhY29HZW9tZXRyeSk7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZUluZGV4KGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5KSB7XG4gICAgY29uc3QgbnVtRmFjZXMgPSBkcmFjb0dlb21ldHJ5Lm51bV9mYWNlcygpO1xuICAgIGNvbnN0IG51bUluZGljZXMgPSBudW1GYWNlcyAqIDM7XG4gICAgY29uc3QgYnl0ZUxlbmd0aCA9IG51bUluZGljZXMgKiA0O1xuICAgIGNvbnN0IHB0ciA9IGRyYWNvLl9tYWxsb2MoYnl0ZUxlbmd0aCk7XG4gICAgZGVjb2Rlci5HZXRUcmlhbmdsZXNVSW50MzJBcnJheShkcmFjb0dlb21ldHJ5LCBieXRlTGVuZ3RoLCBwdHIpO1xuICAgIGNvbnN0IGluZGV4ID0gbmV3IFVpbnQzMkFycmF5KGRyYWNvLkhFQVBGMzIuYnVmZmVyLCBwdHIsIG51bUluZGljZXMpLnNsaWNlKCk7XG4gICAgZHJhY28uX2ZyZWUocHRyKTtcbiAgICByZXR1cm4geyBhcnJheTogaW5kZXgsIGl0ZW1TaXplOiAxIH07XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlQXR0cmlidXRlKGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCBudW1Db21wb25lbnRzID0gYXR0cmlidXRlLm51bV9jb21wb25lbnRzKCk7XG4gICAgY29uc3QgbnVtUG9pbnRzID0gZHJhY29HZW9tZXRyeS5udW1fcG9pbnRzKCk7XG4gICAgY29uc3QgbnVtVmFsdWVzID0gbnVtUG9pbnRzICogbnVtQ29tcG9uZW50cztcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gbnVtVmFsdWVzICogYXR0cmlidXRlVHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGdldERyYWNvRGF0YVR5cGUoZHJhY28sIGF0dHJpYnV0ZVR5cGUpO1xuICAgIGNvbnN0IHB0ciA9IGRyYWNvLl9tYWxsb2MoYnl0ZUxlbmd0aCk7XG4gICAgZGVjb2Rlci5HZXRBdHRyaWJ1dGVEYXRhQXJyYXlGb3JBbGxQb2ludHMoZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlLCBkYXRhVHlwZSwgYnl0ZUxlbmd0aCwgcHRyKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBhdHRyaWJ1dGVUeXBlKGRyYWNvLkhFQVBGMzIuYnVmZmVyLCBwdHIsIG51bVZhbHVlcykuc2xpY2UoKTtcbiAgICBkcmFjby5fZnJlZShwdHIpO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgYXJyYXksXG4gICAgICBpdGVtU2l6ZTogbnVtQ29tcG9uZW50c1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RHJhY29EYXRhVHlwZShkcmFjbywgYXR0cmlidXRlVHlwZSkge1xuICAgIHN3aXRjaCAoYXR0cmlidXRlVHlwZSkge1xuICAgICAgY2FzZSBGbG9hdDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9GTE9BVDMyO1xuICAgICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9JTlQ4O1xuICAgICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfSU5UMTY7XG4gICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9JTlQzMjtcbiAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX1VJTlQ4O1xuICAgICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX1VJTlQxNjtcbiAgICAgIGNhc2UgVWludDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9VSU5UMzI7XG4gICAgfVxuICB9XG59XG5leHBvcnQge1xuICBEUkFDT0xvYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURSQUNPTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkxvYWRlciIsIkZpbGVMb2FkZXIiLCJCdWZmZXJHZW9tZXRyeSIsIkJ1ZmZlckF0dHJpYnV0ZSIsIl90YXNrQ2FjaGUiLCJXZWFrTWFwIiwiRFJBQ09Mb2FkZXIiLCJjb25zdHJ1Y3RvciIsIm1hbmFnZXIiLCJkZWNvZGVyUGF0aCIsImRlY29kZXJDb25maWciLCJkZWNvZGVyQmluYXJ5IiwiZGVjb2RlclBlbmRpbmciLCJ3b3JrZXJMaW1pdCIsIndvcmtlclBvb2wiLCJ3b3JrZXJOZXh0VGFza0lEIiwid29ya2VyU291cmNlVVJMIiwiZGVmYXVsdEF0dHJpYnV0ZUlEcyIsInBvc2l0aW9uIiwibm9ybWFsIiwiY29sb3IiLCJ1diIsImRlZmF1bHRBdHRyaWJ1dGVUeXBlcyIsInNldERlY29kZXJQYXRoIiwicGF0aCIsInNldERlY29kZXJDb25maWciLCJjb25maWciLCJzZXRXb3JrZXJMaW1pdCIsImxvYWQiLCJ1cmwiLCJvbkxvYWQiLCJvblByb2dyZXNzIiwib25FcnJvciIsImxvYWRlciIsInNldFBhdGgiLCJzZXRSZXNwb25zZVR5cGUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwicmVxdWVzdEhlYWRlciIsInNldFdpdGhDcmVkZW50aWFscyIsIndpdGhDcmVkZW50aWFscyIsImJ1ZmZlciIsInRhc2tDb25maWciLCJhdHRyaWJ1dGVJRHMiLCJhdHRyaWJ1dGVUeXBlcyIsInVzZVVuaXF1ZUlEcyIsImRlY29kZUdlb21ldHJ5IiwidGhlbiIsImNhdGNoIiwiZGVjb2RlRHJhY29GaWxlIiwiY2FsbGJhY2siLCJhdHRyaWJ1dGUiLCJ0eXBlIiwiQllURVNfUEVSX0VMRU1FTlQiLCJuYW1lIiwidGFza0tleSIsIkpTT04iLCJzdHJpbmdpZnkiLCJoYXMiLCJjYWNoZWRUYXNrIiwiZ2V0Iiwia2V5IiwicHJvbWlzZSIsImJ5dGVMZW5ndGgiLCJFcnJvciIsIndvcmtlciIsInRhc2tJRCIsInRhc2tDb3N0IiwiZ2VvbWV0cnlQZW5kaW5nIiwiX2dldFdvcmtlciIsIl93b3JrZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIl9jYWxsYmFja3MiLCJwb3N0TWVzc2FnZSIsImlkIiwibWVzc2FnZSIsIl9jcmVhdGVHZW9tZXRyeSIsImdlb21ldHJ5IiwiX3JlbGVhc2VUYXNrIiwic2V0IiwiZ2VvbWV0cnlEYXRhIiwiaW5kZXgiLCJzZXRJbmRleCIsImFycmF5IiwiaSIsImF0dHJpYnV0ZXMiLCJsZW5ndGgiLCJpdGVtU2l6ZSIsInNldEF0dHJpYnV0ZSIsIl9sb2FkTGlicmFyeSIsInJlc3BvbnNlVHlwZSIsInByZWxvYWQiLCJfaW5pdERlY29kZXIiLCJ1c2VKUyIsIldlYkFzc2VtYmx5IiwibGlicmFyaWVzUGVuZGluZyIsInB1c2giLCJhbGwiLCJsaWJyYXJpZXMiLCJqc0NvbnRlbnQiLCJ3YXNtQmluYXJ5IiwiZm4iLCJEUkFDT1dvcmtlciIsInRvU3RyaW5nIiwiYm9keSIsInN1YnN0cmluZyIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImpvaW4iLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJCbG9iIiwid29ya2VyMiIsIldvcmtlciIsIl90YXNrQ29zdHMiLCJfdGFza0xvYWQiLCJvbm1lc3NhZ2UiLCJlIiwiZGF0YSIsImNvbnNvbGUiLCJlcnJvciIsInNvcnQiLCJhIiwiYiIsImRlYnVnIiwibG9nIiwibWFwIiwiZGlzcG9zZSIsInRlcm1pbmF0ZSIsIm9uTW9kdWxlTG9hZGVkIiwiZHJhY28iLCJEcmFjb0RlY29kZXJNb2R1bGUiLCJtb2R1bGUiLCJkZWNvZGVyIiwiRGVjb2RlciIsImRlY29kZXJCdWZmZXIiLCJEZWNvZGVyQnVmZmVyIiwiSW5pdCIsIkludDhBcnJheSIsImJ1ZmZlcnMiLCJhdHRyIiwic2VsZiIsImRlc3Ryb3kiLCJkcmFjb0dlb21ldHJ5IiwiZGVjb2RpbmdTdGF0dXMiLCJnZW9tZXRyeVR5cGUiLCJHZXRFbmNvZGVkR2VvbWV0cnlUeXBlIiwiVFJJQU5HVUxBUl9NRVNIIiwiTWVzaCIsIkRlY29kZUJ1ZmZlclRvTWVzaCIsIlBPSU5UX0NMT1VEIiwiUG9pbnRDbG91ZCIsIkRlY29kZUJ1ZmZlclRvUG9pbnRDbG91ZCIsIm9rIiwicHRyIiwiZXJyb3JfbXNnIiwiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZVR5cGUiLCJhdHRyaWJ1dGVJRCIsIkdldEF0dHJpYnV0ZUJ5VW5pcXVlSWQiLCJHZXRBdHRyaWJ1dGVJZCIsIkdldEF0dHJpYnV0ZSIsImRlY29kZUF0dHJpYnV0ZSIsImRlY29kZUluZGV4IiwibnVtRmFjZXMiLCJudW1fZmFjZXMiLCJudW1JbmRpY2VzIiwiX21hbGxvYyIsIkdldFRyaWFuZ2xlc1VJbnQzMkFycmF5IiwiVWludDMyQXJyYXkiLCJIRUFQRjMyIiwic2xpY2UiLCJfZnJlZSIsIm51bUNvbXBvbmVudHMiLCJudW1fY29tcG9uZW50cyIsIm51bVBvaW50cyIsIm51bV9wb2ludHMiLCJudW1WYWx1ZXMiLCJkYXRhVHlwZSIsImdldERyYWNvRGF0YVR5cGUiLCJHZXRBdHRyaWJ1dGVEYXRhQXJyYXlGb3JBbGxQb2ludHMiLCJGbG9hdDMyQXJyYXkiLCJEVF9GTE9BVDMyIiwiRFRfSU5UOCIsIkludDE2QXJyYXkiLCJEVF9JTlQxNiIsIkludDMyQXJyYXkiLCJEVF9JTlQzMiIsIlVpbnQ4QXJyYXkiLCJEVF9VSU5UOCIsIlVpbnQxNkFycmF5IiwiRFRfVUlOVDE2IiwiRFRfVUlOVDMyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/EXRLoader.js":
/*!********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/EXRLoader.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXRLoader: () => (/* binding */ EXRLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fflate */ \"(ssr)/./node_modules/three-stdlib/node_modules/fflate/esm/index.mjs\");\n\n\nconst hasColorSpace = \"colorSpace\" in new three__WEBPACK_IMPORTED_MODULE_0__.Texture();\nclass EXRLoader extends three__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader {\n    constructor(manager){\n        super(manager);\n        this.type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n    }\n    parse(buffer) {\n        const USHORT_RANGE = 1 << 16;\n        const BITMAP_SIZE = USHORT_RANGE >> 3;\n        const HUF_ENCBITS = 16;\n        const HUF_DECBITS = 14;\n        const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n        const HUF_DECSIZE = 1 << HUF_DECBITS;\n        const HUF_DECMASK = HUF_DECSIZE - 1;\n        const NBITS = 16;\n        const A_OFFSET = 1 << NBITS - 1;\n        const MOD_MASK = (1 << NBITS) - 1;\n        const SHORT_ZEROCODE_RUN = 59;\n        const LONG_ZEROCODE_RUN = 63;\n        const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n        const ULONG_SIZE = 8;\n        const FLOAT32_SIZE = 4;\n        const INT32_SIZE = 4;\n        const INT16_SIZE = 2;\n        const INT8_SIZE = 1;\n        const STATIC_HUFFMAN = 0;\n        const DEFLATE = 1;\n        const UNKNOWN = 0;\n        const LOSSY_DCT = 1;\n        const RLE = 2;\n        const logBase = Math.pow(2.7182818, 2.2);\n        function reverseLutFromBitmap(bitmap, lut) {\n            var k = 0;\n            for(var i = 0; i < USHORT_RANGE; ++i){\n                if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n                    lut[k++] = i;\n                }\n            }\n            var n = k - 1;\n            while(k < USHORT_RANGE)lut[k++] = 0;\n            return n;\n        }\n        function hufClearDecTable(hdec) {\n            for(var i = 0; i < HUF_DECSIZE; i++){\n                hdec[i] = {};\n                hdec[i].len = 0;\n                hdec[i].lit = 0;\n                hdec[i].p = null;\n            }\n        }\n        const getBitsReturn = {\n            l: 0,\n            c: 0,\n            lc: 0\n        };\n        function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n            while(lc < nBits){\n                c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n                lc += 8;\n            }\n            lc -= nBits;\n            getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n            getBitsReturn.c = c;\n            getBitsReturn.lc = lc;\n        }\n        const hufTableBuffer = new Array(59);\n        function hufCanonicalCodeTable(hcode) {\n            for(var i = 0; i <= 58; ++i)hufTableBuffer[i] = 0;\n            for(var i = 0; i < HUF_ENCSIZE; ++i)hufTableBuffer[hcode[i]] += 1;\n            var c = 0;\n            for(var i = 58; i > 0; --i){\n                var nc = c + hufTableBuffer[i] >> 1;\n                hufTableBuffer[i] = c;\n                c = nc;\n            }\n            for(var i = 0; i < HUF_ENCSIZE; ++i){\n                var l = hcode[i];\n                if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n            }\n        }\n        function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n            var p = inOffset;\n            var c = 0;\n            var lc = 0;\n            for(; im <= iM; im++){\n                if (p.value - inOffset.value > ni) return false;\n                getBits(6, c, lc, uInt8Array2, p);\n                var l = getBitsReturn.l;\n                c = getBitsReturn.c;\n                lc = getBitsReturn.lc;\n                hcode[im] = l;\n                if (l == LONG_ZEROCODE_RUN) {\n                    if (p.value - inOffset.value > ni) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    getBits(8, c, lc, uInt8Array2, p);\n                    var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n                    c = getBitsReturn.c;\n                    lc = getBitsReturn.lc;\n                    if (im + zerun > iM + 1) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    while(zerun--)hcode[im++] = 0;\n                    im--;\n                } else if (l >= SHORT_ZEROCODE_RUN) {\n                    var zerun = l - SHORT_ZEROCODE_RUN + 2;\n                    if (im + zerun > iM + 1) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    while(zerun--)hcode[im++] = 0;\n                    im--;\n                }\n            }\n            hufCanonicalCodeTable(hcode);\n        }\n        function hufLength(code) {\n            return code & 63;\n        }\n        function hufCode(code) {\n            return code >> 6;\n        }\n        function hufBuildDecTable(hcode, im, iM, hdecod) {\n            for(; im <= iM; im++){\n                var c = hufCode(hcode[im]);\n                var l = hufLength(hcode[im]);\n                if (c >> l) {\n                    throw \"Invalid table entry\";\n                }\n                if (l > HUF_DECBITS) {\n                    var pl = hdecod[c >> l - HUF_DECBITS];\n                    if (pl.len) {\n                        throw \"Invalid table entry\";\n                    }\n                    pl.lit++;\n                    if (pl.p) {\n                        var p = pl.p;\n                        pl.p = new Array(pl.lit);\n                        for(var i = 0; i < pl.lit - 1; ++i){\n                            pl.p[i] = p[i];\n                        }\n                    } else {\n                        pl.p = new Array(1);\n                    }\n                    pl.p[pl.lit - 1] = im;\n                } else if (l) {\n                    var plOffset = 0;\n                    for(var i = 1 << HUF_DECBITS - l; i > 0; i--){\n                        var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n                        if (pl.len || pl.p) {\n                            throw \"Invalid table entry\";\n                        }\n                        pl.len = l;\n                        pl.lit = im;\n                        plOffset++;\n                    }\n                }\n            }\n            return true;\n        }\n        const getCharReturn = {\n            c: 0,\n            lc: 0\n        };\n        function getChar(c, lc, uInt8Array2, inOffset) {\n            c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n            lc += 8;\n            getCharReturn.c = c;\n            getCharReturn.lc = lc;\n        }\n        const getCodeReturn = {\n            c: 0,\n            lc: 0\n        };\n        function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n            if (po == rlc) {\n                if (lc < 8) {\n                    getChar(c, lc, uInt8Array2, inOffset);\n                    c = getCharReturn.c;\n                    lc = getCharReturn.lc;\n                }\n                lc -= 8;\n                var cs = c >> lc;\n                var cs = new Uint8Array([\n                    cs\n                ])[0];\n                if (outBufferOffset.value + cs > outBufferEndOffset) {\n                    return false;\n                }\n                var s = outBuffer[outBufferOffset.value - 1];\n                while(cs-- > 0){\n                    outBuffer[outBufferOffset.value++] = s;\n                }\n            } else if (outBufferOffset.value < outBufferEndOffset) {\n                outBuffer[outBufferOffset.value++] = po;\n            } else {\n                return false;\n            }\n            getCodeReturn.c = c;\n            getCodeReturn.lc = lc;\n        }\n        function UInt16(value) {\n            return value & 65535;\n        }\n        function Int16(value) {\n            var ref = UInt16(value);\n            return ref > 32767 ? ref - 65536 : ref;\n        }\n        const wdec14Return = {\n            a: 0,\n            b: 0\n        };\n        function wdec14(l, h) {\n            var ls = Int16(l);\n            var hs = Int16(h);\n            var hi = hs;\n            var ai = ls + (hi & 1) + (hi >> 1);\n            var as = ai;\n            var bs = ai - hi;\n            wdec14Return.a = as;\n            wdec14Return.b = bs;\n        }\n        function wdec16(l, h) {\n            var m = UInt16(l);\n            var d = UInt16(h);\n            var bb = m - (d >> 1) & MOD_MASK;\n            var aa = d + bb - A_OFFSET & MOD_MASK;\n            wdec14Return.a = aa;\n            wdec14Return.b = bb;\n        }\n        function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n            var w14 = mx < 1 << 14;\n            var n = nx > ny ? ny : nx;\n            var p = 1;\n            var p2;\n            while(p <= n)p <<= 1;\n            p >>= 1;\n            p2 = p;\n            p >>= 1;\n            while(p >= 1){\n                var py = 0;\n                var ey = py + oy * (ny - p2);\n                var oy1 = oy * p;\n                var oy2 = oy * p2;\n                var ox1 = ox * p;\n                var ox2 = ox * p2;\n                var i00, i01, i10, i11;\n                for(; py <= ey; py += oy2){\n                    var px = py;\n                    var ex = py + ox * (nx - p2);\n                    for(; px <= ex; px += ox2){\n                        var p01 = px + ox1;\n                        var p10 = px + oy1;\n                        var p11 = p10 + ox1;\n                        if (w14) {\n                            wdec14(buffer2[px + j], buffer2[p10 + j]);\n                            i00 = wdec14Return.a;\n                            i10 = wdec14Return.b;\n                            wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n                            i01 = wdec14Return.a;\n                            i11 = wdec14Return.b;\n                            wdec14(i00, i01);\n                            buffer2[px + j] = wdec14Return.a;\n                            buffer2[p01 + j] = wdec14Return.b;\n                            wdec14(i10, i11);\n                            buffer2[p10 + j] = wdec14Return.a;\n                            buffer2[p11 + j] = wdec14Return.b;\n                        } else {\n                            wdec16(buffer2[px + j], buffer2[p10 + j]);\n                            i00 = wdec14Return.a;\n                            i10 = wdec14Return.b;\n                            wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n                            i01 = wdec14Return.a;\n                            i11 = wdec14Return.b;\n                            wdec16(i00, i01);\n                            buffer2[px + j] = wdec14Return.a;\n                            buffer2[p01 + j] = wdec14Return.b;\n                            wdec16(i10, i11);\n                            buffer2[p10 + j] = wdec14Return.a;\n                            buffer2[p11 + j] = wdec14Return.b;\n                        }\n                    }\n                    if (nx & p) {\n                        var p10 = px + oy1;\n                        if (w14) wdec14(buffer2[px + j], buffer2[p10 + j]);\n                        else wdec16(buffer2[px + j], buffer2[p10 + j]);\n                        i00 = wdec14Return.a;\n                        buffer2[p10 + j] = wdec14Return.b;\n                        buffer2[px + j] = i00;\n                    }\n                }\n                if (ny & p) {\n                    var px = py;\n                    var ex = py + ox * (nx - p2);\n                    for(; px <= ex; px += ox2){\n                        var p01 = px + ox1;\n                        if (w14) wdec14(buffer2[px + j], buffer2[p01 + j]);\n                        else wdec16(buffer2[px + j], buffer2[p01 + j]);\n                        i00 = wdec14Return.a;\n                        buffer2[p01 + j] = wdec14Return.b;\n                        buffer2[px + j] = i00;\n                    }\n                }\n                p2 = p;\n                p >>= 1;\n            }\n            return py;\n        }\n        function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n            var c = 0;\n            var lc = 0;\n            var outBufferEndOffset = no;\n            var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n            while(inOffset.value < inOffsetEnd){\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n                while(lc >= HUF_DECBITS){\n                    var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n                    var pl = decodingTable[index];\n                    if (pl.len) {\n                        lc -= pl.len;\n                        getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                        c = getCodeReturn.c;\n                        lc = getCodeReturn.lc;\n                    } else {\n                        if (!pl.p) {\n                            throw \"hufDecode issues\";\n                        }\n                        var j;\n                        for(j = 0; j < pl.lit; j++){\n                            var l = hufLength(encodingTable[pl.p[j]]);\n                            while(lc < l && inOffset.value < inOffsetEnd){\n                                getChar(c, lc, uInt8Array2, inOffset);\n                                c = getCharReturn.c;\n                                lc = getCharReturn.lc;\n                            }\n                            if (lc >= l) {\n                                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                                    lc -= l;\n                                    getCode(pl.p[j], rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                                    c = getCodeReturn.c;\n                                    lc = getCodeReturn.lc;\n                                    break;\n                                }\n                            }\n                        }\n                        if (j == pl.lit) {\n                            throw \"hufDecode issues\";\n                        }\n                    }\n                }\n            }\n            var i = 8 - ni & 7;\n            c >>= i;\n            lc -= i;\n            while(lc > 0){\n                var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n                if (pl.len) {\n                    lc -= pl.len;\n                    getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                    c = getCodeReturn.c;\n                    lc = getCodeReturn.lc;\n                } else {\n                    throw \"hufDecode issues\";\n                }\n            }\n            return true;\n        }\n        function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n            var outOffset = {\n                value: 0\n            };\n            var initialInOffset = inOffset.value;\n            var im = parseUint32(inDataView, inOffset);\n            var iM = parseUint32(inDataView, inOffset);\n            inOffset.value += 4;\n            var nBits = parseUint32(inDataView, inOffset);\n            inOffset.value += 4;\n            if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n                throw \"Something wrong with HUF_ENCSIZE\";\n            }\n            var freq = new Array(HUF_ENCSIZE);\n            var hdec = new Array(HUF_DECSIZE);\n            hufClearDecTable(hdec);\n            var ni = nCompressed - (inOffset.value - initialInOffset);\n            hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n            if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n                throw \"Something wrong with hufUncompress\";\n            }\n            hufBuildDecTable(freq, im, iM, hdec);\n            hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n        }\n        function applyLut(lut, data, nData) {\n            for(var i = 0; i < nData; ++i){\n                data[i] = lut[data[i]];\n            }\n        }\n        function predictor(source) {\n            for(var t = 1; t < source.length; t++){\n                var d = source[t - 1] + source[t] - 128;\n                source[t] = d;\n            }\n        }\n        function interleaveScalar(source, out) {\n            var t1 = 0;\n            var t2 = Math.floor((source.length + 1) / 2);\n            var s = 0;\n            var stop = source.length - 1;\n            while(true){\n                if (s > stop) break;\n                out[s++] = source[t1++];\n                if (s > stop) break;\n                out[s++] = source[t2++];\n            }\n        }\n        function decodeRunLength(source) {\n            var size = source.byteLength;\n            var out = new Array();\n            var p = 0;\n            var reader = new DataView(source);\n            while(size > 0){\n                var l = reader.getInt8(p++);\n                if (l < 0) {\n                    var count = -l;\n                    size -= count + 1;\n                    for(var i = 0; i < count; i++){\n                        out.push(reader.getUint8(p++));\n                    }\n                } else {\n                    var count = l;\n                    size -= 2;\n                    var value = reader.getUint8(p++);\n                    for(var i = 0; i < count + 1; i++){\n                        out.push(value);\n                    }\n                }\n            }\n            return out;\n        }\n        function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n            var dataView = new DataView(outBuffer.buffer);\n            var width = channelData[cscSet.idx[0]].width;\n            var height = channelData[cscSet.idx[0]].height;\n            var numComp = 3;\n            var numFullBlocksX = Math.floor(width / 8);\n            var numBlocksX = Math.ceil(width / 8);\n            var numBlocksY = Math.ceil(height / 8);\n            var leftoverX = width - (numBlocksX - 1) * 8;\n            var leftoverY = height - (numBlocksY - 1) * 8;\n            var currAcComp = {\n                value: 0\n            };\n            var currDcComp = new Array(numComp);\n            var dctData = new Array(numComp);\n            var halfZigBlock = new Array(numComp);\n            var rowBlock = new Array(numComp);\n            var rowOffsets = new Array(numComp);\n            for(let comp2 = 0; comp2 < numComp; ++comp2){\n                rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n                currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n                dctData[comp2] = new Float32Array(64);\n                halfZigBlock[comp2] = new Uint16Array(64);\n                rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n            }\n            for(let blocky = 0; blocky < numBlocksY; ++blocky){\n                var maxY = 8;\n                if (blocky == numBlocksY - 1) maxY = leftoverY;\n                var maxX = 8;\n                for(let blockx = 0; blockx < numBlocksX; ++blockx){\n                    if (blockx == numBlocksX - 1) maxX = leftoverX;\n                    for(let comp2 = 0; comp2 < numComp; ++comp2){\n                        halfZigBlock[comp2].fill(0);\n                        halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n                        unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n                        unZigZag(halfZigBlock[comp2], dctData[comp2]);\n                        dctInverse(dctData[comp2]);\n                    }\n                    {\n                        csc709Inverse(dctData);\n                    }\n                    for(let comp2 = 0; comp2 < numComp; ++comp2){\n                        convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n                    }\n                }\n                let offset2 = 0;\n                for(let comp2 = 0; comp2 < numComp; ++comp2){\n                    const type2 = channelData[cscSet.idx[comp2]].type;\n                    for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){\n                        offset2 = rowOffsets[comp2][y2];\n                        for(let blockx = 0; blockx < numFullBlocksX; ++blockx){\n                            const src = blockx * 64 + (y2 & 7) * 8;\n                            dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n                            dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n                            dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n                            dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n                            dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n                            dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n                            dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n                            dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n                            offset2 += 8 * INT16_SIZE * type2;\n                        }\n                    }\n                    if (numFullBlocksX != numBlocksX) {\n                        for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){\n                            const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n                            const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n                            for(let x2 = 0; x2 < maxX; ++x2){\n                                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n                            }\n                        }\n                    }\n                }\n            }\n            var halfRow = new Uint16Array(width);\n            var dataView = new DataView(outBuffer.buffer);\n            for(var comp = 0; comp < numComp; ++comp){\n                channelData[cscSet.idx[comp]].decoded = true;\n                var type = channelData[cscSet.idx[comp]].type;\n                if (channelData[comp].type != 2) continue;\n                for(var y = 0; y < height; ++y){\n                    const offset2 = rowOffsets[comp][y];\n                    for(var x = 0; x < width; ++x){\n                        halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n                    }\n                    for(var x = 0; x < width; ++x){\n                        dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n                    }\n                }\n            }\n        }\n        function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n            var acValue;\n            var dctComp = 1;\n            while(dctComp < 64){\n                acValue = acBuffer[currAcComp.value];\n                if (acValue == 65280) {\n                    dctComp = 64;\n                } else if (acValue >> 8 == 255) {\n                    dctComp += acValue & 255;\n                } else {\n                    halfZigBlock[dctComp] = acValue;\n                    dctComp++;\n                }\n                currAcComp.value++;\n            }\n        }\n        function unZigZag(src, dst) {\n            dst[0] = decodeFloat16(src[0]);\n            dst[1] = decodeFloat16(src[1]);\n            dst[2] = decodeFloat16(src[5]);\n            dst[3] = decodeFloat16(src[6]);\n            dst[4] = decodeFloat16(src[14]);\n            dst[5] = decodeFloat16(src[15]);\n            dst[6] = decodeFloat16(src[27]);\n            dst[7] = decodeFloat16(src[28]);\n            dst[8] = decodeFloat16(src[2]);\n            dst[9] = decodeFloat16(src[4]);\n            dst[10] = decodeFloat16(src[7]);\n            dst[11] = decodeFloat16(src[13]);\n            dst[12] = decodeFloat16(src[16]);\n            dst[13] = decodeFloat16(src[26]);\n            dst[14] = decodeFloat16(src[29]);\n            dst[15] = decodeFloat16(src[42]);\n            dst[16] = decodeFloat16(src[3]);\n            dst[17] = decodeFloat16(src[8]);\n            dst[18] = decodeFloat16(src[12]);\n            dst[19] = decodeFloat16(src[17]);\n            dst[20] = decodeFloat16(src[25]);\n            dst[21] = decodeFloat16(src[30]);\n            dst[22] = decodeFloat16(src[41]);\n            dst[23] = decodeFloat16(src[43]);\n            dst[24] = decodeFloat16(src[9]);\n            dst[25] = decodeFloat16(src[11]);\n            dst[26] = decodeFloat16(src[18]);\n            dst[27] = decodeFloat16(src[24]);\n            dst[28] = decodeFloat16(src[31]);\n            dst[29] = decodeFloat16(src[40]);\n            dst[30] = decodeFloat16(src[44]);\n            dst[31] = decodeFloat16(src[53]);\n            dst[32] = decodeFloat16(src[10]);\n            dst[33] = decodeFloat16(src[19]);\n            dst[34] = decodeFloat16(src[23]);\n            dst[35] = decodeFloat16(src[32]);\n            dst[36] = decodeFloat16(src[39]);\n            dst[37] = decodeFloat16(src[45]);\n            dst[38] = decodeFloat16(src[52]);\n            dst[39] = decodeFloat16(src[54]);\n            dst[40] = decodeFloat16(src[20]);\n            dst[41] = decodeFloat16(src[22]);\n            dst[42] = decodeFloat16(src[33]);\n            dst[43] = decodeFloat16(src[38]);\n            dst[44] = decodeFloat16(src[46]);\n            dst[45] = decodeFloat16(src[51]);\n            dst[46] = decodeFloat16(src[55]);\n            dst[47] = decodeFloat16(src[60]);\n            dst[48] = decodeFloat16(src[21]);\n            dst[49] = decodeFloat16(src[34]);\n            dst[50] = decodeFloat16(src[37]);\n            dst[51] = decodeFloat16(src[47]);\n            dst[52] = decodeFloat16(src[50]);\n            dst[53] = decodeFloat16(src[56]);\n            dst[54] = decodeFloat16(src[59]);\n            dst[55] = decodeFloat16(src[61]);\n            dst[56] = decodeFloat16(src[35]);\n            dst[57] = decodeFloat16(src[36]);\n            dst[58] = decodeFloat16(src[48]);\n            dst[59] = decodeFloat16(src[49]);\n            dst[60] = decodeFloat16(src[57]);\n            dst[61] = decodeFloat16(src[58]);\n            dst[62] = decodeFloat16(src[62]);\n            dst[63] = decodeFloat16(src[63]);\n        }\n        function dctInverse(data) {\n            const a = 0.5 * Math.cos(3.14159 / 4);\n            const b = 0.5 * Math.cos(3.14159 / 16);\n            const c = 0.5 * Math.cos(3.14159 / 8);\n            const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n            const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n            const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n            const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n            var alpha = new Array(4);\n            var beta = new Array(4);\n            var theta = new Array(4);\n            var gamma = new Array(4);\n            for(var row = 0; row < 8; ++row){\n                var rowPtr = row * 8;\n                alpha[0] = c * data[rowPtr + 2];\n                alpha[1] = f * data[rowPtr + 2];\n                alpha[2] = c * data[rowPtr + 6];\n                alpha[3] = f * data[rowPtr + 6];\n                beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n                beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n                beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n                beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n                theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n                theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n                theta[1] = alpha[0] + alpha[3];\n                theta[2] = alpha[1] - alpha[2];\n                gamma[0] = theta[0] + theta[1];\n                gamma[1] = theta[3] + theta[2];\n                gamma[2] = theta[3] - theta[2];\n                gamma[3] = theta[0] - theta[1];\n                data[rowPtr + 0] = gamma[0] + beta[0];\n                data[rowPtr + 1] = gamma[1] + beta[1];\n                data[rowPtr + 2] = gamma[2] + beta[2];\n                data[rowPtr + 3] = gamma[3] + beta[3];\n                data[rowPtr + 4] = gamma[3] - beta[3];\n                data[rowPtr + 5] = gamma[2] - beta[2];\n                data[rowPtr + 6] = gamma[1] - beta[1];\n                data[rowPtr + 7] = gamma[0] - beta[0];\n            }\n            for(var column = 0; column < 8; ++column){\n                alpha[0] = c * data[16 + column];\n                alpha[1] = f * data[16 + column];\n                alpha[2] = c * data[48 + column];\n                alpha[3] = f * data[48 + column];\n                beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n                beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n                beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n                beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n                theta[0] = a * (data[column] + data[32 + column]);\n                theta[3] = a * (data[column] - data[32 + column]);\n                theta[1] = alpha[0] + alpha[3];\n                theta[2] = alpha[1] - alpha[2];\n                gamma[0] = theta[0] + theta[1];\n                gamma[1] = theta[3] + theta[2];\n                gamma[2] = theta[3] - theta[2];\n                gamma[3] = theta[0] - theta[1];\n                data[0 + column] = gamma[0] + beta[0];\n                data[8 + column] = gamma[1] + beta[1];\n                data[16 + column] = gamma[2] + beta[2];\n                data[24 + column] = gamma[3] + beta[3];\n                data[32 + column] = gamma[3] - beta[3];\n                data[40 + column] = gamma[2] - beta[2];\n                data[48 + column] = gamma[1] - beta[1];\n                data[56 + column] = gamma[0] - beta[0];\n            }\n        }\n        function csc709Inverse(data) {\n            for(var i = 0; i < 64; ++i){\n                var y = data[0][i];\n                var cb = data[1][i];\n                var cr = data[2][i];\n                data[0][i] = y + 1.5747 * cr;\n                data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n                data[2][i] = y + 1.8556 * cb;\n            }\n        }\n        function convertToHalf(src, dst, idx) {\n            for(var i = 0; i < 64; ++i){\n                dst[idx + i] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(toLinear(src[i]));\n            }\n        }\n        function toLinear(float) {\n            if (float <= 1) {\n                return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n            } else {\n                return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n            }\n        }\n        function uncompressRAW(info) {\n            return new DataView(info.array.buffer, info.offset.value, info.size);\n        }\n        function uncompressRLE(info) {\n            var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n            var tmpBuffer = new Uint8Array(rawBuffer.length);\n            predictor(rawBuffer);\n            interleaveScalar(rawBuffer, tmpBuffer);\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressZIP(info) {\n            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n            var tmpBuffer = new Uint8Array(rawBuffer.length);\n            predictor(rawBuffer);\n            interleaveScalar(rawBuffer, tmpBuffer);\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressPIZ(info) {\n            var inDataView = info.viewer;\n            var inOffset = {\n                value: info.offset.value\n            };\n            var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n            var bitmap = new Uint8Array(BITMAP_SIZE);\n            var outBufferEnd = 0;\n            var pizChannelData = new Array(info.channels);\n            for(var i = 0; i < info.channels; i++){\n                pizChannelData[i] = {};\n                pizChannelData[i][\"start\"] = outBufferEnd;\n                pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n                pizChannelData[i][\"nx\"] = info.width;\n                pizChannelData[i][\"ny\"] = info.lines;\n                pizChannelData[i][\"size\"] = info.type;\n                outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n            }\n            var minNonZero = parseUint16(inDataView, inOffset);\n            var maxNonZero = parseUint16(inDataView, inOffset);\n            if (maxNonZero >= BITMAP_SIZE) {\n                throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n            }\n            if (minNonZero <= maxNonZero) {\n                for(var i = 0; i < maxNonZero - minNonZero + 1; i++){\n                    bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n                }\n            }\n            var lut = new Uint16Array(USHORT_RANGE);\n            var maxValue = reverseLutFromBitmap(bitmap, lut);\n            var length = parseUint32(inDataView, inOffset);\n            hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n            for(var i = 0; i < info.channels; ++i){\n                var cd = pizChannelData[i];\n                for(var j = 0; j < pizChannelData[i].size; ++j){\n                    wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n                }\n            }\n            applyLut(lut, outBuffer, outBufferEnd);\n            var tmpOffset2 = 0;\n            var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n            for(var y = 0; y < info.lines; y++){\n                for(var c = 0; c < info.channels; c++){\n                    var cd = pizChannelData[c];\n                    var n = cd.nx * cd.size;\n                    var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n                    tmpBuffer.set(cp, tmpOffset2);\n                    tmpOffset2 += n * INT16_SIZE;\n                    cd.end += n;\n                }\n            }\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressPXR(info) {\n            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n            const sz = info.lines * info.channels * info.width;\n            const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n            let tmpBufferEnd = 0;\n            let writePtr = 0;\n            const ptr = new Array(4);\n            for(let y = 0; y < info.lines; y++){\n                for(let c = 0; c < info.channels; c++){\n                    let pixel = 0;\n                    switch(info.type){\n                        case 1:\n                            ptr[0] = tmpBufferEnd;\n                            ptr[1] = ptr[0] + info.width;\n                            tmpBufferEnd = ptr[1] + info.width;\n                            for(let j = 0; j < info.width; ++j){\n                                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                                pixel += diff;\n                                tmpBuffer[writePtr] = pixel;\n                                writePtr++;\n                            }\n                            break;\n                        case 2:\n                            ptr[0] = tmpBufferEnd;\n                            ptr[1] = ptr[0] + info.width;\n                            ptr[2] = ptr[1] + info.width;\n                            tmpBufferEnd = ptr[2] + info.width;\n                            for(let j = 0; j < info.width; ++j){\n                                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                                pixel += diff;\n                                tmpBuffer[writePtr] = pixel;\n                                writePtr++;\n                            }\n                            break;\n                    }\n                }\n            }\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressDWA(info) {\n            var inDataView = info.viewer;\n            var inOffset = {\n                value: info.offset.value\n            };\n            var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n            var dwaHeader = {\n                version: parseInt64(inDataView, inOffset),\n                unknownUncompressedSize: parseInt64(inDataView, inOffset),\n                unknownCompressedSize: parseInt64(inDataView, inOffset),\n                acCompressedSize: parseInt64(inDataView, inOffset),\n                dcCompressedSize: parseInt64(inDataView, inOffset),\n                rleCompressedSize: parseInt64(inDataView, inOffset),\n                rleUncompressedSize: parseInt64(inDataView, inOffset),\n                rleRawSize: parseInt64(inDataView, inOffset),\n                totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n                totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n                acCompression: parseInt64(inDataView, inOffset)\n            };\n            if (dwaHeader.version < 2) {\n                throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n            }\n            var channelRules = new Array();\n            var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n            while(ruleSize > 0){\n                var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n                var value = parseUint8(inDataView, inOffset);\n                var compression = value >> 2 & 3;\n                var csc = (value >> 4) - 1;\n                var index = new Int8Array([\n                    csc\n                ])[0];\n                var type = parseUint8(inDataView, inOffset);\n                channelRules.push({\n                    name,\n                    index,\n                    type,\n                    compression\n                });\n                ruleSize -= name.length + 3;\n            }\n            var channels = EXRHeader.channels;\n            var channelData = new Array(info.channels);\n            for(var i = 0; i < info.channels; ++i){\n                var cd = channelData[i] = {};\n                var channel = channels[i];\n                cd.name = channel.name;\n                cd.compression = UNKNOWN;\n                cd.decoded = false;\n                cd.type = channel.pixelType;\n                cd.pLinear = channel.pLinear;\n                cd.width = info.width;\n                cd.height = info.lines;\n            }\n            var cscSet = {\n                idx: new Array(3)\n            };\n            for(var offset2 = 0; offset2 < info.channels; ++offset2){\n                var cd = channelData[offset2];\n                for(var i = 0; i < channelRules.length; ++i){\n                    var rule = channelRules[i];\n                    if (cd.name == rule.name) {\n                        cd.compression = rule.compression;\n                        if (rule.index >= 0) {\n                            cscSet.idx[rule.index] = offset2;\n                        }\n                        cd.offset = offset2;\n                    }\n                }\n            }\n            if (dwaHeader.acCompressedSize > 0) {\n                switch(dwaHeader.acCompression){\n                    case STATIC_HUFFMAN:\n                        var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n                        hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n                        break;\n                    case DEFLATE:\n                        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n                        var data = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n                        var acBuffer = new Uint16Array(data.buffer);\n                        inOffset.value += dwaHeader.totalAcUncompressedCount;\n                        break;\n                }\n            }\n            if (dwaHeader.dcCompressedSize > 0) {\n                var zlibInfo = {\n                    array: info.array,\n                    offset: inOffset,\n                    size: dwaHeader.dcCompressedSize\n                };\n                var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n                inOffset.value += dwaHeader.dcCompressedSize;\n            }\n            if (dwaHeader.rleRawSize > 0) {\n                var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n                var data = (0,fflate__WEBPACK_IMPORTED_MODULE_1__.unzlibSync)(compressed);\n                var rleBuffer = decodeRunLength(data.buffer);\n                inOffset.value += dwaHeader.rleCompressedSize;\n            }\n            var outBufferEnd = 0;\n            var rowOffsets = new Array(channelData.length);\n            for(var i = 0; i < rowOffsets.length; ++i){\n                rowOffsets[i] = new Array();\n            }\n            for(var y = 0; y < info.lines; ++y){\n                for(var chan = 0; chan < channelData.length; ++chan){\n                    rowOffsets[chan].push(outBufferEnd);\n                    outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n                }\n            }\n            lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n            for(var i = 0; i < channelData.length; ++i){\n                var cd = channelData[i];\n                if (cd.decoded) continue;\n                switch(cd.compression){\n                    case RLE:\n                        var row = 0;\n                        var rleOffset = 0;\n                        for(var y = 0; y < info.lines; ++y){\n                            var rowOffsetBytes = rowOffsets[i][row];\n                            for(var x = 0; x < cd.width; ++x){\n                                for(var byte = 0; byte < INT16_SIZE * cd.type; ++byte){\n                                    outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                                }\n                                rleOffset++;\n                            }\n                            row++;\n                        }\n                        break;\n                    case LOSSY_DCT:\n                    default:\n                        throw \"EXRLoader.parse: unsupported channel compression\";\n                }\n            }\n            return new DataView(outBuffer.buffer);\n        }\n        function parseNullTerminatedString(buffer2, offset2) {\n            var uintBuffer = new Uint8Array(buffer2);\n            var endOffset = 0;\n            while(uintBuffer[offset2.value + endOffset] != 0){\n                endOffset += 1;\n            }\n            var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n            offset2.value = offset2.value + endOffset + 1;\n            return stringValue;\n        }\n        function parseFixedLengthString(buffer2, offset2, size) {\n            var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n            offset2.value = offset2.value + size;\n            return stringValue;\n        }\n        function parseRational(dataView, offset2) {\n            var x = parseInt32(dataView, offset2);\n            var y = parseUint32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseTimecode(dataView, offset2) {\n            var x = parseUint32(dataView, offset2);\n            var y = parseUint32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseInt32(dataView, offset2) {\n            var Int32 = dataView.getInt32(offset2.value, true);\n            offset2.value = offset2.value + INT32_SIZE;\n            return Int32;\n        }\n        function parseUint32(dataView, offset2) {\n            var Uint32 = dataView.getUint32(offset2.value, true);\n            offset2.value = offset2.value + INT32_SIZE;\n            return Uint32;\n        }\n        function parseUint8Array(uInt8Array2, offset2) {\n            var Uint8 = uInt8Array2[offset2.value];\n            offset2.value = offset2.value + INT8_SIZE;\n            return Uint8;\n        }\n        function parseUint8(dataView, offset2) {\n            var Uint8 = dataView.getUint8(offset2.value);\n            offset2.value = offset2.value + INT8_SIZE;\n            return Uint8;\n        }\n        const parseInt64 = function(dataView, offset2) {\n            let int;\n            if (\"getBigInt64\" in DataView.prototype) {\n                int = Number(dataView.getBigInt64(offset2.value, true));\n            } else {\n                int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n            }\n            offset2.value += ULONG_SIZE;\n            return int;\n        };\n        function parseFloat32(dataView, offset2) {\n            var float = dataView.getFloat32(offset2.value, true);\n            offset2.value += FLOAT32_SIZE;\n            return float;\n        }\n        function decodeFloat32(dataView, offset2) {\n            return three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n        }\n        function decodeFloat16(binary) {\n            var exponent = (binary & 31744) >> 10, fraction = binary & 1023;\n            return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n        }\n        function parseUint16(dataView, offset2) {\n            var Uint16 = dataView.getUint16(offset2.value, true);\n            offset2.value += INT16_SIZE;\n            return Uint16;\n        }\n        function parseFloat16(buffer2, offset2) {\n            return decodeFloat16(parseUint16(buffer2, offset2));\n        }\n        function parseChlist(dataView, buffer2, offset2, size) {\n            var startOffset = offset2.value;\n            var channels = [];\n            while(offset2.value < startOffset + size - 1){\n                var name = parseNullTerminatedString(buffer2, offset2);\n                var pixelType = parseInt32(dataView, offset2);\n                var pLinear = parseUint8(dataView, offset2);\n                offset2.value += 3;\n                var xSampling = parseInt32(dataView, offset2);\n                var ySampling = parseInt32(dataView, offset2);\n                channels.push({\n                    name,\n                    pixelType,\n                    pLinear,\n                    xSampling,\n                    ySampling\n                });\n            }\n            offset2.value += 1;\n            return channels;\n        }\n        function parseChromaticities(dataView, offset2) {\n            var redX = parseFloat32(dataView, offset2);\n            var redY = parseFloat32(dataView, offset2);\n            var greenX = parseFloat32(dataView, offset2);\n            var greenY = parseFloat32(dataView, offset2);\n            var blueX = parseFloat32(dataView, offset2);\n            var blueY = parseFloat32(dataView, offset2);\n            var whiteX = parseFloat32(dataView, offset2);\n            var whiteY = parseFloat32(dataView, offset2);\n            return {\n                redX,\n                redY,\n                greenX,\n                greenY,\n                blueX,\n                blueY,\n                whiteX,\n                whiteY\n            };\n        }\n        function parseCompression(dataView, offset2) {\n            var compressionCodes = [\n                \"NO_COMPRESSION\",\n                \"RLE_COMPRESSION\",\n                \"ZIPS_COMPRESSION\",\n                \"ZIP_COMPRESSION\",\n                \"PIZ_COMPRESSION\",\n                \"PXR24_COMPRESSION\",\n                \"B44_COMPRESSION\",\n                \"B44A_COMPRESSION\",\n                \"DWAA_COMPRESSION\",\n                \"DWAB_COMPRESSION\"\n            ];\n            var compression = parseUint8(dataView, offset2);\n            return compressionCodes[compression];\n        }\n        function parseBox2i(dataView, offset2) {\n            var xMin = parseUint32(dataView, offset2);\n            var yMin = parseUint32(dataView, offset2);\n            var xMax = parseUint32(dataView, offset2);\n            var yMax = parseUint32(dataView, offset2);\n            return {\n                xMin,\n                yMin,\n                xMax,\n                yMax\n            };\n        }\n        function parseLineOrder(dataView, offset2) {\n            var lineOrders = [\n                \"INCREASING_Y\"\n            ];\n            var lineOrder = parseUint8(dataView, offset2);\n            return lineOrders[lineOrder];\n        }\n        function parseV2f(dataView, offset2) {\n            var x = parseFloat32(dataView, offset2);\n            var y = parseFloat32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseV3f(dataView, offset2) {\n            var x = parseFloat32(dataView, offset2);\n            var y = parseFloat32(dataView, offset2);\n            var z = parseFloat32(dataView, offset2);\n            return [\n                x,\n                y,\n                z\n            ];\n        }\n        function parseValue(dataView, buffer2, offset2, type, size) {\n            if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n                return parseFixedLengthString(buffer2, offset2, size);\n            } else if (type === \"chlist\") {\n                return parseChlist(dataView, buffer2, offset2, size);\n            } else if (type === \"chromaticities\") {\n                return parseChromaticities(dataView, offset2);\n            } else if (type === \"compression\") {\n                return parseCompression(dataView, offset2);\n            } else if (type === \"box2i\") {\n                return parseBox2i(dataView, offset2);\n            } else if (type === \"lineOrder\") {\n                return parseLineOrder(dataView, offset2);\n            } else if (type === \"float\") {\n                return parseFloat32(dataView, offset2);\n            } else if (type === \"v2f\") {\n                return parseV2f(dataView, offset2);\n            } else if (type === \"v3f\") {\n                return parseV3f(dataView, offset2);\n            } else if (type === \"int\") {\n                return parseInt32(dataView, offset2);\n            } else if (type === \"rational\") {\n                return parseRational(dataView, offset2);\n            } else if (type === \"timecode\") {\n                return parseTimecode(dataView, offset2);\n            } else if (type === \"preview\") {\n                offset2.value += size;\n                return \"skipped\";\n            } else {\n                offset2.value += size;\n                return void 0;\n            }\n        }\n        function parseHeader(dataView, buffer2, offset2) {\n            const EXRHeader2 = {};\n            if (dataView.getUint32(0, true) != 20000630) {\n                throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n            }\n            EXRHeader2.version = dataView.getUint8(4);\n            const spec = dataView.getUint8(5);\n            EXRHeader2.spec = {\n                singleTile: !!(spec & 2),\n                longName: !!(spec & 4),\n                deepFormat: !!(spec & 8),\n                multiPart: !!(spec & 16)\n            };\n            offset2.value = 8;\n            var keepReading = true;\n            while(keepReading){\n                var attributeName = parseNullTerminatedString(buffer2, offset2);\n                if (attributeName == 0) {\n                    keepReading = false;\n                } else {\n                    var attributeType = parseNullTerminatedString(buffer2, offset2);\n                    var attributeSize = parseUint32(dataView, offset2);\n                    var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n                    if (attributeValue === void 0) {\n                        console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);\n                    } else {\n                        EXRHeader2[attributeName] = attributeValue;\n                    }\n                }\n            }\n            if ((spec & ~4) != 0) {\n                console.error(\"EXRHeader:\", EXRHeader2);\n                throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n            }\n            return EXRHeader2;\n        }\n        function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n            const EXRDecoder2 = {\n                size: 0,\n                viewer: dataView,\n                array: uInt8Array2,\n                offset: offset2,\n                width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n                height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n                channels: EXRHeader2.channels.length,\n                bytesPerLine: null,\n                lines: null,\n                inputSize: null,\n                type: EXRHeader2.channels[0].pixelType,\n                uncompress: null,\n                getter: null,\n                format: null,\n                [hasColorSpace ? \"colorSpace\" : \"encoding\"]: null\n            };\n            switch(EXRHeader2.compression){\n                case \"NO_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressRAW;\n                    break;\n                case \"RLE_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressRLE;\n                    break;\n                case \"ZIPS_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressZIP;\n                    break;\n                case \"ZIP_COMPRESSION\":\n                    EXRDecoder2.lines = 16;\n                    EXRDecoder2.uncompress = uncompressZIP;\n                    break;\n                case \"PIZ_COMPRESSION\":\n                    EXRDecoder2.lines = 32;\n                    EXRDecoder2.uncompress = uncompressPIZ;\n                    break;\n                case \"PXR24_COMPRESSION\":\n                    EXRDecoder2.lines = 16;\n                    EXRDecoder2.uncompress = uncompressPXR;\n                    break;\n                case \"DWAA_COMPRESSION\":\n                    EXRDecoder2.lines = 32;\n                    EXRDecoder2.uncompress = uncompressDWA;\n                    break;\n                case \"DWAB_COMPRESSION\":\n                    EXRDecoder2.lines = 256;\n                    EXRDecoder2.uncompress = uncompressDWA;\n                    break;\n                default:\n                    throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n            }\n            EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n            if (EXRDecoder2.type == 1) {\n                switch(outputType){\n                    case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                        EXRDecoder2.getter = parseFloat16;\n                        EXRDecoder2.inputSize = INT16_SIZE;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                        EXRDecoder2.getter = parseUint16;\n                        EXRDecoder2.inputSize = INT16_SIZE;\n                        break;\n                }\n            } else if (EXRDecoder2.type == 2) {\n                switch(outputType){\n                    case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                        EXRDecoder2.getter = parseFloat32;\n                        EXRDecoder2.inputSize = FLOAT32_SIZE;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                        EXRDecoder2.getter = decodeFloat32;\n                        EXRDecoder2.inputSize = FLOAT32_SIZE;\n                }\n            } else {\n                throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n            }\n            EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n            for(var i = 0; i < EXRDecoder2.blockCount; i++)parseInt64(dataView, offset2);\n            EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n            const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n            switch(outputType){\n                case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                    EXRDecoder2.byteArray = new Float32Array(size);\n                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(1, 0, size);\n                    break;\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    EXRDecoder2.byteArray = new Uint16Array(size);\n                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(15360, 0, size);\n                    break;\n                default:\n                    console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n                    break;\n            }\n            EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n            if (EXRDecoder2.outputChannels == 4) EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat;\n            else EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_0__.RedFormat;\n            if (hasColorSpace) EXRDecoder2.colorSpace = \"srgb-linear\";\n            else EXRDecoder2.encoding = 3e3;\n            return EXRDecoder2;\n        }\n        const bufferDataView = new DataView(buffer);\n        const uInt8Array = new Uint8Array(buffer);\n        const offset = {\n            value: 0\n        };\n        const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n        const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n        const tmpOffset = {\n            value: 0\n        };\n        const channelOffsets = {\n            R: 0,\n            G: 1,\n            B: 2,\n            A: 3,\n            Y: 0\n        };\n        for(let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++){\n            const line = parseUint32(bufferDataView, offset);\n            EXRDecoder.size = parseUint32(bufferDataView, offset);\n            EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n            const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n            const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n            offset.value += EXRDecoder.size;\n            for(let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++){\n                const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n                if (true_y >= EXRDecoder.height) break;\n                for(let channelID = 0; channelID < EXRDecoder.channels; channelID++){\n                    const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n                    for(let x = 0; x < EXRDecoder.width; x++){\n                        tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n                        const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n                        EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n                    }\n                }\n            }\n        }\n        return {\n            header: EXRHeader,\n            width: EXRDecoder.width,\n            height: EXRDecoder.height,\n            data: EXRDecoder.byteArray,\n            format: EXRDecoder.format,\n            [hasColorSpace ? \"colorSpace\" : \"encoding\"]: EXRDecoder[hasColorSpace ? \"colorSpace\" : \"encoding\"],\n            type: this.type\n        };\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            if (hasColorSpace) texture.colorSpace = texData.colorSpace;\n            else texture.encoding = texData.encoding;\n            texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.generateMipmaps = false;\n            texture.flipY = false;\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n //# sourceMappingURL=EXRLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRVhSTG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2SDtBQUN6RjtBQUNwQyxNQUFNUyxnQkFBZ0IsZ0JBQWdCLElBQUlULDBDQUFPQTtBQUNqRCxNQUFNVSxrQkFBa0JULG9EQUFpQkE7SUFDdkNVLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUdYLGdEQUFhQTtJQUMzQjtJQUNBWSxNQUFNQyxNQUFNLEVBQUU7UUFDWixNQUFNQyxlQUFlLEtBQUs7UUFDMUIsTUFBTUMsY0FBY0QsZ0JBQWdCO1FBQ3BDLE1BQU1FLGNBQWM7UUFDcEIsTUFBTUMsY0FBYztRQUNwQixNQUFNQyxjQUFjLENBQUMsS0FBS0YsV0FBVSxJQUFLO1FBQ3pDLE1BQU1HLGNBQWMsS0FBS0Y7UUFDekIsTUFBTUcsY0FBY0QsY0FBYztRQUNsQyxNQUFNRSxRQUFRO1FBQ2QsTUFBTUMsV0FBVyxLQUFLRCxRQUFRO1FBQzlCLE1BQU1FLFdBQVcsQ0FBQyxLQUFLRixLQUFJLElBQUs7UUFDaEMsTUFBTUcscUJBQXFCO1FBQzNCLE1BQU1DLG9CQUFvQjtRQUMxQixNQUFNQyxvQkFBb0IsSUFBSUQsb0JBQW9CRDtRQUNsRCxNQUFNRyxhQUFhO1FBQ25CLE1BQU1DLGVBQWU7UUFDckIsTUFBTUMsYUFBYTtRQUNuQixNQUFNQyxhQUFhO1FBQ25CLE1BQU1DLFlBQVk7UUFDbEIsTUFBTUMsaUJBQWlCO1FBQ3ZCLE1BQU1DLFVBQVU7UUFDaEIsTUFBTUMsVUFBVTtRQUNoQixNQUFNQyxZQUFZO1FBQ2xCLE1BQU1DLE1BQU07UUFDWixNQUFNQyxVQUFVQyxLQUFLQyxHQUFHLENBQUMsV0FBVztRQUNwQyxTQUFTQyxxQkFBcUJDLE1BQU0sRUFBRUMsR0FBRztZQUN2QyxJQUFJQyxJQUFJO1lBQ1IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUk5QixjQUFjLEVBQUU4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R0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsRUFBRTtZQUM5QmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEVBQUU7WUFDOUJjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxFQUFFO1lBQzlCYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdB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U0FBUyxHQUFHcGEsK0NBQVlBO1lBQ2hDaWEsUUFBUUksZUFBZSxHQUFHO1lBQzFCSixRQUFRSyxLQUFLLEdBQUc7WUFDaEIsSUFBSVQsUUFDRkEsT0FBT0ksU0FBU0M7UUFDcEI7UUFDQSxPQUFPLEtBQUssQ0FBQ1AsS0FBS0MsS0FBS0ksZ0JBQWdCRixZQUFZQztJQUNyRDtBQUNGO0FBR0UsQ0FDRixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8zRC1BSS1FbmdsaXNoLy4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL0VYUkxvYWRlci5qcz83ZTQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRleHR1cmUsIERhdGFUZXh0dXJlTG9hZGVyLCBIYWxmRmxvYXRUeXBlLCBGbG9hdFR5cGUsIFJHQkFGb3JtYXQsIFJlZEZvcm1hdCwgTGluZWFyRmlsdGVyLCBEYXRhVXRpbHMgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IHVuemxpYlN5bmMgfSBmcm9tIFwiZmZsYXRlXCI7XG5jb25zdCBoYXNDb2xvclNwYWNlID0gXCJjb2xvclNwYWNlXCIgaW4gbmV3IFRleHR1cmUoKTtcbmNsYXNzIEVYUkxvYWRlciBleHRlbmRzIERhdGFUZXh0dXJlTG9hZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgIHRoaXMudHlwZSA9IEhhbGZGbG9hdFR5cGU7XG4gIH1cbiAgcGFyc2UoYnVmZmVyKSB7XG4gICAgY29uc3QgVVNIT1JUX1JBTkdFID0gMSA8PCAxNjtcbiAgICBjb25zdCBCSVRNQVBfU0laRSA9IFVTSE9SVF9SQU5HRSA+PiAzO1xuICAgIGNvbnN0IEhVRl9FTkNCSVRTID0gMTY7XG4gICAgY29uc3QgSFVGX0RFQ0JJVFMgPSAxNDtcbiAgICBjb25zdCBIVUZfRU5DU0laRSA9ICgxIDw8IEhVRl9FTkNCSVRTKSArIDE7XG4gICAgY29uc3QgSFVGX0RFQ1NJWkUgPSAxIDw8IEhVRl9ERUNCSVRTO1xuICAgIGNvbnN0IEhVRl9ERUNNQVNLID0gSFVGX0RFQ1NJWkUgLSAxO1xuICAgIGNvbnN0IE5CSVRTID0gMTY7XG4gICAgY29uc3QgQV9PRkZTRVQgPSAxIDw8IE5CSVRTIC0gMTtcbiAgICBjb25zdCBNT0RfTUFTSyA9ICgxIDw8IE5CSVRTKSAtIDE7XG4gICAgY29uc3QgU0hPUlRfWkVST0NPREVfUlVOID0gNTk7XG4gICAgY29uc3QgTE9OR19aRVJPQ09ERV9SVU4gPSA2MztcbiAgICBjb25zdCBTSE9SVEVTVF9MT05HX1JVTiA9IDIgKyBMT05HX1pFUk9DT0RFX1JVTiAtIFNIT1JUX1pFUk9DT0RFX1JVTjtcbiAgICBjb25zdCBVTE9OR19TSVpFID0gODtcbiAgICBjb25zdCBGTE9BVDMyX1NJWkUgPSA0O1xuICAgIGNvbnN0IElOVDMyX1NJWkUgPSA0O1xuICAgIGNvbnN0IElOVDE2X1NJWkUgPSAyO1xuICAgIGNvbnN0IElOVDhfU0laRSA9IDE7XG4gICAgY29uc3QgU1RBVElDX0hVRkZNQU4gPSAwO1xuICAgIGNvbnN0IERFRkxBVEUgPSAxO1xuICAgIGNvbnN0IFVOS05PV04gPSAwO1xuICAgIGNvbnN0IExPU1NZX0RDVCA9IDE7XG4gICAgY29uc3QgUkxFID0gMjtcbiAgICBjb25zdCBsb2dCYXNlID0gTWF0aC5wb3coMi43MTgyODE4LCAyLjIpO1xuICAgIGZ1bmN0aW9uIHJldmVyc2VMdXRGcm9tQml0bWFwKGJpdG1hcCwgbHV0KSB7XG4gICAgICB2YXIgayA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFVTSE9SVF9SQU5HRTsgKytpKSB7XG4gICAgICAgIGlmIChpID09IDAgfHwgYml0bWFwW2kgPj4gM10gJiAxIDw8IChpICYgNykpIHtcbiAgICAgICAgICBsdXRbaysrXSA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBuID0gayAtIDE7XG4gICAgICB3aGlsZSAoayA8IFVTSE9SVF9SQU5HRSlcbiAgICAgICAgbHV0W2srK10gPSAwO1xuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1ZkNsZWFyRGVjVGFibGUoaGRlYykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBIVUZfREVDU0laRTsgaSsrKSB7XG4gICAgICAgIGhkZWNbaV0gPSB7fTtcbiAgICAgICAgaGRlY1tpXS5sZW4gPSAwO1xuICAgICAgICBoZGVjW2ldLmxpdCA9IDA7XG4gICAgICAgIGhkZWNbaV0ucCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGdldEJpdHNSZXR1cm4gPSB7IGw6IDAsIGM6IDAsIGxjOiAwIH07XG4gICAgZnVuY3Rpb24gZ2V0Qml0cyhuQml0cywgYywgbGMsIHVJbnQ4QXJyYXkyLCBpbk9mZnNldCkge1xuICAgICAgd2hpbGUgKGxjIDwgbkJpdHMpIHtcbiAgICAgICAgYyA9IGMgPDwgOCB8IHBhcnNlVWludDhBcnJheSh1SW50OEFycmF5MiwgaW5PZmZzZXQpO1xuICAgICAgICBsYyArPSA4O1xuICAgICAgfVxuICAgICAgbGMgLT0gbkJpdHM7XG4gICAgICBnZXRCaXRzUmV0dXJuLmwgPSBjID4+IGxjICYgKDEgPDwgbkJpdHMpIC0gMTtcbiAgICAgIGdldEJpdHNSZXR1cm4uYyA9IGM7XG4gICAgICBnZXRCaXRzUmV0dXJuLmxjID0gbGM7XG4gICAgfVxuICAgIGNvbnN0IGh1ZlRhYmxlQnVmZmVyID0gbmV3IEFycmF5KDU5KTtcbiAgICBmdW5jdGlvbiBodWZDYW5vbmljYWxDb2RlVGFibGUoaGNvZGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IDU4OyArK2kpXG4gICAgICAgIGh1ZlRhYmxlQnVmZmVyW2ldID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgSFVGX0VOQ1NJWkU7ICsraSlcbiAgICAgICAgaHVmVGFibGVCdWZmZXJbaGNvZGVbaV1dICs9IDE7XG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gNTg7IGkgPiAwOyAtLWkpIHtcbiAgICAgICAgdmFyIG5jID0gYyArIGh1ZlRhYmxlQnVmZmVyW2ldID4+IDE7XG4gICAgICAgIGh1ZlRhYmxlQnVmZmVyW2ldID0gYztcbiAgICAgICAgYyA9IG5jO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBIVUZfRU5DU0laRTsgKytpKSB7XG4gICAgICAgIHZhciBsID0gaGNvZGVbaV07XG4gICAgICAgIGlmIChsID4gMClcbiAgICAgICAgICBoY29kZVtpXSA9IGwgfCBodWZUYWJsZUJ1ZmZlcltsXSsrIDw8IDY7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1ZlVucGFja0VuY1RhYmxlKHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbmksIGltLCBpTSwgaGNvZGUpIHtcbiAgICAgIHZhciBwID0gaW5PZmZzZXQ7XG4gICAgICB2YXIgYyA9IDA7XG4gICAgICB2YXIgbGMgPSAwO1xuICAgICAgZm9yICg7IGltIDw9IGlNOyBpbSsrKSB7XG4gICAgICAgIGlmIChwLnZhbHVlIC0gaW5PZmZzZXQudmFsdWUgPiBuaSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGdldEJpdHMoNiwgYywgbGMsIHVJbnQ4QXJyYXkyLCBwKTtcbiAgICAgICAgdmFyIGwgPSBnZXRCaXRzUmV0dXJuLmw7XG4gICAgICAgIGMgPSBnZXRCaXRzUmV0dXJuLmM7XG4gICAgICAgIGxjID0gZ2V0Qml0c1JldHVybi5sYztcbiAgICAgICAgaGNvZGVbaW1dID0gbDtcbiAgICAgICAgaWYgKGwgPT0gTE9OR19aRVJPQ09ERV9SVU4pIHtcbiAgICAgICAgICBpZiAocC52YWx1ZSAtIGluT2Zmc2V0LnZhbHVlID4gbmkpIHtcbiAgICAgICAgICAgIHRocm93IFwiU29tZXRoaW5nIHdyb25nIHdpdGggaHVmVW5wYWNrRW5jVGFibGVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2V0Qml0cyg4LCBjLCBsYywgdUludDhBcnJheTIsIHApO1xuICAgICAgICAgIHZhciB6ZXJ1biA9IGdldEJpdHNSZXR1cm4ubCArIFNIT1JURVNUX0xPTkdfUlVOO1xuICAgICAgICAgIGMgPSBnZXRCaXRzUmV0dXJuLmM7XG4gICAgICAgICAgbGMgPSBnZXRCaXRzUmV0dXJuLmxjO1xuICAgICAgICAgIGlmIChpbSArIHplcnVuID4gaU0gKyAxKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlNvbWV0aGluZyB3cm9uZyB3aXRoIGh1ZlVucGFja0VuY1RhYmxlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICh6ZXJ1bi0tKVxuICAgICAgICAgICAgaGNvZGVbaW0rK10gPSAwO1xuICAgICAgICAgIGltLS07XG4gICAgICAgIH0gZWxzZSBpZiAobCA+PSBTSE9SVF9aRVJPQ09ERV9SVU4pIHtcbiAgICAgICAgICB2YXIgemVydW4gPSBsIC0gU0hPUlRfWkVST0NPREVfUlVOICsgMjtcbiAgICAgICAgICBpZiAoaW0gKyB6ZXJ1biA+IGlNICsgMSkge1xuICAgICAgICAgICAgdGhyb3cgXCJTb21ldGhpbmcgd3Jvbmcgd2l0aCBodWZVbnBhY2tFbmNUYWJsZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoemVydW4tLSlcbiAgICAgICAgICAgIGhjb2RlW2ltKytdID0gMDtcbiAgICAgICAgICBpbS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBodWZDYW5vbmljYWxDb2RlVGFibGUoaGNvZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBodWZMZW5ndGgoY29kZSkge1xuICAgICAgcmV0dXJuIGNvZGUgJiA2MztcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmQ29kZShjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSA+PiA2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBodWZCdWlsZERlY1RhYmxlKGhjb2RlLCBpbSwgaU0sIGhkZWNvZCkge1xuICAgICAgZm9yICg7IGltIDw9IGlNOyBpbSsrKSB7XG4gICAgICAgIHZhciBjID0gaHVmQ29kZShoY29kZVtpbV0pO1xuICAgICAgICB2YXIgbCA9IGh1Zkxlbmd0aChoY29kZVtpbV0pO1xuICAgICAgICBpZiAoYyA+PiBsKSB7XG4gICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHRhYmxlIGVudHJ5XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGwgPiBIVUZfREVDQklUUykge1xuICAgICAgICAgIHZhciBwbCA9IGhkZWNvZFtjID4+IGwgLSBIVUZfREVDQklUU107XG4gICAgICAgICAgaWYgKHBsLmxlbikge1xuICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHRhYmxlIGVudHJ5XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBsLmxpdCsrO1xuICAgICAgICAgIGlmIChwbC5wKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHBsLnA7XG4gICAgICAgICAgICBwbC5wID0gbmV3IEFycmF5KHBsLmxpdCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsLmxpdCAtIDE7ICsraSkge1xuICAgICAgICAgICAgICBwbC5wW2ldID0gcFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGwucCA9IG5ldyBBcnJheSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGwucFtwbC5saXQgLSAxXSA9IGltO1xuICAgICAgICB9IGVsc2UgaWYgKGwpIHtcbiAgICAgICAgICB2YXIgcGxPZmZzZXQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxIDw8IEhVRl9ERUNCSVRTIC0gbDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIHBsID0gaGRlY29kWyhjIDw8IEhVRl9ERUNCSVRTIC0gbCkgKyBwbE9mZnNldF07XG4gICAgICAgICAgICBpZiAocGwubGVuIHx8IHBsLnApIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHRhYmxlIGVudHJ5XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbC5sZW4gPSBsO1xuICAgICAgICAgICAgcGwubGl0ID0gaW07XG4gICAgICAgICAgICBwbE9mZnNldCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGdldENoYXJSZXR1cm4gPSB7IGM6IDAsIGxjOiAwIH07XG4gICAgZnVuY3Rpb24gZ2V0Q2hhcihjLCBsYywgdUludDhBcnJheTIsIGluT2Zmc2V0KSB7XG4gICAgICBjID0gYyA8PCA4IHwgcGFyc2VVaW50OEFycmF5KHVJbnQ4QXJyYXkyLCBpbk9mZnNldCk7XG4gICAgICBsYyArPSA4O1xuICAgICAgZ2V0Q2hhclJldHVybi5jID0gYztcbiAgICAgIGdldENoYXJSZXR1cm4ubGMgPSBsYztcbiAgICB9XG4gICAgY29uc3QgZ2V0Q29kZVJldHVybiA9IHsgYzogMCwgbGM6IDAgfTtcbiAgICBmdW5jdGlvbiBnZXRDb2RlKHBvLCBybGMsIGMsIGxjLCB1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG91dEJ1ZmZlciwgb3V0QnVmZmVyT2Zmc2V0LCBvdXRCdWZmZXJFbmRPZmZzZXQpIHtcbiAgICAgIGlmIChwbyA9PSBybGMpIHtcbiAgICAgICAgaWYgKGxjIDwgOCkge1xuICAgICAgICAgIGdldENoYXIoYywgbGMsIHVJbnQ4QXJyYXkyLCBpbk9mZnNldCk7XG4gICAgICAgICAgYyA9IGdldENoYXJSZXR1cm4uYztcbiAgICAgICAgICBsYyA9IGdldENoYXJSZXR1cm4ubGM7XG4gICAgICAgIH1cbiAgICAgICAgbGMgLT0gODtcbiAgICAgICAgdmFyIGNzID0gYyA+PiBsYztcbiAgICAgICAgdmFyIGNzID0gbmV3IFVpbnQ4QXJyYXkoW2NzXSlbMF07XG4gICAgICAgIGlmIChvdXRCdWZmZXJPZmZzZXQudmFsdWUgKyBjcyA+IG91dEJ1ZmZlckVuZE9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcyA9IG91dEJ1ZmZlcltvdXRCdWZmZXJPZmZzZXQudmFsdWUgLSAxXTtcbiAgICAgICAgd2hpbGUgKGNzLS0gPiAwKSB7XG4gICAgICAgICAgb3V0QnVmZmVyW291dEJ1ZmZlck9mZnNldC52YWx1ZSsrXSA9IHM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob3V0QnVmZmVyT2Zmc2V0LnZhbHVlIDwgb3V0QnVmZmVyRW5kT2Zmc2V0KSB7XG4gICAgICAgIG91dEJ1ZmZlcltvdXRCdWZmZXJPZmZzZXQudmFsdWUrK10gPSBwbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGdldENvZGVSZXR1cm4uYyA9IGM7XG4gICAgICBnZXRDb2RlUmV0dXJuLmxjID0gbGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVJbnQxNih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYgNjU1MzU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEludDE2KHZhbHVlKSB7XG4gICAgICB2YXIgcmVmID0gVUludDE2KHZhbHVlKTtcbiAgICAgIHJldHVybiByZWYgPiAzMjc2NyA/IHJlZiAtIDY1NTM2IDogcmVmO1xuICAgIH1cbiAgICBjb25zdCB3ZGVjMTRSZXR1cm4gPSB7IGE6IDAsIGI6IDAgfTtcbiAgICBmdW5jdGlvbiB3ZGVjMTQobCwgaCkge1xuICAgICAgdmFyIGxzID0gSW50MTYobCk7XG4gICAgICB2YXIgaHMgPSBJbnQxNihoKTtcbiAgICAgIHZhciBoaSA9IGhzO1xuICAgICAgdmFyIGFpID0gbHMgKyAoaGkgJiAxKSArIChoaSA+PiAxKTtcbiAgICAgIHZhciBhcyA9IGFpO1xuICAgICAgdmFyIGJzID0gYWkgLSBoaTtcbiAgICAgIHdkZWMxNFJldHVybi5hID0gYXM7XG4gICAgICB3ZGVjMTRSZXR1cm4uYiA9IGJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3ZGVjMTYobCwgaCkge1xuICAgICAgdmFyIG0gPSBVSW50MTYobCk7XG4gICAgICB2YXIgZCA9IFVJbnQxNihoKTtcbiAgICAgIHZhciBiYiA9IG0gLSAoZCA+PiAxKSAmIE1PRF9NQVNLO1xuICAgICAgdmFyIGFhID0gZCArIGJiIC0gQV9PRkZTRVQgJiBNT0RfTUFTSztcbiAgICAgIHdkZWMxNFJldHVybi5hID0gYWE7XG4gICAgICB3ZGVjMTRSZXR1cm4uYiA9IGJiO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXYyRGVjb2RlKGJ1ZmZlcjIsIGosIG54LCBveCwgbnksIG95LCBteCkge1xuICAgICAgdmFyIHcxNCA9IG14IDwgMSA8PCAxNDtcbiAgICAgIHZhciBuID0gbnggPiBueSA/IG55IDogbng7XG4gICAgICB2YXIgcCA9IDE7XG4gICAgICB2YXIgcDI7XG4gICAgICB3aGlsZSAocCA8PSBuKVxuICAgICAgICBwIDw8PSAxO1xuICAgICAgcCA+Pj0gMTtcbiAgICAgIHAyID0gcDtcbiAgICAgIHAgPj49IDE7XG4gICAgICB3aGlsZSAocCA+PSAxKSB7XG4gICAgICAgIHZhciBweSA9IDA7XG4gICAgICAgIHZhciBleSA9IHB5ICsgb3kgKiAobnkgLSBwMik7XG4gICAgICAgIHZhciBveTEgPSBveSAqIHA7XG4gICAgICAgIHZhciBveTIgPSBveSAqIHAyO1xuICAgICAgICB2YXIgb3gxID0gb3ggKiBwO1xuICAgICAgICB2YXIgb3gyID0gb3ggKiBwMjtcbiAgICAgICAgdmFyIGkwMCwgaTAxLCBpMTAsIGkxMTtcbiAgICAgICAgZm9yICg7IHB5IDw9IGV5OyBweSArPSBveTIpIHtcbiAgICAgICAgICB2YXIgcHggPSBweTtcbiAgICAgICAgICB2YXIgZXggPSBweSArIG94ICogKG54IC0gcDIpO1xuICAgICAgICAgIGZvciAoOyBweCA8PSBleDsgcHggKz0gb3gyKSB7XG4gICAgICAgICAgICB2YXIgcDAxID0gcHggKyBveDE7XG4gICAgICAgICAgICB2YXIgcDEwID0gcHggKyBveTE7XG4gICAgICAgICAgICB2YXIgcDExID0gcDEwICsgb3gxO1xuICAgICAgICAgICAgaWYgKHcxNCkge1xuICAgICAgICAgICAgICB3ZGVjMTQoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AxMCArIGpdKTtcbiAgICAgICAgICAgICAgaTAwID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGkxMCA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgICB3ZGVjMTQoYnVmZmVyMltwMDEgKyBqXSwgYnVmZmVyMltwMTEgKyBqXSk7XG4gICAgICAgICAgICAgIGkwMSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBpMTEgPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE0KGkwMCwgaTAxKTtcbiAgICAgICAgICAgICAgYnVmZmVyMltweCArIGpdID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcDAxICsgal0gPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE0KGkxMCwgaTExKTtcbiAgICAgICAgICAgICAgYnVmZmVyMltwMTAgKyBqXSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBidWZmZXIyW3AxMSArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3ZGVjMTYoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AxMCArIGpdKTtcbiAgICAgICAgICAgICAgaTAwID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGkxMCA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgICB3ZGVjMTYoYnVmZmVyMltwMDEgKyBqXSwgYnVmZmVyMltwMTEgKyBqXSk7XG4gICAgICAgICAgICAgIGkwMSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBpMTEgPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE2KGkwMCwgaTAxKTtcbiAgICAgICAgICAgICAgYnVmZmVyMltweCArIGpdID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcDAxICsgal0gPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE2KGkxMCwgaTExKTtcbiAgICAgICAgICAgICAgYnVmZmVyMltwMTAgKyBqXSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBidWZmZXIyW3AxMSArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChueCAmIHApIHtcbiAgICAgICAgICAgIHZhciBwMTAgPSBweCArIG95MTtcbiAgICAgICAgICAgIGlmICh3MTQpXG4gICAgICAgICAgICAgIHdkZWMxNChidWZmZXIyW3B4ICsgal0sIGJ1ZmZlcjJbcDEwICsgal0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB3ZGVjMTYoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AxMCArIGpdKTtcbiAgICAgICAgICAgIGkwMCA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgYnVmZmVyMltwMTAgKyBqXSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgYnVmZmVyMltweCArIGpdID0gaTAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnkgJiBwKSB7XG4gICAgICAgICAgdmFyIHB4ID0gcHk7XG4gICAgICAgICAgdmFyIGV4ID0gcHkgKyBveCAqIChueCAtIHAyKTtcbiAgICAgICAgICBmb3IgKDsgcHggPD0gZXg7IHB4ICs9IG94Mikge1xuICAgICAgICAgICAgdmFyIHAwMSA9IHB4ICsgb3gxO1xuICAgICAgICAgICAgaWYgKHcxNClcbiAgICAgICAgICAgICAgd2RlYzE0KGJ1ZmZlcjJbcHggKyBqXSwgYnVmZmVyMltwMDEgKyBqXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHdkZWMxNihidWZmZXIyW3B4ICsgal0sIGJ1ZmZlcjJbcDAxICsgal0pO1xuICAgICAgICAgICAgaTAwID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICBidWZmZXIyW3AwMSArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICBidWZmZXIyW3B4ICsgal0gPSBpMDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAyID0gcDtcbiAgICAgICAgcCA+Pj0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBweTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmRGVjb2RlKGVuY29kaW5nVGFibGUsIGRlY29kaW5nVGFibGUsIHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbmksIHJsYywgbm8sIG91dEJ1ZmZlciwgb3V0T2Zmc2V0KSB7XG4gICAgICB2YXIgYyA9IDA7XG4gICAgICB2YXIgbGMgPSAwO1xuICAgICAgdmFyIG91dEJ1ZmZlckVuZE9mZnNldCA9IG5vO1xuICAgICAgdmFyIGluT2Zmc2V0RW5kID0gTWF0aC50cnVuYyhpbk9mZnNldC52YWx1ZSArIChuaSArIDcpIC8gOCk7XG4gICAgICB3aGlsZSAoaW5PZmZzZXQudmFsdWUgPCBpbk9mZnNldEVuZCkge1xuICAgICAgICBnZXRDaGFyKGMsIGxjLCB1SW50OEFycmF5MiwgaW5PZmZzZXQpO1xuICAgICAgICBjID0gZ2V0Q2hhclJldHVybi5jO1xuICAgICAgICBsYyA9IGdldENoYXJSZXR1cm4ubGM7XG4gICAgICAgIHdoaWxlIChsYyA+PSBIVUZfREVDQklUUykge1xuICAgICAgICAgIHZhciBpbmRleCA9IGMgPj4gbGMgLSBIVUZfREVDQklUUyAmIEhVRl9ERUNNQVNLO1xuICAgICAgICAgIHZhciBwbCA9IGRlY29kaW5nVGFibGVbaW5kZXhdO1xuICAgICAgICAgIGlmIChwbC5sZW4pIHtcbiAgICAgICAgICAgIGxjIC09IHBsLmxlbjtcbiAgICAgICAgICAgIGdldENvZGUocGwubGl0LCBybGMsIGMsIGxjLCB1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG91dEJ1ZmZlciwgb3V0T2Zmc2V0LCBvdXRCdWZmZXJFbmRPZmZzZXQpO1xuICAgICAgICAgICAgYyA9IGdldENvZGVSZXR1cm4uYztcbiAgICAgICAgICAgIGxjID0gZ2V0Q29kZVJldHVybi5sYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFwbC5wKSB7XG4gICAgICAgICAgICAgIHRocm93IFwiaHVmRGVjb2RlIGlzc3Vlc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGo7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGwubGl0OyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIGwgPSBodWZMZW5ndGgoZW5jb2RpbmdUYWJsZVtwbC5wW2pdXSk7XG4gICAgICAgICAgICAgIHdoaWxlIChsYyA8IGwgJiYgaW5PZmZzZXQudmFsdWUgPCBpbk9mZnNldEVuZCkge1xuICAgICAgICAgICAgICAgIGdldENoYXIoYywgbGMsIHVJbnQ4QXJyYXkyLCBpbk9mZnNldCk7XG4gICAgICAgICAgICAgICAgYyA9IGdldENoYXJSZXR1cm4uYztcbiAgICAgICAgICAgICAgICBsYyA9IGdldENoYXJSZXR1cm4ubGM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxjID49IGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaHVmQ29kZShlbmNvZGluZ1RhYmxlW3BsLnBbal1dKSA9PSAoYyA+PiBsYyAtIGwgJiAoMSA8PCBsKSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICBsYyAtPSBsO1xuICAgICAgICAgICAgICAgICAgZ2V0Q29kZShcbiAgICAgICAgICAgICAgICAgICAgcGwucFtqXSxcbiAgICAgICAgICAgICAgICAgICAgcmxjLFxuICAgICAgICAgICAgICAgICAgICBjLFxuICAgICAgICAgICAgICAgICAgICBsYyxcbiAgICAgICAgICAgICAgICAgICAgdUludDhBcnJheTIsXG4gICAgICAgICAgICAgICAgICAgIGluRGF0YVZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGluT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBvdXRCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIG91dE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgb3V0QnVmZmVyRW5kT2Zmc2V0XG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYyA9IGdldENvZGVSZXR1cm4uYztcbiAgICAgICAgICAgICAgICAgIGxjID0gZ2V0Q29kZVJldHVybi5sYztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogPT0gcGwubGl0KSB7XG4gICAgICAgICAgICAgIHRocm93IFwiaHVmRGVjb2RlIGlzc3Vlc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGkgPSA4IC0gbmkgJiA3O1xuICAgICAgYyA+Pj0gaTtcbiAgICAgIGxjIC09IGk7XG4gICAgICB3aGlsZSAobGMgPiAwKSB7XG4gICAgICAgIHZhciBwbCA9IGRlY29kaW5nVGFibGVbYyA8PCBIVUZfREVDQklUUyAtIGxjICYgSFVGX0RFQ01BU0tdO1xuICAgICAgICBpZiAocGwubGVuKSB7XG4gICAgICAgICAgbGMgLT0gcGwubGVuO1xuICAgICAgICAgIGdldENvZGUocGwubGl0LCBybGMsIGMsIGxjLCB1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG91dEJ1ZmZlciwgb3V0T2Zmc2V0LCBvdXRCdWZmZXJFbmRPZmZzZXQpO1xuICAgICAgICAgIGMgPSBnZXRDb2RlUmV0dXJuLmM7XG4gICAgICAgICAgbGMgPSBnZXRDb2RlUmV0dXJuLmxjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IFwiaHVmRGVjb2RlIGlzc3Vlc1wiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmVW5jb21wcmVzcyh1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG5Db21wcmVzc2VkLCBvdXRCdWZmZXIsIG5SYXcpIHtcbiAgICAgIHZhciBvdXRPZmZzZXQgPSB7IHZhbHVlOiAwIH07XG4gICAgICB2YXIgaW5pdGlhbEluT2Zmc2V0ID0gaW5PZmZzZXQudmFsdWU7XG4gICAgICB2YXIgaW0gPSBwYXJzZVVpbnQzMihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICB2YXIgaU0gPSBwYXJzZVVpbnQzMihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICBpbk9mZnNldC52YWx1ZSArPSA0O1xuICAgICAgdmFyIG5CaXRzID0gcGFyc2VVaW50MzIoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgaW5PZmZzZXQudmFsdWUgKz0gNDtcbiAgICAgIGlmIChpbSA8IDAgfHwgaW0gPj0gSFVGX0VOQ1NJWkUgfHwgaU0gPCAwIHx8IGlNID49IEhVRl9FTkNTSVpFKSB7XG4gICAgICAgIHRocm93IFwiU29tZXRoaW5nIHdyb25nIHdpdGggSFVGX0VOQ1NJWkVcIjtcbiAgICAgIH1cbiAgICAgIHZhciBmcmVxID0gbmV3IEFycmF5KEhVRl9FTkNTSVpFKTtcbiAgICAgIHZhciBoZGVjID0gbmV3IEFycmF5KEhVRl9ERUNTSVpFKTtcbiAgICAgIGh1ZkNsZWFyRGVjVGFibGUoaGRlYyk7XG4gICAgICB2YXIgbmkgPSBuQ29tcHJlc3NlZCAtIChpbk9mZnNldC52YWx1ZSAtIGluaXRpYWxJbk9mZnNldCk7XG4gICAgICBodWZVbnBhY2tFbmNUYWJsZSh1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG5pLCBpbSwgaU0sIGZyZXEpO1xuICAgICAgaWYgKG5CaXRzID4gOCAqIChuQ29tcHJlc3NlZCAtIChpbk9mZnNldC52YWx1ZSAtIGluaXRpYWxJbk9mZnNldCkpKSB7XG4gICAgICAgIHRocm93IFwiU29tZXRoaW5nIHdyb25nIHdpdGggaHVmVW5jb21wcmVzc1wiO1xuICAgICAgfVxuICAgICAgaHVmQnVpbGREZWNUYWJsZShmcmVxLCBpbSwgaU0sIGhkZWMpO1xuICAgICAgaHVmRGVjb2RlKGZyZXEsIGhkZWMsIHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbkJpdHMsIGlNLCBuUmF3LCBvdXRCdWZmZXIsIG91dE9mZnNldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5THV0KGx1dCwgZGF0YSwgbkRhdGEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkRhdGE7ICsraSkge1xuICAgICAgICBkYXRhW2ldID0gbHV0W2RhdGFbaV1dO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVkaWN0b3Ioc291cmNlKSB7XG4gICAgICBmb3IgKHZhciB0ID0gMTsgdCA8IHNvdXJjZS5sZW5ndGg7IHQrKykge1xuICAgICAgICB2YXIgZCA9IHNvdXJjZVt0IC0gMV0gKyBzb3VyY2VbdF0gLSAxMjg7XG4gICAgICAgIHNvdXJjZVt0XSA9IGQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVybGVhdmVTY2FsYXIoc291cmNlLCBvdXQpIHtcbiAgICAgIHZhciB0MSA9IDA7XG4gICAgICB2YXIgdDIgPSBNYXRoLmZsb29yKChzb3VyY2UubGVuZ3RoICsgMSkgLyAyKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBzdG9wID0gc291cmNlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAocyA+IHN0b3ApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIG91dFtzKytdID0gc291cmNlW3QxKytdO1xuICAgICAgICBpZiAocyA+IHN0b3ApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIG91dFtzKytdID0gc291cmNlW3QyKytdO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVSdW5MZW5ndGgoc291cmNlKSB7XG4gICAgICB2YXIgc2l6ZSA9IHNvdXJjZS5ieXRlTGVuZ3RoO1xuICAgICAgdmFyIG91dCA9IG5ldyBBcnJheSgpO1xuICAgICAgdmFyIHAgPSAwO1xuICAgICAgdmFyIHJlYWRlciA9IG5ldyBEYXRhVmlldyhzb3VyY2UpO1xuICAgICAgd2hpbGUgKHNpemUgPiAwKSB7XG4gICAgICAgIHZhciBsID0gcmVhZGVyLmdldEludDgocCsrKTtcbiAgICAgICAgaWYgKGwgPCAwKSB7XG4gICAgICAgICAgdmFyIGNvdW50ID0gLWw7XG4gICAgICAgICAgc2l6ZSAtPSBjb3VudCArIDE7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBvdXQucHVzaChyZWFkZXIuZ2V0VWludDgocCsrKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjb3VudCA9IGw7XG4gICAgICAgICAgc2l6ZSAtPSAyO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHJlYWRlci5nZXRVaW50OChwKyspO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvc3N5RGN0RGVjb2RlKGNzY1NldCwgcm93UHRycywgY2hhbm5lbERhdGEsIGFjQnVmZmVyLCBkY0J1ZmZlciwgb3V0QnVmZmVyKSB7XG4gICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcob3V0QnVmZmVyLmJ1ZmZlcik7XG4gICAgICB2YXIgd2lkdGggPSBjaGFubmVsRGF0YVtjc2NTZXQuaWR4WzBdXS53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBjaGFubmVsRGF0YVtjc2NTZXQuaWR4WzBdXS5oZWlnaHQ7XG4gICAgICB2YXIgbnVtQ29tcCA9IDM7XG4gICAgICB2YXIgbnVtRnVsbEJsb2Nrc1ggPSBNYXRoLmZsb29yKHdpZHRoIC8gOCk7XG4gICAgICB2YXIgbnVtQmxvY2tzWCA9IE1hdGguY2VpbCh3aWR0aCAvIDgpO1xuICAgICAgdmFyIG51bUJsb2Nrc1kgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gOCk7XG4gICAgICB2YXIgbGVmdG92ZXJYID0gd2lkdGggLSAobnVtQmxvY2tzWCAtIDEpICogODtcbiAgICAgIHZhciBsZWZ0b3ZlclkgPSBoZWlnaHQgLSAobnVtQmxvY2tzWSAtIDEpICogODtcbiAgICAgIHZhciBjdXJyQWNDb21wID0geyB2YWx1ZTogMCB9O1xuICAgICAgdmFyIGN1cnJEY0NvbXAgPSBuZXcgQXJyYXkobnVtQ29tcCk7XG4gICAgICB2YXIgZGN0RGF0YSA9IG5ldyBBcnJheShudW1Db21wKTtcbiAgICAgIHZhciBoYWxmWmlnQmxvY2sgPSBuZXcgQXJyYXkobnVtQ29tcCk7XG4gICAgICB2YXIgcm93QmxvY2sgPSBuZXcgQXJyYXkobnVtQ29tcCk7XG4gICAgICB2YXIgcm93T2Zmc2V0cyA9IG5ldyBBcnJheShudW1Db21wKTtcbiAgICAgIGZvciAobGV0IGNvbXAyID0gMDsgY29tcDIgPCBudW1Db21wOyArK2NvbXAyKSB7XG4gICAgICAgIHJvd09mZnNldHNbY29tcDJdID0gcm93UHRyc1tjc2NTZXQuaWR4W2NvbXAyXV07XG4gICAgICAgIGN1cnJEY0NvbXBbY29tcDJdID0gY29tcDIgPCAxID8gMCA6IGN1cnJEY0NvbXBbY29tcDIgLSAxXSArIG51bUJsb2Nrc1ggKiBudW1CbG9ja3NZO1xuICAgICAgICBkY3REYXRhW2NvbXAyXSA9IG5ldyBGbG9hdDMyQXJyYXkoNjQpO1xuICAgICAgICBoYWxmWmlnQmxvY2tbY29tcDJdID0gbmV3IFVpbnQxNkFycmF5KDY0KTtcbiAgICAgICAgcm93QmxvY2tbY29tcDJdID0gbmV3IFVpbnQxNkFycmF5KG51bUJsb2Nrc1ggKiA2NCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBibG9ja3kgPSAwOyBibG9ja3kgPCBudW1CbG9ja3NZOyArK2Jsb2NreSkge1xuICAgICAgICB2YXIgbWF4WSA9IDg7XG4gICAgICAgIGlmIChibG9ja3kgPT0gbnVtQmxvY2tzWSAtIDEpXG4gICAgICAgICAgbWF4WSA9IGxlZnRvdmVyWTtcbiAgICAgICAgdmFyIG1heFggPSA4O1xuICAgICAgICBmb3IgKGxldCBibG9ja3ggPSAwOyBibG9ja3ggPCBudW1CbG9ja3NYOyArK2Jsb2NreCkge1xuICAgICAgICAgIGlmIChibG9ja3ggPT0gbnVtQmxvY2tzWCAtIDEpXG4gICAgICAgICAgICBtYXhYID0gbGVmdG92ZXJYO1xuICAgICAgICAgIGZvciAobGV0IGNvbXAyID0gMDsgY29tcDIgPCBudW1Db21wOyArK2NvbXAyKSB7XG4gICAgICAgICAgICBoYWxmWmlnQmxvY2tbY29tcDJdLmZpbGwoMCk7XG4gICAgICAgICAgICBoYWxmWmlnQmxvY2tbY29tcDJdWzBdID0gZGNCdWZmZXJbY3VyckRjQ29tcFtjb21wMl0rK107XG4gICAgICAgICAgICB1blJsZUFDKGN1cnJBY0NvbXAsIGFjQnVmZmVyLCBoYWxmWmlnQmxvY2tbY29tcDJdKTtcbiAgICAgICAgICAgIHVuWmlnWmFnKGhhbGZaaWdCbG9ja1tjb21wMl0sIGRjdERhdGFbY29tcDJdKTtcbiAgICAgICAgICAgIGRjdEludmVyc2UoZGN0RGF0YVtjb21wMl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB7XG4gICAgICAgICAgICBjc2M3MDlJbnZlcnNlKGRjdERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBjb21wMiA9IDA7IGNvbXAyIDwgbnVtQ29tcDsgKytjb21wMikge1xuICAgICAgICAgICAgY29udmVydFRvSGFsZihkY3REYXRhW2NvbXAyXSwgcm93QmxvY2tbY29tcDJdLCBibG9ja3ggKiA2NCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBvZmZzZXQyID0gMDtcbiAgICAgICAgZm9yIChsZXQgY29tcDIgPSAwOyBjb21wMiA8IG51bUNvbXA7ICsrY29tcDIpIHtcbiAgICAgICAgICBjb25zdCB0eXBlMiA9IGNoYW5uZWxEYXRhW2NzY1NldC5pZHhbY29tcDJdXS50eXBlO1xuICAgICAgICAgIGZvciAobGV0IHkyID0gOCAqIGJsb2NreTsgeTIgPCA4ICogYmxvY2t5ICsgbWF4WTsgKyt5Mikge1xuICAgICAgICAgICAgb2Zmc2V0MiA9IHJvd09mZnNldHNbY29tcDJdW3kyXTtcbiAgICAgICAgICAgIGZvciAobGV0IGJsb2NreCA9IDA7IGJsb2NreCA8IG51bUZ1bGxCbG9ja3NYOyArK2Jsb2NreCkge1xuICAgICAgICAgICAgICBjb25zdCBzcmMgPSBibG9ja3ggKiA2NCArICh5MiAmIDcpICogODtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyAwICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgMF0sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDEgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyAxXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgMiAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDJdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyAzICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgM10sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDQgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyA0XSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgNSAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDVdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyA2ICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgNl0sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDcgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyA3XSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIG9mZnNldDIgKz0gOCAqIElOVDE2X1NJWkUgKiB0eXBlMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG51bUZ1bGxCbG9ja3NYICE9IG51bUJsb2Nrc1gpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkyID0gOCAqIGJsb2NreTsgeTIgPCA4ICogYmxvY2t5ICsgbWF4WTsgKyt5Mikge1xuICAgICAgICAgICAgICBjb25zdCBvZmZzZXQzID0gcm93T2Zmc2V0c1tjb21wMl1beTJdICsgOCAqIG51bUZ1bGxCbG9ja3NYICogSU5UMTZfU0laRSAqIHR5cGUyO1xuICAgICAgICAgICAgICBjb25zdCBzcmMgPSBudW1GdWxsQmxvY2tzWCAqIDY0ICsgKHkyICYgNykgKiA4O1xuICAgICAgICAgICAgICBmb3IgKGxldCB4MiA9IDA7IHgyIDwgbWF4WDsgKyt4Mikge1xuICAgICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQzICsgeDIgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyB4Ml0sIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaGFsZlJvdyA9IG5ldyBVaW50MTZBcnJheSh3aWR0aCk7XG4gICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcob3V0QnVmZmVyLmJ1ZmZlcik7XG4gICAgICBmb3IgKHZhciBjb21wID0gMDsgY29tcCA8IG51bUNvbXA7ICsrY29tcCkge1xuICAgICAgICBjaGFubmVsRGF0YVtjc2NTZXQuaWR4W2NvbXBdXS5kZWNvZGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHR5cGUgPSBjaGFubmVsRGF0YVtjc2NTZXQuaWR4W2NvbXBdXS50eXBlO1xuICAgICAgICBpZiAoY2hhbm5lbERhdGFbY29tcF0udHlwZSAhPSAyKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IHJvd09mZnNldHNbY29tcF1beV07XG4gICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7XG4gICAgICAgICAgICBoYWxmUm93W3hdID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldDIgKyB4ICogSU5UMTZfU0laRSAqIHR5cGUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgICAgIGRhdGFWaWV3LnNldEZsb2F0MzIob2Zmc2V0MiArIHggKiBJTlQxNl9TSVpFICogdHlwZSwgZGVjb2RlRmxvYXQxNihoYWxmUm93W3hdKSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuUmxlQUMoY3VyckFjQ29tcCwgYWNCdWZmZXIsIGhhbGZaaWdCbG9jaykge1xuICAgICAgdmFyIGFjVmFsdWU7XG4gICAgICB2YXIgZGN0Q29tcCA9IDE7XG4gICAgICB3aGlsZSAoZGN0Q29tcCA8IDY0KSB7XG4gICAgICAgIGFjVmFsdWUgPSBhY0J1ZmZlcltjdXJyQWNDb21wLnZhbHVlXTtcbiAgICAgICAgaWYgKGFjVmFsdWUgPT0gNjUyODApIHtcbiAgICAgICAgICBkY3RDb21wID0gNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYWNWYWx1ZSA+PiA4ID09IDI1NSkge1xuICAgICAgICAgIGRjdENvbXAgKz0gYWNWYWx1ZSAmIDI1NTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYWxmWmlnQmxvY2tbZGN0Q29tcF0gPSBhY1ZhbHVlO1xuICAgICAgICAgIGRjdENvbXArKztcbiAgICAgICAgfVxuICAgICAgICBjdXJyQWNDb21wLnZhbHVlKys7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuWmlnWmFnKHNyYywgZHN0KSB7XG4gICAgICBkc3RbMF0gPSBkZWNvZGVGbG9hdDE2KHNyY1swXSk7XG4gICAgICBkc3RbMV0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxXSk7XG4gICAgICBkc3RbMl0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1XSk7XG4gICAgICBkc3RbM10gPSBkZWNvZGVGbG9hdDE2KHNyY1s2XSk7XG4gICAgICBkc3RbNF0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxNF0pO1xuICAgICAgZHN0WzVdID0gZGVjb2RlRmxvYXQxNihzcmNbMTVdKTtcbiAgICAgIGRzdFs2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzI3XSk7XG4gICAgICBkc3RbN10gPSBkZWNvZGVGbG9hdDE2KHNyY1syOF0pO1xuICAgICAgZHN0WzhdID0gZGVjb2RlRmxvYXQxNihzcmNbMl0pO1xuICAgICAgZHN0WzldID0gZGVjb2RlRmxvYXQxNihzcmNbNF0pO1xuICAgICAgZHN0WzEwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzddKTtcbiAgICAgIGRzdFsxMV0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxM10pO1xuICAgICAgZHN0WzEyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzE2XSk7XG4gICAgICBkc3RbMTNdID0gZGVjb2RlRmxvYXQxNihzcmNbMjZdKTtcbiAgICAgIGRzdFsxNF0gPSBkZWNvZGVGbG9hdDE2KHNyY1syOV0pO1xuICAgICAgZHN0WzE1XSA9IGRlY29kZUZsb2F0MTYoc3JjWzQyXSk7XG4gICAgICBkc3RbMTZdID0gZGVjb2RlRmxvYXQxNihzcmNbM10pO1xuICAgICAgZHN0WzE3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzhdKTtcbiAgICAgIGRzdFsxOF0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxMl0pO1xuICAgICAgZHN0WzE5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzE3XSk7XG4gICAgICBkc3RbMjBdID0gZGVjb2RlRmxvYXQxNihzcmNbMjVdKTtcbiAgICAgIGRzdFsyMV0gPSBkZWNvZGVGbG9hdDE2KHNyY1szMF0pO1xuICAgICAgZHN0WzIyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzQxXSk7XG4gICAgICBkc3RbMjNdID0gZGVjb2RlRmxvYXQxNihzcmNbNDNdKTtcbiAgICAgIGRzdFsyNF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s5XSk7XG4gICAgICBkc3RbMjVdID0gZGVjb2RlRmxvYXQxNihzcmNbMTFdKTtcbiAgICAgIGRzdFsyNl0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxOF0pO1xuICAgICAgZHN0WzI3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzI0XSk7XG4gICAgICBkc3RbMjhdID0gZGVjb2RlRmxvYXQxNihzcmNbMzFdKTtcbiAgICAgIGRzdFsyOV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0MF0pO1xuICAgICAgZHN0WzMwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ0XSk7XG4gICAgICBkc3RbMzFdID0gZGVjb2RlRmxvYXQxNihzcmNbNTNdKTtcbiAgICAgIGRzdFszMl0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxMF0pO1xuICAgICAgZHN0WzMzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzE5XSk7XG4gICAgICBkc3RbMzRdID0gZGVjb2RlRmxvYXQxNihzcmNbMjNdKTtcbiAgICAgIGRzdFszNV0gPSBkZWNvZGVGbG9hdDE2KHNyY1szMl0pO1xuICAgICAgZHN0WzM2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzM5XSk7XG4gICAgICBkc3RbMzddID0gZGVjb2RlRmxvYXQxNihzcmNbNDVdKTtcbiAgICAgIGRzdFszOF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1Ml0pO1xuICAgICAgZHN0WzM5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzU0XSk7XG4gICAgICBkc3RbNDBdID0gZGVjb2RlRmxvYXQxNihzcmNbMjBdKTtcbiAgICAgIGRzdFs0MV0gPSBkZWNvZGVGbG9hdDE2KHNyY1syMl0pO1xuICAgICAgZHN0WzQyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzMzXSk7XG4gICAgICBkc3RbNDNdID0gZGVjb2RlRmxvYXQxNihzcmNbMzhdKTtcbiAgICAgIGRzdFs0NF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0Nl0pO1xuICAgICAgZHN0WzQ1XSA9IGRlY29kZUZsb2F0MTYoc3JjWzUxXSk7XG4gICAgICBkc3RbNDZdID0gZGVjb2RlRmxvYXQxNihzcmNbNTVdKTtcbiAgICAgIGRzdFs0N10gPSBkZWNvZGVGbG9hdDE2KHNyY1s2MF0pO1xuICAgICAgZHN0WzQ4XSA9IGRlY29kZUZsb2F0MTYoc3JjWzIxXSk7XG4gICAgICBkc3RbNDldID0gZGVjb2RlRmxvYXQxNihzcmNbMzRdKTtcbiAgICAgIGRzdFs1MF0gPSBkZWNvZGVGbG9hdDE2KHNyY1szN10pO1xuICAgICAgZHN0WzUxXSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ3XSk7XG4gICAgICBkc3RbNTJdID0gZGVjb2RlRmxvYXQxNihzcmNbNTBdKTtcbiAgICAgIGRzdFs1M10gPSBkZWNvZGVGbG9hdDE2KHNyY1s1Nl0pO1xuICAgICAgZHN0WzU0XSA9IGRlY29kZUZsb2F0MTYoc3JjWzU5XSk7XG4gICAgICBkc3RbNTVdID0gZGVjb2RlRmxvYXQxNihzcmNbNjFdKTtcbiAgICAgIGRzdFs1Nl0gPSBkZWNvZGVGbG9hdDE2KHNyY1szNV0pO1xuICAgICAgZHN0WzU3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzM2XSk7XG4gICAgICBkc3RbNThdID0gZGVjb2RlRmxvYXQxNihzcmNbNDhdKTtcbiAgICAgIGRzdFs1OV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0OV0pO1xuICAgICAgZHN0WzYwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzU3XSk7XG4gICAgICBkc3RbNjFdID0gZGVjb2RlRmxvYXQxNihzcmNbNThdKTtcbiAgICAgIGRzdFs2Ml0gPSBkZWNvZGVGbG9hdDE2KHNyY1s2Ml0pO1xuICAgICAgZHN0WzYzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzYzXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRjdEludmVyc2UoZGF0YSkge1xuICAgICAgY29uc3QgYSA9IDAuNSAqIE1hdGguY29zKDMuMTQxNTkgLyA0KTtcbiAgICAgIGNvbnN0IGIgPSAwLjUgKiBNYXRoLmNvcygzLjE0MTU5IC8gMTYpO1xuICAgICAgY29uc3QgYyA9IDAuNSAqIE1hdGguY29zKDMuMTQxNTkgLyA4KTtcbiAgICAgIGNvbnN0IGQgPSAwLjUgKiBNYXRoLmNvcygzICogMy4xNDE1OSAvIDE2KTtcbiAgICAgIGNvbnN0IGUgPSAwLjUgKiBNYXRoLmNvcyg1ICogMy4xNDE1OSAvIDE2KTtcbiAgICAgIGNvbnN0IGYgPSAwLjUgKiBNYXRoLmNvcygzICogMy4xNDE1OSAvIDgpO1xuICAgICAgY29uc3QgZyA9IDAuNSAqIE1hdGguY29zKDcgKiAzLjE0MTU5IC8gMTYpO1xuICAgICAgdmFyIGFscGhhID0gbmV3IEFycmF5KDQpO1xuICAgICAgdmFyIGJldGEgPSBuZXcgQXJyYXkoNCk7XG4gICAgICB2YXIgdGhldGEgPSBuZXcgQXJyYXkoNCk7XG4gICAgICB2YXIgZ2FtbWEgPSBuZXcgQXJyYXkoNCk7XG4gICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCA4OyArK3Jvdykge1xuICAgICAgICB2YXIgcm93UHRyID0gcm93ICogODtcbiAgICAgICAgYWxwaGFbMF0gPSBjICogZGF0YVtyb3dQdHIgKyAyXTtcbiAgICAgICAgYWxwaGFbMV0gPSBmICogZGF0YVtyb3dQdHIgKyAyXTtcbiAgICAgICAgYWxwaGFbMl0gPSBjICogZGF0YVtyb3dQdHIgKyA2XTtcbiAgICAgICAgYWxwaGFbM10gPSBmICogZGF0YVtyb3dQdHIgKyA2XTtcbiAgICAgICAgYmV0YVswXSA9IGIgKiBkYXRhW3Jvd1B0ciArIDFdICsgZCAqIGRhdGFbcm93UHRyICsgM10gKyBlICogZGF0YVtyb3dQdHIgKyA1XSArIGcgKiBkYXRhW3Jvd1B0ciArIDddO1xuICAgICAgICBiZXRhWzFdID0gZCAqIGRhdGFbcm93UHRyICsgMV0gLSBnICogZGF0YVtyb3dQdHIgKyAzXSAtIGIgKiBkYXRhW3Jvd1B0ciArIDVdIC0gZSAqIGRhdGFbcm93UHRyICsgN107XG4gICAgICAgIGJldGFbMl0gPSBlICogZGF0YVtyb3dQdHIgKyAxXSAtIGIgKiBkYXRhW3Jvd1B0ciArIDNdICsgZyAqIGRhdGFbcm93UHRyICsgNV0gKyBkICogZGF0YVtyb3dQdHIgKyA3XTtcbiAgICAgICAgYmV0YVszXSA9IGcgKiBkYXRhW3Jvd1B0ciArIDFdIC0gZSAqIGRhdGFbcm93UHRyICsgM10gKyBkICogZGF0YVtyb3dQdHIgKyA1XSAtIGIgKiBkYXRhW3Jvd1B0ciArIDddO1xuICAgICAgICB0aGV0YVswXSA9IGEgKiAoZGF0YVtyb3dQdHIgKyAwXSArIGRhdGFbcm93UHRyICsgNF0pO1xuICAgICAgICB0aGV0YVszXSA9IGEgKiAoZGF0YVtyb3dQdHIgKyAwXSAtIGRhdGFbcm93UHRyICsgNF0pO1xuICAgICAgICB0aGV0YVsxXSA9IGFscGhhWzBdICsgYWxwaGFbM107XG4gICAgICAgIHRoZXRhWzJdID0gYWxwaGFbMV0gLSBhbHBoYVsyXTtcbiAgICAgICAgZ2FtbWFbMF0gPSB0aGV0YVswXSArIHRoZXRhWzFdO1xuICAgICAgICBnYW1tYVsxXSA9IHRoZXRhWzNdICsgdGhldGFbMl07XG4gICAgICAgIGdhbW1hWzJdID0gdGhldGFbM10gLSB0aGV0YVsyXTtcbiAgICAgICAgZ2FtbWFbM10gPSB0aGV0YVswXSAtIHRoZXRhWzFdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDBdID0gZ2FtbWFbMF0gKyBiZXRhWzBdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDFdID0gZ2FtbWFbMV0gKyBiZXRhWzFdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDJdID0gZ2FtbWFbMl0gKyBiZXRhWzJdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDNdID0gZ2FtbWFbM10gKyBiZXRhWzNdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDRdID0gZ2FtbWFbM10gLSBiZXRhWzNdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDVdID0gZ2FtbWFbMl0gLSBiZXRhWzJdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDZdID0gZ2FtbWFbMV0gLSBiZXRhWzFdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDddID0gZ2FtbWFbMF0gLSBiZXRhWzBdO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgY29sdW1uID0gMDsgY29sdW1uIDwgODsgKytjb2x1bW4pIHtcbiAgICAgICAgYWxwaGFbMF0gPSBjICogZGF0YVsxNiArIGNvbHVtbl07XG4gICAgICAgIGFscGhhWzFdID0gZiAqIGRhdGFbMTYgKyBjb2x1bW5dO1xuICAgICAgICBhbHBoYVsyXSA9IGMgKiBkYXRhWzQ4ICsgY29sdW1uXTtcbiAgICAgICAgYWxwaGFbM10gPSBmICogZGF0YVs0OCArIGNvbHVtbl07XG4gICAgICAgIGJldGFbMF0gPSBiICogZGF0YVs4ICsgY29sdW1uXSArIGQgKiBkYXRhWzI0ICsgY29sdW1uXSArIGUgKiBkYXRhWzQwICsgY29sdW1uXSArIGcgKiBkYXRhWzU2ICsgY29sdW1uXTtcbiAgICAgICAgYmV0YVsxXSA9IGQgKiBkYXRhWzggKyBjb2x1bW5dIC0gZyAqIGRhdGFbMjQgKyBjb2x1bW5dIC0gYiAqIGRhdGFbNDAgKyBjb2x1bW5dIC0gZSAqIGRhdGFbNTYgKyBjb2x1bW5dO1xuICAgICAgICBiZXRhWzJdID0gZSAqIGRhdGFbOCArIGNvbHVtbl0gLSBiICogZGF0YVsyNCArIGNvbHVtbl0gKyBnICogZGF0YVs0MCArIGNvbHVtbl0gKyBkICogZGF0YVs1NiArIGNvbHVtbl07XG4gICAgICAgIGJldGFbM10gPSBnICogZGF0YVs4ICsgY29sdW1uXSAtIGUgKiBkYXRhWzI0ICsgY29sdW1uXSArIGQgKiBkYXRhWzQwICsgY29sdW1uXSAtIGIgKiBkYXRhWzU2ICsgY29sdW1uXTtcbiAgICAgICAgdGhldGFbMF0gPSBhICogKGRhdGFbY29sdW1uXSArIGRhdGFbMzIgKyBjb2x1bW5dKTtcbiAgICAgICAgdGhldGFbM10gPSBhICogKGRhdGFbY29sdW1uXSAtIGRhdGFbMzIgKyBjb2x1bW5dKTtcbiAgICAgICAgdGhldGFbMV0gPSBhbHBoYVswXSArIGFscGhhWzNdO1xuICAgICAgICB0aGV0YVsyXSA9IGFscGhhWzFdIC0gYWxwaGFbMl07XG4gICAgICAgIGdhbW1hWzBdID0gdGhldGFbMF0gKyB0aGV0YVsxXTtcbiAgICAgICAgZ2FtbWFbMV0gPSB0aGV0YVszXSArIHRoZXRhWzJdO1xuICAgICAgICBnYW1tYVsyXSA9IHRoZXRhWzNdIC0gdGhldGFbMl07XG4gICAgICAgIGdhbW1hWzNdID0gdGhldGFbMF0gLSB0aGV0YVsxXTtcbiAgICAgICAgZGF0YVswICsgY29sdW1uXSA9IGdhbW1hWzBdICsgYmV0YVswXTtcbiAgICAgICAgZGF0YVs4ICsgY29sdW1uXSA9IGdhbW1hWzFdICsgYmV0YVsxXTtcbiAgICAgICAgZGF0YVsxNiArIGNvbHVtbl0gPSBnYW1tYVsyXSArIGJldGFbMl07XG4gICAgICAgIGRhdGFbMjQgKyBjb2x1bW5dID0gZ2FtbWFbM10gKyBiZXRhWzNdO1xuICAgICAgICBkYXRhWzMyICsgY29sdW1uXSA9IGdhbW1hWzNdIC0gYmV0YVszXTtcbiAgICAgICAgZGF0YVs0MCArIGNvbHVtbl0gPSBnYW1tYVsyXSAtIGJldGFbMl07XG4gICAgICAgIGRhdGFbNDggKyBjb2x1bW5dID0gZ2FtbWFbMV0gLSBiZXRhWzFdO1xuICAgICAgICBkYXRhWzU2ICsgY29sdW1uXSA9IGdhbW1hWzBdIC0gYmV0YVswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3NjNzA5SW52ZXJzZShkYXRhKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgICAgdmFyIHkgPSBkYXRhWzBdW2ldO1xuICAgICAgICB2YXIgY2IgPSBkYXRhWzFdW2ldO1xuICAgICAgICB2YXIgY3IgPSBkYXRhWzJdW2ldO1xuICAgICAgICBkYXRhWzBdW2ldID0geSArIDEuNTc0NyAqIGNyO1xuICAgICAgICBkYXRhWzFdW2ldID0geSAtIDAuMTg3MyAqIGNiIC0gMC40NjgyICogY3I7XG4gICAgICAgIGRhdGFbMl1baV0gPSB5ICsgMS44NTU2ICogY2I7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUb0hhbGYoc3JjLCBkc3QsIGlkeCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICAgIGRzdFtpZHggKyBpXSA9IERhdGFVdGlscy50b0hhbGZGbG9hdCh0b0xpbmVhcihzcmNbaV0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdG9MaW5lYXIoZmxvYXQpIHtcbiAgICAgIGlmIChmbG9hdCA8PSAxKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpZ24oZmxvYXQpICogTWF0aC5wb3coTWF0aC5hYnMoZmxvYXQpLCAyLjIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2lnbihmbG9hdCkgKiBNYXRoLnBvdyhsb2dCYXNlLCBNYXRoLmFicyhmbG9hdCkgLSAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1JBVyhpbmZvKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KGluZm8uYXJyYXkuYnVmZmVyLCBpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5zaXplKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1JMRShpbmZvKSB7XG4gICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8udmlld2VyLmJ1ZmZlci5zbGljZShpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5vZmZzZXQudmFsdWUgKyBpbmZvLnNpemUpO1xuICAgICAgdmFyIHJhd0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KGRlY29kZVJ1bkxlbmd0aChjb21wcmVzc2VkKSk7XG4gICAgICB2YXIgdG1wQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkocmF3QnVmZmVyLmxlbmd0aCk7XG4gICAgICBwcmVkaWN0b3IocmF3QnVmZmVyKTtcbiAgICAgIGludGVybGVhdmVTY2FsYXIocmF3QnVmZmVyLCB0bXBCdWZmZXIpO1xuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyh0bXBCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1pJUChpbmZvKSB7XG4gICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8uYXJyYXkuc2xpY2UoaW5mby5vZmZzZXQudmFsdWUsIGluZm8ub2Zmc2V0LnZhbHVlICsgaW5mby5zaXplKTtcbiAgICAgIHZhciByYXdCdWZmZXIgPSB1bnpsaWJTeW5jKGNvbXByZXNzZWQpO1xuICAgICAgdmFyIHRtcEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHJhd0J1ZmZlci5sZW5ndGgpO1xuICAgICAgcHJlZGljdG9yKHJhd0J1ZmZlcik7XG4gICAgICBpbnRlcmxlYXZlU2NhbGFyKHJhd0J1ZmZlciwgdG1wQnVmZmVyKTtcbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcodG1wQnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY29tcHJlc3NQSVooaW5mbykge1xuICAgICAgdmFyIGluRGF0YVZpZXcgPSBpbmZvLnZpZXdlcjtcbiAgICAgIHZhciBpbk9mZnNldCA9IHsgdmFsdWU6IGluZm8ub2Zmc2V0LnZhbHVlIH07XG4gICAgICB2YXIgb3V0QnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KGluZm8ud2lkdGggKiBpbmZvLnNjYW5saW5lQmxvY2tTaXplICogKGluZm8uY2hhbm5lbHMgKiBpbmZvLnR5cGUpKTtcbiAgICAgIHZhciBiaXRtYXAgPSBuZXcgVWludDhBcnJheShCSVRNQVBfU0laRSk7XG4gICAgICB2YXIgb3V0QnVmZmVyRW5kID0gMDtcbiAgICAgIHZhciBwaXpDaGFubmVsRGF0YSA9IG5ldyBBcnJheShpbmZvLmNoYW5uZWxzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5mby5jaGFubmVsczsgaSsrKSB7XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldID0ge307XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldW1wic3RhcnRcIl0gPSBvdXRCdWZmZXJFbmQ7XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldW1wiZW5kXCJdID0gcGl6Q2hhbm5lbERhdGFbaV1bXCJzdGFydFwiXTtcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bXCJueFwiXSA9IGluZm8ud2lkdGg7XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldW1wibnlcIl0gPSBpbmZvLmxpbmVzO1xuICAgICAgICBwaXpDaGFubmVsRGF0YVtpXVtcInNpemVcIl0gPSBpbmZvLnR5cGU7XG4gICAgICAgIG91dEJ1ZmZlckVuZCArPSBwaXpDaGFubmVsRGF0YVtpXS5ueCAqIHBpekNoYW5uZWxEYXRhW2ldLm55ICogcGl6Q2hhbm5lbERhdGFbaV0uc2l6ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtaW5Ob25aZXJvID0gcGFyc2VVaW50MTYoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgdmFyIG1heE5vblplcm8gPSBwYXJzZVVpbnQxNihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICBpZiAobWF4Tm9uWmVybyA+PSBCSVRNQVBfU0laRSkge1xuICAgICAgICB0aHJvdyBcIlNvbWV0aGluZyBpcyB3cm9uZyB3aXRoIFBJWl9DT01QUkVTU0lPTiBCSVRNQVBfU0laRVwiO1xuICAgICAgfVxuICAgICAgaWYgKG1pbk5vblplcm8gPD0gbWF4Tm9uWmVybykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heE5vblplcm8gLSBtaW5Ob25aZXJvICsgMTsgaSsrKSB7XG4gICAgICAgICAgYml0bWFwW2kgKyBtaW5Ob25aZXJvXSA9IHBhcnNlVWludDgoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbHV0ID0gbmV3IFVpbnQxNkFycmF5KFVTSE9SVF9SQU5HRSk7XG4gICAgICB2YXIgbWF4VmFsdWUgPSByZXZlcnNlTHV0RnJvbUJpdG1hcChiaXRtYXAsIGx1dCk7XG4gICAgICB2YXIgbGVuZ3RoID0gcGFyc2VVaW50MzIoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgaHVmVW5jb21wcmVzcyhpbmZvLmFycmF5LCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbGVuZ3RoLCBvdXRCdWZmZXIsIG91dEJ1ZmZlckVuZCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZm8uY2hhbm5lbHM7ICsraSkge1xuICAgICAgICB2YXIgY2QgPSBwaXpDaGFubmVsRGF0YVtpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwaXpDaGFubmVsRGF0YVtpXS5zaXplOyArK2opIHtcbiAgICAgICAgICB3YXYyRGVjb2RlKG91dEJ1ZmZlciwgY2Quc3RhcnQgKyBqLCBjZC5ueCwgY2Quc2l6ZSwgY2QubnksIGNkLm54ICogY2Quc2l6ZSwgbWF4VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHBseUx1dChsdXQsIG91dEJ1ZmZlciwgb3V0QnVmZmVyRW5kKTtcbiAgICAgIHZhciB0bXBPZmZzZXQyID0gMDtcbiAgICAgIHZhciB0bXBCdWZmZXIgPSBuZXcgVWludDhBcnJheShvdXRCdWZmZXIuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBpbmZvLmxpbmVzOyB5KyspIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBpbmZvLmNoYW5uZWxzOyBjKyspIHtcbiAgICAgICAgICB2YXIgY2QgPSBwaXpDaGFubmVsRGF0YVtjXTtcbiAgICAgICAgICB2YXIgbiA9IGNkLm54ICogY2Quc2l6ZTtcbiAgICAgICAgICB2YXIgY3AgPSBuZXcgVWludDhBcnJheShvdXRCdWZmZXIuYnVmZmVyLCBjZC5lbmQgKiBJTlQxNl9TSVpFLCBuICogSU5UMTZfU0laRSk7XG4gICAgICAgICAgdG1wQnVmZmVyLnNldChjcCwgdG1wT2Zmc2V0Mik7XG4gICAgICAgICAgdG1wT2Zmc2V0MiArPSBuICogSU5UMTZfU0laRTtcbiAgICAgICAgICBjZC5lbmQgKz0gbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyh0bXBCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1BYUihpbmZvKSB7XG4gICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8uYXJyYXkuc2xpY2UoaW5mby5vZmZzZXQudmFsdWUsIGluZm8ub2Zmc2V0LnZhbHVlICsgaW5mby5zaXplKTtcbiAgICAgIHZhciByYXdCdWZmZXIgPSB1bnpsaWJTeW5jKGNvbXByZXNzZWQpO1xuICAgICAgY29uc3Qgc3ogPSBpbmZvLmxpbmVzICogaW5mby5jaGFubmVscyAqIGluZm8ud2lkdGg7XG4gICAgICBjb25zdCB0bXBCdWZmZXIgPSBpbmZvLnR5cGUgPT0gMSA/IG5ldyBVaW50MTZBcnJheShzeikgOiBuZXcgVWludDMyQXJyYXkoc3opO1xuICAgICAgbGV0IHRtcEJ1ZmZlckVuZCA9IDA7XG4gICAgICBsZXQgd3JpdGVQdHIgPSAwO1xuICAgICAgY29uc3QgcHRyID0gbmV3IEFycmF5KDQpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBpbmZvLmxpbmVzOyB5KyspIHtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBpbmZvLmNoYW5uZWxzOyBjKyspIHtcbiAgICAgICAgICBsZXQgcGl4ZWwgPSAwO1xuICAgICAgICAgIHN3aXRjaCAoaW5mby50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHB0clswXSA9IHRtcEJ1ZmZlckVuZDtcbiAgICAgICAgICAgICAgcHRyWzFdID0gcHRyWzBdICsgaW5mby53aWR0aDtcbiAgICAgICAgICAgICAgdG1wQnVmZmVyRW5kID0gcHRyWzFdICsgaW5mby53aWR0aDtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmZvLndpZHRoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gcmF3QnVmZmVyW3B0clswXSsrXSA8PCA4IHwgcmF3QnVmZmVyW3B0clsxXSsrXTtcbiAgICAgICAgICAgICAgICBwaXhlbCArPSBkaWZmO1xuICAgICAgICAgICAgICAgIHRtcEJ1ZmZlclt3cml0ZVB0cl0gPSBwaXhlbDtcbiAgICAgICAgICAgICAgICB3cml0ZVB0cisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBwdHJbMF0gPSB0bXBCdWZmZXJFbmQ7XG4gICAgICAgICAgICAgIHB0clsxXSA9IHB0clswXSArIGluZm8ud2lkdGg7XG4gICAgICAgICAgICAgIHB0clsyXSA9IHB0clsxXSArIGluZm8ud2lkdGg7XG4gICAgICAgICAgICAgIHRtcEJ1ZmZlckVuZCA9IHB0clsyXSArIGluZm8ud2lkdGg7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5mby53aWR0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZiA9IHJhd0J1ZmZlcltwdHJbMF0rK10gPDwgMjQgfCByYXdCdWZmZXJbcHRyWzFdKytdIDw8IDE2IHwgcmF3QnVmZmVyW3B0clsyXSsrXSA8PCA4O1xuICAgICAgICAgICAgICAgIHBpeGVsICs9IGRpZmY7XG4gICAgICAgICAgICAgICAgdG1wQnVmZmVyW3dyaXRlUHRyXSA9IHBpeGVsO1xuICAgICAgICAgICAgICAgIHdyaXRlUHRyKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KHRtcEJ1ZmZlci5idWZmZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmNvbXByZXNzRFdBKGluZm8pIHtcbiAgICAgIHZhciBpbkRhdGFWaWV3ID0gaW5mby52aWV3ZXI7XG4gICAgICB2YXIgaW5PZmZzZXQgPSB7IHZhbHVlOiBpbmZvLm9mZnNldC52YWx1ZSB9O1xuICAgICAgdmFyIG91dEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGluZm8ud2lkdGggKiBpbmZvLmxpbmVzICogKGluZm8uY2hhbm5lbHMgKiBpbmZvLnR5cGUgKiBJTlQxNl9TSVpFKSk7XG4gICAgICB2YXIgZHdhSGVhZGVyID0ge1xuICAgICAgICB2ZXJzaW9uOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgdW5rbm93blVuY29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICB1bmtub3duQ29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBhY0NvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgZGNDb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHJsZUNvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgcmxlVW5jb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHJsZVJhd1NpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICB0b3RhbEFjVW5jb21wcmVzc2VkQ291bnQ6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICB0b3RhbERjVW5jb21wcmVzc2VkQ291bnQ6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBhY0NvbXByZXNzaW9uOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KVxuICAgICAgfTtcbiAgICAgIGlmIChkd2FIZWFkZXIudmVyc2lvbiA8IDIpIHtcbiAgICAgICAgdGhyb3cgXCJFWFJMb2FkZXIucGFyc2U6IFwiICsgRVhSSGVhZGVyLmNvbXByZXNzaW9uICsgXCIgdmVyc2lvbiBcIiArIGR3YUhlYWRlci52ZXJzaW9uICsgXCIgaXMgdW5zdXBwb3J0ZWRcIjtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFubmVsUnVsZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgIHZhciBydWxlU2l6ZSA9IHBhcnNlVWludDE2KGluRGF0YVZpZXcsIGluT2Zmc2V0KSAtIElOVDE2X1NJWkU7XG4gICAgICB3aGlsZSAocnVsZVNpemUgPiAwKSB7XG4gICAgICAgIHZhciBuYW1lID0gcGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyhpbkRhdGFWaWV3LmJ1ZmZlciwgaW5PZmZzZXQpO1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZVVpbnQ4KGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gdmFsdWUgPj4gMiAmIDM7XG4gICAgICAgIHZhciBjc2MgPSAodmFsdWUgPj4gNCkgLSAxO1xuICAgICAgICB2YXIgaW5kZXggPSBuZXcgSW50OEFycmF5KFtjc2NdKVswXTtcbiAgICAgICAgdmFyIHR5cGUgPSBwYXJzZVVpbnQ4KGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgICAgY2hhbm5lbFJ1bGVzLnB1c2goe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBjb21wcmVzc2lvblxuICAgICAgICB9KTtcbiAgICAgICAgcnVsZVNpemUgLT0gbmFtZS5sZW5ndGggKyAzO1xuICAgICAgfVxuICAgICAgdmFyIGNoYW5uZWxzID0gRVhSSGVhZGVyLmNoYW5uZWxzO1xuICAgICAgdmFyIGNoYW5uZWxEYXRhID0gbmV3IEFycmF5KGluZm8uY2hhbm5lbHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmZvLmNoYW5uZWxzOyArK2kpIHtcbiAgICAgICAgdmFyIGNkID0gY2hhbm5lbERhdGFbaV0gPSB7fTtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBjaGFubmVsc1tpXTtcbiAgICAgICAgY2QubmFtZSA9IGNoYW5uZWwubmFtZTtcbiAgICAgICAgY2QuY29tcHJlc3Npb24gPSBVTktOT1dOO1xuICAgICAgICBjZC5kZWNvZGVkID0gZmFsc2U7XG4gICAgICAgIGNkLnR5cGUgPSBjaGFubmVsLnBpeGVsVHlwZTtcbiAgICAgICAgY2QucExpbmVhciA9IGNoYW5uZWwucExpbmVhcjtcbiAgICAgICAgY2Qud2lkdGggPSBpbmZvLndpZHRoO1xuICAgICAgICBjZC5oZWlnaHQgPSBpbmZvLmxpbmVzO1xuICAgICAgfVxuICAgICAgdmFyIGNzY1NldCA9IHtcbiAgICAgICAgaWR4OiBuZXcgQXJyYXkoMylcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBvZmZzZXQyID0gMDsgb2Zmc2V0MiA8IGluZm8uY2hhbm5lbHM7ICsrb2Zmc2V0Mikge1xuICAgICAgICB2YXIgY2QgPSBjaGFubmVsRGF0YVtvZmZzZXQyXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFubmVsUnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgcnVsZSA9IGNoYW5uZWxSdWxlc1tpXTtcbiAgICAgICAgICBpZiAoY2QubmFtZSA9PSBydWxlLm5hbWUpIHtcbiAgICAgICAgICAgIGNkLmNvbXByZXNzaW9uID0gcnVsZS5jb21wcmVzc2lvbjtcbiAgICAgICAgICAgIGlmIChydWxlLmluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgY3NjU2V0LmlkeFtydWxlLmluZGV4XSA9IG9mZnNldDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZC5vZmZzZXQgPSBvZmZzZXQyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGR3YUhlYWRlci5hY0NvbXByZXNzZWRTaXplID4gMCkge1xuICAgICAgICBzd2l0Y2ggKGR3YUhlYWRlci5hY0NvbXByZXNzaW9uKSB7XG4gICAgICAgICAgY2FzZSBTVEFUSUNfSFVGRk1BTjpcbiAgICAgICAgICAgIHZhciBhY0J1ZmZlciA9IG5ldyBVaW50MTZBcnJheShkd2FIZWFkZXIudG90YWxBY1VuY29tcHJlc3NlZENvdW50KTtcbiAgICAgICAgICAgIGh1ZlVuY29tcHJlc3MoXG4gICAgICAgICAgICAgIGluZm8uYXJyYXksXG4gICAgICAgICAgICAgIGluRGF0YVZpZXcsXG4gICAgICAgICAgICAgIGluT2Zmc2V0LFxuICAgICAgICAgICAgICBkd2FIZWFkZXIuYWNDb21wcmVzc2VkU2l6ZSxcbiAgICAgICAgICAgICAgYWNCdWZmZXIsXG4gICAgICAgICAgICAgIGR3YUhlYWRlci50b3RhbEFjVW5jb21wcmVzc2VkQ291bnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIERFRkxBVEU6XG4gICAgICAgICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8uYXJyYXkuc2xpY2UoaW5PZmZzZXQudmFsdWUsIGluT2Zmc2V0LnZhbHVlICsgZHdhSGVhZGVyLnRvdGFsQWNVbmNvbXByZXNzZWRDb3VudCk7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHVuemxpYlN5bmMoY29tcHJlc3NlZCk7XG4gICAgICAgICAgICB2YXIgYWNCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoZGF0YS5idWZmZXIpO1xuICAgICAgICAgICAgaW5PZmZzZXQudmFsdWUgKz0gZHdhSGVhZGVyLnRvdGFsQWNVbmNvbXByZXNzZWRDb3VudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZHdhSGVhZGVyLmRjQ29tcHJlc3NlZFNpemUgPiAwKSB7XG4gICAgICAgIHZhciB6bGliSW5mbyA9IHtcbiAgICAgICAgICBhcnJheTogaW5mby5hcnJheSxcbiAgICAgICAgICBvZmZzZXQ6IGluT2Zmc2V0LFxuICAgICAgICAgIHNpemU6IGR3YUhlYWRlci5kY0NvbXByZXNzZWRTaXplXG4gICAgICAgIH07XG4gICAgICAgIHZhciBkY0J1ZmZlciA9IG5ldyBVaW50MTZBcnJheSh1bmNvbXByZXNzWklQKHpsaWJJbmZvKS5idWZmZXIpO1xuICAgICAgICBpbk9mZnNldC52YWx1ZSArPSBkd2FIZWFkZXIuZGNDb21wcmVzc2VkU2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkd2FIZWFkZXIucmxlUmF3U2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIGNvbXByZXNzZWQgPSBpbmZvLmFycmF5LnNsaWNlKGluT2Zmc2V0LnZhbHVlLCBpbk9mZnNldC52YWx1ZSArIGR3YUhlYWRlci5ybGVDb21wcmVzc2VkU2l6ZSk7XG4gICAgICAgIHZhciBkYXRhID0gdW56bGliU3luYyhjb21wcmVzc2VkKTtcbiAgICAgICAgdmFyIHJsZUJ1ZmZlciA9IGRlY29kZVJ1bkxlbmd0aChkYXRhLmJ1ZmZlcik7XG4gICAgICAgIGluT2Zmc2V0LnZhbHVlICs9IGR3YUhlYWRlci5ybGVDb21wcmVzc2VkU2l6ZTtcbiAgICAgIH1cbiAgICAgIHZhciBvdXRCdWZmZXJFbmQgPSAwO1xuICAgICAgdmFyIHJvd09mZnNldHMgPSBuZXcgQXJyYXkoY2hhbm5lbERhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93T2Zmc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICByb3dPZmZzZXRzW2ldID0gbmV3IEFycmF5KCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGluZm8ubGluZXM7ICsreSkge1xuICAgICAgICBmb3IgKHZhciBjaGFuID0gMDsgY2hhbiA8IGNoYW5uZWxEYXRhLmxlbmd0aDsgKytjaGFuKSB7XG4gICAgICAgICAgcm93T2Zmc2V0c1tjaGFuXS5wdXNoKG91dEJ1ZmZlckVuZCk7XG4gICAgICAgICAgb3V0QnVmZmVyRW5kICs9IGNoYW5uZWxEYXRhW2NoYW5dLndpZHRoICogaW5mby50eXBlICogSU5UMTZfU0laRTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9zc3lEY3REZWNvZGUoY3NjU2V0LCByb3dPZmZzZXRzLCBjaGFubmVsRGF0YSwgYWNCdWZmZXIsIGRjQnVmZmVyLCBvdXRCdWZmZXIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFubmVsRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY2QgPSBjaGFubmVsRGF0YVtpXTtcbiAgICAgICAgaWYgKGNkLmRlY29kZWQpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHN3aXRjaCAoY2QuY29tcHJlc3Npb24pIHtcbiAgICAgICAgICBjYXNlIFJMRTpcbiAgICAgICAgICAgIHZhciByb3cgPSAwO1xuICAgICAgICAgICAgdmFyIHJsZU9mZnNldCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGluZm8ubGluZXM7ICsreSkge1xuICAgICAgICAgICAgICB2YXIgcm93T2Zmc2V0Qnl0ZXMgPSByb3dPZmZzZXRzW2ldW3Jvd107XG4gICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgY2Qud2lkdGg7ICsreCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGJ5dGUgPSAwOyBieXRlIDwgSU5UMTZfU0laRSAqIGNkLnR5cGU7ICsrYnl0ZSkge1xuICAgICAgICAgICAgICAgICAgb3V0QnVmZmVyW3Jvd09mZnNldEJ5dGVzKytdID0gcmxlQnVmZmVyW3JsZU9mZnNldCArIGJ5dGUgKiBjZC53aWR0aCAqIGNkLmhlaWdodF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJsZU9mZnNldCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBMT1NTWV9EQ1Q6XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFwiRVhSTG9hZGVyLnBhcnNlOiB1bnN1cHBvcnRlZCBjaGFubmVsIGNvbXByZXNzaW9uXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcob3V0QnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Mikge1xuICAgICAgdmFyIHVpbnRCdWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIyKTtcbiAgICAgIHZhciBlbmRPZmZzZXQgPSAwO1xuICAgICAgd2hpbGUgKHVpbnRCdWZmZXJbb2Zmc2V0Mi52YWx1ZSArIGVuZE9mZnNldF0gIT0gMCkge1xuICAgICAgICBlbmRPZmZzZXQgKz0gMTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh1aW50QnVmZmVyLnNsaWNlKG9mZnNldDIudmFsdWUsIG9mZnNldDIudmFsdWUgKyBlbmRPZmZzZXQpKTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgZW5kT2Zmc2V0ICsgMTtcbiAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VGaXhlZExlbmd0aFN0cmluZyhidWZmZXIyLCBvZmZzZXQyLCBzaXplKSB7XG4gICAgICB2YXIgc3RyaW5nVmFsdWUgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyMikuc2xpY2Uob2Zmc2V0Mi52YWx1ZSwgb2Zmc2V0Mi52YWx1ZSArIHNpemUpKTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgc2l6ZTtcbiAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VSYXRpb25hbChkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHggPSBwYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5ID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VUaW1lY29kZShkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHggPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeSA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBJbnQzMiA9IGRhdGFWaWV3LmdldEludDMyKG9mZnNldDIudmFsdWUsIHRydWUpO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSA9IG9mZnNldDIudmFsdWUgKyBJTlQzMl9TSVpFO1xuICAgICAgcmV0dXJuIEludDMyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIFVpbnQzMiA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQyLnZhbHVlLCB0cnVlKTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgSU5UMzJfU0laRTtcbiAgICAgIHJldHVybiBVaW50MzI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVWludDhBcnJheSh1SW50OEFycmF5Miwgb2Zmc2V0Mikge1xuICAgICAgdmFyIFVpbnQ4ID0gdUludDhBcnJheTJbb2Zmc2V0Mi52YWx1ZV07XG4gICAgICBvZmZzZXQyLnZhbHVlID0gb2Zmc2V0Mi52YWx1ZSArIElOVDhfU0laRTtcbiAgICAgIHJldHVybiBVaW50ODtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIFVpbnQ4ID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0Mi52YWx1ZSk7XG4gICAgICBvZmZzZXQyLnZhbHVlID0gb2Zmc2V0Mi52YWx1ZSArIElOVDhfU0laRTtcbiAgICAgIHJldHVybiBVaW50ODtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VJbnQ2NCA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICBsZXQgaW50O1xuICAgICAgaWYgKFwiZ2V0QmlnSW50NjRcIiBpbiBEYXRhVmlldy5wcm90b3R5cGUpIHtcbiAgICAgICAgaW50ID0gTnVtYmVyKGRhdGFWaWV3LmdldEJpZ0ludDY0KG9mZnNldDIudmFsdWUsIHRydWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludCA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQyLnZhbHVlICsgNCwgdHJ1ZSkgKyBOdW1iZXIoZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldDIudmFsdWUsIHRydWUpIDw8IDMyKTtcbiAgICAgIH1cbiAgICAgIG9mZnNldDIudmFsdWUgKz0gVUxPTkdfU0laRTtcbiAgICAgIHJldHVybiBpbnQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBmbG9hdCA9IGRhdGFWaWV3LmdldEZsb2F0MzIob2Zmc2V0Mi52YWx1ZSwgdHJ1ZSk7XG4gICAgICBvZmZzZXQyLnZhbHVlICs9IEZMT0FUMzJfU0laRTtcbiAgICAgIHJldHVybiBmbG9hdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgcmV0dXJuIERhdGFVdGlscy50b0hhbGZGbG9hdChwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlRmxvYXQxNihiaW5hcnkpIHtcbiAgICAgIHZhciBleHBvbmVudCA9IChiaW5hcnkgJiAzMTc0NCkgPj4gMTAsIGZyYWN0aW9uID0gYmluYXJ5ICYgMTAyMztcbiAgICAgIHJldHVybiAoYmluYXJ5ID4+IDE1ID8gLTEgOiAxKSAqIChleHBvbmVudCA/IGV4cG9uZW50ID09PSAzMSA/IGZyYWN0aW9uID8gTmFOIDogSW5maW5pdHkgOiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDE1KSAqICgxICsgZnJhY3Rpb24gLyAxMDI0KSA6IDYxMDM1MTU2MjVlLTE0ICogKGZyYWN0aW9uIC8gMTAyNCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVVpbnQxNihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIFVpbnQxNiA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQyLnZhbHVlLCB0cnVlKTtcbiAgICAgIG9mZnNldDIudmFsdWUgKz0gSU5UMTZfU0laRTtcbiAgICAgIHJldHVybiBVaW50MTY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlRmxvYXQxNihidWZmZXIyLCBvZmZzZXQyKSB7XG4gICAgICByZXR1cm4gZGVjb2RlRmxvYXQxNihwYXJzZVVpbnQxNihidWZmZXIyLCBvZmZzZXQyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQ2hsaXN0KGRhdGFWaWV3LCBidWZmZXIyLCBvZmZzZXQyLCBzaXplKSB7XG4gICAgICB2YXIgc3RhcnRPZmZzZXQgPSBvZmZzZXQyLnZhbHVlO1xuICAgICAgdmFyIGNoYW5uZWxzID0gW107XG4gICAgICB3aGlsZSAob2Zmc2V0Mi52YWx1ZSA8IHN0YXJ0T2Zmc2V0ICsgc2l6ZSAtIDEpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGJ1ZmZlcjIsIG9mZnNldDIpO1xuICAgICAgICB2YXIgcGl4ZWxUeXBlID0gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgIHZhciBwTGluZWFyID0gcGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgIG9mZnNldDIudmFsdWUgKz0gMztcbiAgICAgICAgdmFyIHhTYW1wbGluZyA9IHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgICB2YXIgeVNhbXBsaW5nID0gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgIGNoYW5uZWxzLnB1c2goe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgcGl4ZWxUeXBlLFxuICAgICAgICAgIHBMaW5lYXIsXG4gICAgICAgICAgeFNhbXBsaW5nLFxuICAgICAgICAgIHlTYW1wbGluZ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG9mZnNldDIudmFsdWUgKz0gMTtcbiAgICAgIHJldHVybiBjaGFubmVscztcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VDaHJvbWF0aWNpdGllcyhkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHJlZFggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHJlZFkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIGdyZWVuWCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgZ3JlZW5ZID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciBibHVlWCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgYmx1ZVkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHdoaXRlWCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgd2hpdGVZID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZFgsXG4gICAgICAgIHJlZFksXG4gICAgICAgIGdyZWVuWCxcbiAgICAgICAgZ3JlZW5ZLFxuICAgICAgICBibHVlWCxcbiAgICAgICAgYmx1ZVksXG4gICAgICAgIHdoaXRlWCxcbiAgICAgICAgd2hpdGVZXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUNvbXByZXNzaW9uKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgY29tcHJlc3Npb25Db2RlcyA9IFtcbiAgICAgICAgXCJOT19DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIlJMRV9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIlpJUFNfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJaSVBfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJQSVpfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJQWFIyNF9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIkI0NF9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIkI0NEFfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJEV0FBX0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiRFdBQl9DT01QUkVTU0lPTlwiXG4gICAgICBdO1xuICAgICAgdmFyIGNvbXByZXNzaW9uID0gcGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4gY29tcHJlc3Npb25Db2Rlc1tjb21wcmVzc2lvbl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQm94MmkoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciB4TWluID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHlNaW4gPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeE1heCA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5TWF4ID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIHsgeE1pbiwgeU1pbiwgeE1heCwgeU1heCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUxpbmVPcmRlcihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIGxpbmVPcmRlcnMgPSBbXCJJTkNSRUFTSU5HX1lcIl07XG4gICAgICB2YXIgbGluZU9yZGVyID0gcGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4gbGluZU9yZGVyc1tsaW5lT3JkZXJdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVYyZihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VWM2YoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciB4ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB6ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiBbeCwgeSwgel07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVmFsdWUoZGF0YVZpZXcsIGJ1ZmZlcjIsIG9mZnNldDIsIHR5cGUsIHNpemUpIHtcbiAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwic3RyaW5ndmVjdG9yXCIgfHwgdHlwZSA9PT0gXCJpY2NQcm9maWxlXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRml4ZWRMZW5ndGhTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Miwgc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY2hsaXN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQ2hsaXN0KGRhdGFWaWV3LCBidWZmZXIyLCBvZmZzZXQyLCBzaXplKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjaHJvbWF0aWNpdGllc1wiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUNocm9tYXRpY2l0aWVzKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb21wcmVzc2lvblwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUNvbXByZXNzaW9uKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJib3gyaVwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUJveDJpKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJsaW5lT3JkZXJcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VMaW5lT3JkZXIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImZsb2F0XCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidjJmXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVjJmKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ2M2ZcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VWM2YoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImludFwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyYXRpb25hbFwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVJhdGlvbmFsKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ0aW1lY29kZVwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVRpbWVjb2RlKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJwcmV2aWV3XCIpIHtcbiAgICAgICAgb2Zmc2V0Mi52YWx1ZSArPSBzaXplO1xuICAgICAgICByZXR1cm4gXCJza2lwcGVkXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQyLnZhbHVlICs9IHNpemU7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKGRhdGFWaWV3LCBidWZmZXIyLCBvZmZzZXQyKSB7XG4gICAgICBjb25zdCBFWFJIZWFkZXIyID0ge307XG4gICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDMyKDAsIHRydWUpICE9IDIwMDAwNjMwKSB7XG4gICAgICAgIHRocm93IFwiVEhSRUUuRVhSTG9hZGVyOiBwcm92aWRlZCBmaWxlIGRvZXNuJ3QgYXBwZWFyIHRvIGJlIGluIE9wZW5FWFIgZm9ybWF0LlwiO1xuICAgICAgfVxuICAgICAgRVhSSGVhZGVyMi52ZXJzaW9uID0gZGF0YVZpZXcuZ2V0VWludDgoNCk7XG4gICAgICBjb25zdCBzcGVjID0gZGF0YVZpZXcuZ2V0VWludDgoNSk7XG4gICAgICBFWFJIZWFkZXIyLnNwZWMgPSB7XG4gICAgICAgIHNpbmdsZVRpbGU6ICEhKHNwZWMgJiAyKSxcbiAgICAgICAgbG9uZ05hbWU6ICEhKHNwZWMgJiA0KSxcbiAgICAgICAgZGVlcEZvcm1hdDogISEoc3BlYyAmIDgpLFxuICAgICAgICBtdWx0aVBhcnQ6ICEhKHNwZWMgJiAxNilcbiAgICAgIH07XG4gICAgICBvZmZzZXQyLnZhbHVlID0gODtcbiAgICAgIHZhciBrZWVwUmVhZGluZyA9IHRydWU7XG4gICAgICB3aGlsZSAoa2VlcFJlYWRpbmcpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGJ1ZmZlcjIsIG9mZnNldDIpO1xuICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PSAwKSB7XG4gICAgICAgICAga2VlcFJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlVHlwZSA9IHBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Mik7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZVNpemUgPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZVZhbHVlID0gcGFyc2VWYWx1ZShkYXRhVmlldywgYnVmZmVyMiwgb2Zmc2V0MiwgYXR0cmlidXRlVHlwZSwgYXR0cmlidXRlU2l6ZSk7XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRVhSTG9hZGVyLnBhcnNlOiBza2lwcGVkIHVua25vd24gaGVhZGVyIGF0dHJpYnV0ZSB0eXBlICcke2F0dHJpYnV0ZVR5cGV9Jy5gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRVhSSGVhZGVyMlthdHRyaWJ1dGVOYW1lXSA9IGF0dHJpYnV0ZVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKChzcGVjICYgfjQpICE9IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVYUkhlYWRlcjpcIiwgRVhSSGVhZGVyMik7XG4gICAgICAgIHRocm93IFwiVEhSRUUuRVhSTG9hZGVyOiBwcm92aWRlZCBmaWxlIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC5cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBFWFJIZWFkZXIyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXR1cERlY29kZXIoRVhSSGVhZGVyMiwgZGF0YVZpZXcsIHVJbnQ4QXJyYXkyLCBvZmZzZXQyLCBvdXRwdXRUeXBlKSB7XG4gICAgICBjb25zdCBFWFJEZWNvZGVyMiA9IHtcbiAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgdmlld2VyOiBkYXRhVmlldyxcbiAgICAgICAgYXJyYXk6IHVJbnQ4QXJyYXkyLFxuICAgICAgICBvZmZzZXQ6IG9mZnNldDIsXG4gICAgICAgIHdpZHRoOiBFWFJIZWFkZXIyLmRhdGFXaW5kb3cueE1heCAtIEVYUkhlYWRlcjIuZGF0YVdpbmRvdy54TWluICsgMSxcbiAgICAgICAgaGVpZ2h0OiBFWFJIZWFkZXIyLmRhdGFXaW5kb3cueU1heCAtIEVYUkhlYWRlcjIuZGF0YVdpbmRvdy55TWluICsgMSxcbiAgICAgICAgY2hhbm5lbHM6IEVYUkhlYWRlcjIuY2hhbm5lbHMubGVuZ3RoLFxuICAgICAgICBieXRlc1BlckxpbmU6IG51bGwsXG4gICAgICAgIGxpbmVzOiBudWxsLFxuICAgICAgICBpbnB1dFNpemU6IG51bGwsXG4gICAgICAgIHR5cGU6IEVYUkhlYWRlcjIuY2hhbm5lbHNbMF0ucGl4ZWxUeXBlLFxuICAgICAgICB1bmNvbXByZXNzOiBudWxsLFxuICAgICAgICBnZXR0ZXI6IG51bGwsXG4gICAgICAgIGZvcm1hdDogbnVsbCxcbiAgICAgICAgW2hhc0NvbG9yU3BhY2UgPyBcImNvbG9yU3BhY2VcIiA6IFwiZW5jb2RpbmdcIl06IG51bGxcbiAgICAgIH07XG4gICAgICBzd2l0Y2ggKEVYUkhlYWRlcjIuY29tcHJlc3Npb24pIHtcbiAgICAgICAgY2FzZSBcIk5PX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAxO1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUkFXO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUkxFX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAxO1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUkxFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiWklQU19DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMTtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc1pJUDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlpJUF9DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMTY7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NaSVA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQSVpfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDMyO1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUElaO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUFhSMjRfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDE2O1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUFhSO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRFdBQV9DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMzI7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NEV0E7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJEV0FCX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAyNTY7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NEV0E7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgXCJFWFJMb2FkZXIucGFyc2U6IFwiICsgRVhSSGVhZGVyMi5jb21wcmVzc2lvbiArIFwiIGlzIHVuc3VwcG9ydGVkXCI7XG4gICAgICB9XG4gICAgICBFWFJEZWNvZGVyMi5zY2FubGluZUJsb2NrU2l6ZSA9IEVYUkRlY29kZXIyLmxpbmVzO1xuICAgICAgaWYgKEVYUkRlY29kZXIyLnR5cGUgPT0gMSkge1xuICAgICAgICBzd2l0Y2ggKG91dHB1dFR5cGUpIHtcbiAgICAgICAgICBjYXNlIEZsb2F0VHlwZTpcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmdldHRlciA9IHBhcnNlRmxvYXQxNjtcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmlucHV0U2l6ZSA9IElOVDE2X1NJWkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5nZXR0ZXIgPSBwYXJzZVVpbnQxNjtcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmlucHV0U2l6ZSA9IElOVDE2X1NJWkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChFWFJEZWNvZGVyMi50eXBlID09IDIpIHtcbiAgICAgICAgc3dpdGNoIChvdXRwdXRUeXBlKSB7XG4gICAgICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5nZXR0ZXIgPSBwYXJzZUZsb2F0MzI7XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5pbnB1dFNpemUgPSBGTE9BVDMyX1NJWkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5nZXR0ZXIgPSBkZWNvZGVGbG9hdDMyO1xuICAgICAgICAgICAgRVhSRGVjb2RlcjIuaW5wdXRTaXplID0gRkxPQVQzMl9TSVpFO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBcIkVYUkxvYWRlci5wYXJzZTogdW5zdXBwb3J0ZWQgcGl4ZWxUeXBlIFwiICsgRVhSRGVjb2RlcjIudHlwZSArIFwiIGZvciBcIiArIEVYUkhlYWRlcjIuY29tcHJlc3Npb24gKyBcIi5cIjtcbiAgICAgIH1cbiAgICAgIEVYUkRlY29kZXIyLmJsb2NrQ291bnQgPSAoRVhSSGVhZGVyMi5kYXRhV2luZG93LnlNYXggKyAxKSAvIEVYUkRlY29kZXIyLnNjYW5saW5lQmxvY2tTaXplO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBFWFJEZWNvZGVyMi5ibG9ja0NvdW50OyBpKyspXG4gICAgICAgIHBhcnNlSW50NjQoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgRVhSRGVjb2RlcjIub3V0cHV0Q2hhbm5lbHMgPSBFWFJEZWNvZGVyMi5jaGFubmVscyA9PSAzID8gNCA6IEVYUkRlY29kZXIyLmNoYW5uZWxzO1xuICAgICAgY29uc3Qgc2l6ZSA9IEVYUkRlY29kZXIyLndpZHRoICogRVhSRGVjb2RlcjIuaGVpZ2h0ICogRVhSRGVjb2RlcjIub3V0cHV0Q2hhbm5lbHM7XG4gICAgICBzd2l0Y2ggKG91dHB1dFR5cGUpIHtcbiAgICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgICAgRVhSRGVjb2RlcjIuYnl0ZUFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICAgICAgICBpZiAoRVhSRGVjb2RlcjIuY2hhbm5lbHMgPCBFWFJEZWNvZGVyMi5vdXRwdXRDaGFubmVscylcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmJ5dGVBcnJheS5maWxsKDEsIDAsIHNpemUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgRVhSRGVjb2RlcjIuYnl0ZUFycmF5ID0gbmV3IFVpbnQxNkFycmF5KHNpemUpO1xuICAgICAgICAgIGlmIChFWFJEZWNvZGVyMi5jaGFubmVscyA8IEVYUkRlY29kZXIyLm91dHB1dENoYW5uZWxzKVxuICAgICAgICAgICAgRVhSRGVjb2RlcjIuYnl0ZUFycmF5LmZpbGwoMTUzNjAsIDAsIHNpemUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5FWFJMb2FkZXI6IHVuc3VwcG9ydGVkIHR5cGU6IFwiLCBvdXRwdXRUeXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIEVYUkRlY29kZXIyLmJ5dGVzUGVyTGluZSA9IEVYUkRlY29kZXIyLndpZHRoICogRVhSRGVjb2RlcjIuaW5wdXRTaXplICogRVhSRGVjb2RlcjIuY2hhbm5lbHM7XG4gICAgICBpZiAoRVhSRGVjb2RlcjIub3V0cHV0Q2hhbm5lbHMgPT0gNClcbiAgICAgICAgRVhSRGVjb2RlcjIuZm9ybWF0ID0gUkdCQUZvcm1hdDtcbiAgICAgIGVsc2VcbiAgICAgICAgRVhSRGVjb2RlcjIuZm9ybWF0ID0gUmVkRm9ybWF0O1xuICAgICAgaWYgKGhhc0NvbG9yU3BhY2UpXG4gICAgICAgIEVYUkRlY29kZXIyLmNvbG9yU3BhY2UgPSBcInNyZ2ItbGluZWFyXCI7XG4gICAgICBlbHNlXG4gICAgICAgIEVYUkRlY29kZXIyLmVuY29kaW5nID0gM2UzO1xuICAgICAgcmV0dXJuIEVYUkRlY29kZXIyO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJEYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGNvbnN0IHVJbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGNvbnN0IG9mZnNldCA9IHsgdmFsdWU6IDAgfTtcbiAgICBjb25zdCBFWFJIZWFkZXIgPSBwYXJzZUhlYWRlcihidWZmZXJEYXRhVmlldywgYnVmZmVyLCBvZmZzZXQpO1xuICAgIGNvbnN0IEVYUkRlY29kZXIgPSBzZXR1cERlY29kZXIoRVhSSGVhZGVyLCBidWZmZXJEYXRhVmlldywgdUludDhBcnJheSwgb2Zmc2V0LCB0aGlzLnR5cGUpO1xuICAgIGNvbnN0IHRtcE9mZnNldCA9IHsgdmFsdWU6IDAgfTtcbiAgICBjb25zdCBjaGFubmVsT2Zmc2V0cyA9IHsgUjogMCwgRzogMSwgQjogMiwgQTogMywgWTogMCB9O1xuICAgIGZvciAobGV0IHNjYW5saW5lQmxvY2tJZHggPSAwOyBzY2FubGluZUJsb2NrSWR4IDwgRVhSRGVjb2Rlci5oZWlnaHQgLyBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplOyBzY2FubGluZUJsb2NrSWR4KyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBwYXJzZVVpbnQzMihidWZmZXJEYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgIEVYUkRlY29kZXIuc2l6ZSA9IHBhcnNlVWludDMyKGJ1ZmZlckRhdGFWaWV3LCBvZmZzZXQpO1xuICAgICAgRVhSRGVjb2Rlci5saW5lcyA9IGxpbmUgKyBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplID4gRVhSRGVjb2Rlci5oZWlnaHQgPyBFWFJEZWNvZGVyLmhlaWdodCAtIGxpbmUgOiBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplO1xuICAgICAgY29uc3QgaXNDb21wcmVzc2VkID0gRVhSRGVjb2Rlci5zaXplIDwgRVhSRGVjb2Rlci5saW5lcyAqIEVYUkRlY29kZXIuYnl0ZXNQZXJMaW5lO1xuICAgICAgY29uc3Qgdmlld2VyID0gaXNDb21wcmVzc2VkID8gRVhSRGVjb2Rlci51bmNvbXByZXNzKEVYUkRlY29kZXIpIDogdW5jb21wcmVzc1JBVyhFWFJEZWNvZGVyKTtcbiAgICAgIG9mZnNldC52YWx1ZSArPSBFWFJEZWNvZGVyLnNpemU7XG4gICAgICBmb3IgKGxldCBsaW5lX3kgPSAwOyBsaW5lX3kgPCBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplOyBsaW5lX3krKykge1xuICAgICAgICBjb25zdCB0cnVlX3kgPSBsaW5lX3kgKyBzY2FubGluZUJsb2NrSWR4ICogRVhSRGVjb2Rlci5zY2FubGluZUJsb2NrU2l6ZTtcbiAgICAgICAgaWYgKHRydWVfeSA+PSBFWFJEZWNvZGVyLmhlaWdodClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZm9yIChsZXQgY2hhbm5lbElEID0gMDsgY2hhbm5lbElEIDwgRVhSRGVjb2Rlci5jaGFubmVsczsgY2hhbm5lbElEKyspIHtcbiAgICAgICAgICBjb25zdCBjT2ZmID0gY2hhbm5lbE9mZnNldHNbRVhSSGVhZGVyLmNoYW5uZWxzW2NoYW5uZWxJRF0ubmFtZV07XG4gICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBFWFJEZWNvZGVyLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIHRtcE9mZnNldC52YWx1ZSA9IChsaW5lX3kgKiAoRVhSRGVjb2Rlci5jaGFubmVscyAqIEVYUkRlY29kZXIud2lkdGgpICsgY2hhbm5lbElEICogRVhSRGVjb2Rlci53aWR0aCArIHgpICogRVhSRGVjb2Rlci5pbnB1dFNpemU7XG4gICAgICAgICAgICBjb25zdCBvdXRJbmRleCA9IChFWFJEZWNvZGVyLmhlaWdodCAtIDEgLSB0cnVlX3kpICogKEVYUkRlY29kZXIud2lkdGggKiBFWFJEZWNvZGVyLm91dHB1dENoYW5uZWxzKSArIHggKiBFWFJEZWNvZGVyLm91dHB1dENoYW5uZWxzICsgY09mZjtcbiAgICAgICAgICAgIEVYUkRlY29kZXIuYnl0ZUFycmF5W291dEluZGV4XSA9IEVYUkRlY29kZXIuZ2V0dGVyKHZpZXdlciwgdG1wT2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlYWRlcjogRVhSSGVhZGVyLFxuICAgICAgd2lkdGg6IEVYUkRlY29kZXIud2lkdGgsXG4gICAgICBoZWlnaHQ6IEVYUkRlY29kZXIuaGVpZ2h0LFxuICAgICAgZGF0YTogRVhSRGVjb2Rlci5ieXRlQXJyYXksXG4gICAgICBmb3JtYXQ6IEVYUkRlY29kZXIuZm9ybWF0LFxuICAgICAgW2hhc0NvbG9yU3BhY2UgPyBcImNvbG9yU3BhY2VcIiA6IFwiZW5jb2RpbmdcIl06IEVYUkRlY29kZXJbaGFzQ29sb3JTcGFjZSA/IFwiY29sb3JTcGFjZVwiIDogXCJlbmNvZGluZ1wiXSxcbiAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgIH07XG4gIH1cbiAgc2V0RGF0YVR5cGUodmFsdWUpIHtcbiAgICB0aGlzLnR5cGUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgZnVuY3Rpb24gb25Mb2FkQ2FsbGJhY2sodGV4dHVyZSwgdGV4RGF0YSkge1xuICAgICAgaWYgKGhhc0NvbG9yU3BhY2UpXG4gICAgICAgIHRleHR1cmUuY29sb3JTcGFjZSA9IHRleERhdGEuY29sb3JTcGFjZTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGV4dHVyZS5lbmNvZGluZyA9IHRleERhdGEuZW5jb2Rpbmc7XG4gICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcbiAgICAgIHRleHR1cmUubWFnRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICAgIHRleHR1cmUuZmxpcFkgPSBmYWxzZTtcbiAgICAgIGlmIChvbkxvYWQpXG4gICAgICAgIG9uTG9hZCh0ZXh0dXJlLCB0ZXhEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmxvYWQodXJsLCBvbkxvYWRDYWxsYmFjaywgb25Qcm9ncmVzcywgb25FcnJvcik7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEVYUkxvYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVYUkxvYWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJUZXh0dXJlIiwiRGF0YVRleHR1cmVMb2FkZXIiLCJIYWxmRmxvYXRUeXBlIiwiRmxvYXRUeXBlIiwiUkdCQUZvcm1hdCIsIlJlZEZvcm1hdCIsIkxpbmVhckZpbHRlciIsIkRhdGFVdGlscyIsInVuemxpYlN5bmMiLCJoYXNDb2xvclNwYWNlIiwiRVhSTG9hZGVyIiwiY29uc3RydWN0b3IiLCJtYW5hZ2VyIiwidHlwZSIsInBhcnNlIiwiYnVmZmVyIiwiVVNIT1JUX1JBTkdFIiwiQklUTUFQX1NJWkUiLCJIVUZfRU5DQklUUyIsIkhVRl9ERUNCSVRTIiwiSFVGX0VOQ1NJWkUiLCJIVUZfREVDU0laRSIsIkhVRl9ERUNNQVNLIiwiTkJJVFMiLCJBX09GRlNFVCIsIk1PRF9NQVNLIiwiU0hPUlRfWkVST0NPREVfUlVOIiwiTE9OR19aRVJPQ09ERV9SVU4iLCJTSE9SVEVTVF9MT05HX1JVTiIsIlVMT05HX1NJWkUiLCJGTE9BVDMyX1NJWkUiLCJJTlQzMl9TSVpFIiwiSU5UMTZfU0laRSIsIklOVDhfU0laRSIsIlNUQVRJQ19IVUZGTUFOIiwiREVGTEFURSIsIlVOS05PV04iLCJMT1NTWV9EQ1QiLCJSTEUiLCJsb2dCYXNlIiwiTWF0aCIsInBvdyIsInJldmVyc2VMdXRGcm9tQml0bWFwIiwiYml0bWFwIiwibHV0IiwiayIsImkiLCJuIiwiaHVmQ2xlYXJEZWNUYWJsZSIsImhkZWMiLCJsZW4iLCJsaXQiLCJwIiwiZ2V0Qml0c1JldHVybiIsImwiLCJjIiwibGMiLCJnZXRCaXRzIiwibkJpdHMiLCJ1SW50OEFycmF5MiIsImluT2Zmc2V0IiwicGFyc2VVaW50OEFycmF5IiwiaHVmVGFibGVCdWZmZXIiLCJBcnJheSIsImh1ZkNhbm9uaWNhbENvZGVUYWJsZSIsImhjb2RlIiwibmMiLCJodWZVbnBhY2tFbmNUYWJsZSIsImluRGF0YVZpZXciLCJuaSIsImltIiwiaU0iLCJ2YWx1ZSIsInplcnVuIiwiaHVmTGVuZ3RoIiwiY29kZSIsImh1ZkNvZGUiLCJodWZCdWlsZERlY1RhYmxlIiwiaGRlY29kIiwicGwiLCJwbE9mZnNldCIsImdldENoYXJSZXR1cm4iLCJnZXRDaGFyIiwiZ2V0Q29kZVJldHVybiIsImdldENvZGUiLCJwbyIsInJsYyIsIm91dEJ1ZmZlciIsIm91dEJ1ZmZlck9mZnNldCIsIm91dEJ1ZmZlckVuZE9mZnNldCIsImNzIiwiVWludDhBcnJheSIsInMiLCJVSW50MTYiLCJJbnQxNiIsInJlZiIsIndkZWMxNFJldHVybiIsImEiLCJiIiwid2RlYzE0IiwiaCIsImxzIiwiaHMiLCJoaSIsImFpIiwiYXMiLCJicyIsIndkZWMxNiIsIm0iLCJkIiwiYmIiLCJhYSIsIndhdjJEZWNvZGUiLCJidWZmZXIyIiwiaiIsIm54Iiwib3giLCJueSIsIm95IiwibXgiLCJ3MTQiLCJwMiIsInB5IiwiZXkiLCJveTEiLCJveTIiLCJveDEiLCJveDIiLCJpMDAiLCJpMDEiLCJpMTAiLCJpMTEiLCJweCIsImV4IiwicDAxIiwicDEwIiwicDExIiwiaHVmRGVjb2RlIiwiZW5jb2RpbmdUYWJsZSIsImRlY29kaW5nVGFibGUiLCJubyIsIm91dE9mZnNldCIsImluT2Zmc2V0RW5kIiwidHJ1bmMiLCJpbmRleCIsImh1ZlVuY29tcHJlc3MiLCJuQ29tcHJlc3NlZCIsIm5SYXciLCJpbml0aWFsSW5PZmZzZXQiLCJwYXJzZVVpbnQzMiIsImZyZXEiLCJhcHBseUx1dCIsImRhdGEiLCJuRGF0YSIsInByZWRpY3RvciIsInNvdXJjZSIsInQiLCJsZW5ndGgiLCJpbnRlcmxlYXZlU2NhbGFyIiwib3V0IiwidDEiLCJ0MiIsImZsb29yIiwic3RvcCIsImRlY29kZVJ1bkxlbmd0aCIsInNpemUiLCJieXRlTGVuZ3RoIiwicmVhZGVyIiwiRGF0YVZpZXciLCJnZXRJbnQ4IiwiY291bnQiLCJwdXNoIiwiZ2V0VWludDgiLCJsb3NzeURjdERlY29kZSIsImNzY1NldCIsInJvd1B0cnMiLCJjaGFubmVsRGF0YSIsImFjQnVmZmVyIiwiZGNCdWZmZXIiLCJkYXRhVmlldyIsIndpZHRoIiwiaWR4IiwiaGVpZ2h0IiwibnVtQ29tcCIsIm51bUZ1bGxCbG9ja3NYIiwibnVtQmxvY2tzWCIsImNlaWwiLCJudW1CbG9ja3NZIiwibGVmdG92ZXJYIiwibGVmdG92ZXJZIiwiY3VyckFjQ29tcCIsImN1cnJEY0NvbXAiLCJkY3REYXRhIiwiaGFsZlppZ0Jsb2NrIiwicm93QmxvY2siLCJyb3dPZmZzZXRzIiwiY29tcDIiLCJGbG9hdDMyQXJyYXkiLCJVaW50MTZBcnJheSIsImJsb2NreSIsIm1heFkiLCJtYXhYIiwiYmxvY2t4IiwiZmlsbCIsInVuUmxlQUMiLCJ1blppZ1phZyIsImRjdEludmVyc2UiLCJjc2M3MDlJbnZlcnNlIiwiY29udmVydFRvSGFsZiIsIm9mZnNldDIiLCJ0eXBlMiIsInkyIiwic3JjIiwic2V0VWludDE2Iiwib2Zmc2V0MyIsIngyIiwiaGFsZlJvdyIsImNvbXAiLCJkZWNvZGVkIiwieSIsIngiLCJnZXRVaW50MTYiLCJzZXRGbG9hdDMyIiwiZGVjb2RlRmxvYXQxNiIsImFjVmFsdWUiLCJkY3RDb21wIiwiZHN0IiwiY29zIiwiZSIsImYiLCJnIiwiYWxwaGEiLCJiZXRhIiwidGhldGEiLCJnYW1tYSIsInJvdyIsInJvd1B0ciIsImNvbHVtbiIsImNiIiwiY3IiLCJ0b0hhbGZGbG9hdCIsInRvTGluZWFyIiwiZmxvYXQiLCJzaWduIiwiYWJzIiwidW5jb21wcmVzc1JBVyIsImluZm8iLCJhcnJheSIsIm9mZnNldCIsInVuY29tcHJlc3NSTEUiLCJjb21wcmVzc2VkIiwidmlld2VyIiwic2xpY2UiLCJyYXdCdWZmZXIiLCJ0bXBCdWZmZXIiLCJ1bmNvbXByZXNzWklQIiwidW5jb21wcmVzc1BJWiIsInNjYW5saW5lQmxvY2tTaXplIiwiY2hhbm5lbHMiLCJvdXRCdWZmZXJFbmQiLCJwaXpDaGFubmVsRGF0YSIsImxpbmVzIiwibWluTm9uWmVybyIsInBhcnNlVWludDE2IiwibWF4Tm9uWmVybyIsInBhcnNlVWludDgiLCJtYXhWYWx1ZSIsImNkIiwic3RhcnQiLCJ0bXBPZmZzZXQyIiwiY3AiLCJlbmQiLCJzZXQiLCJ1bmNvbXByZXNzUFhSIiwic3oiLCJVaW50MzJBcnJheSIsInRtcEJ1ZmZlckVuZCIsIndyaXRlUHRyIiwicHRyIiwicGl4ZWwiLCJkaWZmIiwidW5jb21wcmVzc0RXQSIsImR3YUhlYWRlciIsInZlcnNpb24iLCJwYXJzZUludDY0IiwidW5rbm93blVuY29tcHJlc3NlZFNpemUiLCJ1bmtub3duQ29tcHJlc3NlZFNpemUiLCJhY0NvbXByZXNzZWRTaXplIiwiZGNDb21wcmVzc2VkU2l6ZSIsInJsZUNvbXByZXNzZWRTaXplIiwicmxlVW5jb21wcmVzc2VkU2l6ZSIsInJsZVJhd1NpemUiLCJ0b3RhbEFjVW5jb21wcmVzc2VkQ291bnQiLCJ0b3RhbERjVW5jb21wcmVzc2VkQ291bnQiLCJhY0NvbXByZXNzaW9uIiwiRVhSSGVhZGVyIiwiY29tcHJlc3Npb24iLCJjaGFubmVsUnVsZXMiLCJydWxlU2l6ZSIsIm5hbWUiLCJwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nIiwiY3NjIiwiSW50OEFycmF5IiwiY2hhbm5lbCIsInBpeGVsVHlwZSIsInBMaW5lYXIiLCJydWxlIiwiemxpYkluZm8iLCJybGVCdWZmZXIiLCJjaGFuIiwicmxlT2Zmc2V0Iiwicm93T2Zmc2V0Qnl0ZXMiLCJieXRlIiwidWludEJ1ZmZlciIsImVuZE9mZnNldCIsInN0cmluZ1ZhbHVlIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJwYXJzZUZpeGVkTGVuZ3RoU3RyaW5nIiwicGFyc2VSYXRpb25hbCIsInBhcnNlSW50MzIiLCJwYXJzZVRpbWVjb2RlIiwiSW50MzIiLCJnZXRJbnQzMiIsIlVpbnQzMiIsImdldFVpbnQzMiIsIlVpbnQ4IiwiaW50IiwicHJvdG90eXBlIiwiTnVtYmVyIiwiZ2V0QmlnSW50NjQiLCJwYXJzZUZsb2F0MzIiLCJnZXRGbG9hdDMyIiwiZGVjb2RlRmxvYXQzMiIsImJpbmFyeSIsImV4cG9uZW50IiwiZnJhY3Rpb24iLCJOYU4iLCJJbmZpbml0eSIsIlVpbnQxNiIsInBhcnNlRmxvYXQxNiIsInBhcnNlQ2hsaXN0Iiwic3RhcnRPZmZzZXQiLCJ4U2FtcGxpbmciLCJ5U2FtcGxpbmciLCJwYXJzZUNocm9tYXRpY2l0aWVzIiwicmVkWCIsInJlZFkiLCJncmVlblgiLCJncmVlblkiLCJibHVlWCIsImJsdWVZIiwid2hpdGVYIiwid2hpdGVZIiwicGFyc2VDb21wcmVzc2lvbiIsImNvbXByZXNzaW9uQ29kZXMiLCJwYXJzZUJveDJpIiwieE1pbiIsInlNaW4iLCJ4TWF4IiwieU1heCIsInBhcnNlTGluZU9yZGVyIiwibGluZU9yZGVycyIsImxpbmVPcmRlciIsInBhcnNlVjJmIiwicGFyc2VWM2YiLCJ6IiwicGFyc2VWYWx1ZSIsInBhcnNlSGVhZGVyIiwiRVhSSGVhZGVyMiIsInNwZWMiLCJzaW5nbGVUaWxlIiwibG9uZ05hbWUiLCJkZWVwRm9ybWF0IiwibXVsdGlQYXJ0Iiwia2VlcFJlYWRpbmciLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlVHlwZSIsImF0dHJpYnV0ZVNpemUiLCJhdHRyaWJ1dGVWYWx1ZSIsImNvbnNvbGUiLCJ3YXJuIiwiZXJyb3IiLCJzZXR1cERlY29kZXIiLCJvdXRwdXRUeXBlIiwiRVhSRGVjb2RlcjIiLCJkYXRhV2luZG93IiwiYnl0ZXNQZXJMaW5lIiwiaW5wdXRTaXplIiwidW5jb21wcmVzcyIsImdldHRlciIsImZvcm1hdCIsImJsb2NrQ291bnQiLCJvdXRwdXRDaGFubmVscyIsImJ5dGVBcnJheSIsImNvbG9yU3BhY2UiLCJlbmNvZGluZyIsImJ1ZmZlckRhdGFWaWV3IiwidUludDhBcnJheSIsIkVYUkRlY29kZXIiLCJ0bXBPZmZzZXQiLCJjaGFubmVsT2Zmc2V0cyIsIlIiLCJHIiwiQiIsIkEiLCJZIiwic2NhbmxpbmVCbG9ja0lkeCIsImxpbmUiLCJpc0NvbXByZXNzZWQiLCJsaW5lX3kiLCJ0cnVlX3kiLCJjaGFubmVsSUQiLCJjT2ZmIiwib3V0SW5kZXgiLCJoZWFkZXIiLCJzZXREYXRhVHlwZSIsImxvYWQiLCJ1cmwiLCJvbkxvYWQiLCJvblByb2dyZXNzIiwib25FcnJvciIsIm9uTG9hZENhbGxiYWNrIiwidGV4dHVyZSIsInRleERhdGEiLCJtaW5GaWx0ZXIiLCJtYWdGaWx0ZXIiLCJnZW5lcmF0ZU1pcG1hcHMiLCJmbGlwWSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/EXRLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/GLTFLoader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFLoader: () => (/* binding */ GLTFLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/BufferGeometryUtils.js */ \"(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n\n\n\nclass GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(manager){\n        super(manager);\n        this.dracoLoader = null;\n        this.ktx2Loader = null;\n        this.meshoptDecoder = null;\n        this.pluginCallbacks = [];\n        this.register(function(parser) {\n            return new GLTFMaterialsClearcoatExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureBasisUExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureWebPExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureAVIFExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsSheenExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsTransmissionExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsVolumeExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsIorExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsEmissiveStrengthExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsSpecularExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsIridescenceExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsAnisotropyExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFLightsExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMeshoptCompression(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMeshGpuInstancing(parser);\n        });\n    }\n    load(url, onLoad, onProgress, onError) {\n        const scope = this;\n        let resourcePath;\n        if (this.resourcePath !== \"\") {\n            resourcePath = this.resourcePath;\n        } else if (this.path !== \"\") {\n            resourcePath = this.path;\n        } else {\n            resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n        }\n        this.manager.itemStart(url);\n        const _onError = function(e) {\n            if (onError) {\n                onError(e);\n            } else {\n                console.error(e);\n            }\n            scope.manager.itemError(url);\n            scope.manager.itemEnd(url);\n        };\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(url, function(data) {\n            try {\n                scope.parse(data, resourcePath, function(gltf) {\n                    onLoad(gltf);\n                    scope.manager.itemEnd(url);\n                }, _onError);\n            } catch (e) {\n                _onError(e);\n            }\n        }, onProgress, _onError);\n    }\n    setDRACOLoader(dracoLoader) {\n        this.dracoLoader = dracoLoader;\n        return this;\n    }\n    setDDSLoader() {\n        throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n    }\n    setKTX2Loader(ktx2Loader) {\n        this.ktx2Loader = ktx2Loader;\n        return this;\n    }\n    setMeshoptDecoder(meshoptDecoder) {\n        this.meshoptDecoder = meshoptDecoder;\n        return this;\n    }\n    register(callback) {\n        if (this.pluginCallbacks.indexOf(callback) === -1) {\n            this.pluginCallbacks.push(callback);\n        }\n        return this;\n    }\n    unregister(callback) {\n        if (this.pluginCallbacks.indexOf(callback) !== -1) {\n            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n        }\n        return this;\n    }\n    parse(data, path, onLoad, onError) {\n        let json;\n        const extensions = {};\n        const plugins = {};\n        if (typeof data === \"string\") {\n            json = JSON.parse(data);\n        } else if (data instanceof ArrayBuffer) {\n            const magic = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4)));\n            if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n                try {\n                    extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n                } catch (error) {\n                    if (onError) onError(error);\n                    return;\n                }\n                json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n            } else {\n                json = JSON.parse(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data)));\n            }\n        } else {\n            json = data;\n        }\n        if (json.asset === void 0 || json.asset.version[0] < 2) {\n            if (onError) onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n            return;\n        }\n        const parser = new GLTFParser(json, {\n            path: path || this.resourcePath || \"\",\n            crossOrigin: this.crossOrigin,\n            requestHeader: this.requestHeader,\n            manager: this.manager,\n            ktx2Loader: this.ktx2Loader,\n            meshoptDecoder: this.meshoptDecoder\n        });\n        parser.fileLoader.setRequestHeader(this.requestHeader);\n        for(let i = 0; i < this.pluginCallbacks.length; i++){\n            const plugin = this.pluginCallbacks[i](parser);\n            plugins[plugin.name] = plugin;\n            extensions[plugin.name] = true;\n        }\n        if (json.extensionsUsed) {\n            for(let i = 0; i < json.extensionsUsed.length; ++i){\n                const extensionName = json.extensionsUsed[i];\n                const extensionsRequired = json.extensionsRequired || [];\n                switch(extensionName){\n                    case EXTENSIONS.KHR_MATERIALS_UNLIT:\n                        extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n                        break;\n                    case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n                        extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n                        break;\n                    case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n                        extensions[extensionName] = new GLTFTextureTransformExtension();\n                        break;\n                    case EXTENSIONS.KHR_MESH_QUANTIZATION:\n                        extensions[extensionName] = new GLTFMeshQuantizationExtension();\n                        break;\n                    default:\n                        if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n                            console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n                        }\n                }\n            }\n        }\n        parser.setExtensions(extensions);\n        parser.setPlugins(plugins);\n        parser.parse(onLoad, onError);\n    }\n    parseAsync(data, path) {\n        const scope = this;\n        return new Promise(function(resolve, reject) {\n            scope.parse(data, path, resolve, reject);\n        });\n    }\n}\nfunction GLTFRegistry() {\n    let objects = {};\n    return {\n        get: function(key) {\n            return objects[key];\n        },\n        add: function(key, object) {\n            objects[key] = object;\n        },\n        remove: function(key) {\n            delete objects[key];\n        },\n        removeAll: function() {\n            objects = {};\n        }\n    };\n}\nconst EXTENSIONS = {\n    KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n    KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n    KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n    KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n    KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n    KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n    KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n    KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n    KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n    KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n    KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n    KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n    KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n    KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n    KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n    KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n    EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n    EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n    EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n    EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass GLTFLightsExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n        this.cache = {\n            refs: {},\n            uses: {}\n        };\n    }\n    _markDefs() {\n        const parser = this.parser;\n        const nodeDefs = this.parser.json.nodes || [];\n        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){\n            const nodeDef = nodeDefs[nodeIndex];\n            if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n                parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n            }\n        }\n    }\n    _loadLight(lightIndex) {\n        const parser = this.parser;\n        const cacheKey = \"light:\" + lightIndex;\n        let dependency = parser.cache.get(cacheKey);\n        if (dependency) return dependency;\n        const json = parser.json;\n        const extensions = json.extensions && json.extensions[this.name] || {};\n        const lightDefs = extensions.lights || [];\n        const lightDef = lightDefs[lightIndex];\n        let lightNode;\n        const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n        if (lightDef.color !== void 0) color.fromArray(lightDef.color);\n        const range = lightDef.range !== void 0 ? lightDef.range : 0;\n        switch(lightDef.type){\n            case \"directional\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(color);\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            case \"point\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(color);\n                lightNode.distance = range;\n                break;\n            case \"spot\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight(color);\n                lightNode.distance = range;\n                lightDef.spot = lightDef.spot || {};\n                lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n                lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n                lightNode.angle = lightDef.spot.outerConeAngle;\n                lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            default:\n                throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n        }\n        lightNode.position.set(0, 0, 0);\n        lightNode.decay = 2;\n        assignExtrasToUserData(lightNode, lightDef);\n        if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;\n        lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n        dependency = Promise.resolve(lightNode);\n        parser.cache.add(cacheKey, dependency);\n        return dependency;\n    }\n    getDependency(type, index) {\n        if (type !== \"light\") return;\n        return this._loadLight(index);\n    }\n    createNodeAttachment(nodeIndex) {\n        const self2 = this;\n        const parser = this.parser;\n        const json = parser.json;\n        const nodeDef = json.nodes[nodeIndex];\n        const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n        const lightIndex = lightDef.light;\n        if (lightIndex === void 0) return null;\n        return this._loadLight(lightIndex).then(function(light) {\n            return parser._getNodeRef(self2.cache, lightIndex, light);\n        });\n    }\n}\nclass GLTFMaterialsUnlitExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n    }\n    getMaterialType() {\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;\n    }\n    extendParams(materialParams, materialDef, parser) {\n        const pending = [];\n        materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n        materialParams.opacity = 1;\n        const metallicRoughness = materialDef.pbrMetallicRoughness;\n        if (metallicRoughness) {\n            if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                const array = metallicRoughness.baseColorFactor;\n                materialParams.color.fromArray(array);\n                materialParams.opacity = array[3];\n            }\n            if (metallicRoughness.baseColorTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, 3001));\n            }\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n        if (emissiveStrength !== void 0) {\n            materialParams.emissiveIntensity = emissiveStrength;\n        }\n        return Promise.resolve();\n    }\n}\nclass GLTFMaterialsClearcoatExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.clearcoatFactor !== void 0) {\n            materialParams.clearcoat = extension.clearcoatFactor;\n        }\n        if (extension.clearcoatTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n        }\n        if (extension.clearcoatRoughnessFactor !== void 0) {\n            materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n        }\n        if (extension.clearcoatRoughnessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n        }\n        if (extension.clearcoatNormalTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n            if (extension.clearcoatNormalTexture.scale !== void 0) {\n                const scale = extension.clearcoatNormalTexture.scale;\n                materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scale, scale);\n            }\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsIridescenceExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.iridescenceFactor !== void 0) {\n            materialParams.iridescence = extension.iridescenceFactor;\n        }\n        if (extension.iridescenceTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n        }\n        if (extension.iridescenceIor !== void 0) {\n            materialParams.iridescenceIOR = extension.iridescenceIor;\n        }\n        if (materialParams.iridescenceThicknessRange === void 0) {\n            materialParams.iridescenceThicknessRange = [\n                100,\n                400\n            ];\n        }\n        if (extension.iridescenceThicknessMinimum !== void 0) {\n            materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n        }\n        if (extension.iridescenceThicknessMaximum !== void 0) {\n            materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n        }\n        if (extension.iridescenceThicknessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsSheenExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        materialParams.sheenColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0);\n        materialParams.sheenRoughness = 0;\n        materialParams.sheen = 1;\n        const extension = materialDef.extensions[this.name];\n        if (extension.sheenColorFactor !== void 0) {\n            materialParams.sheenColor.fromArray(extension.sheenColorFactor);\n        }\n        if (extension.sheenRoughnessFactor !== void 0) {\n            materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n        }\n        if (extension.sheenColorTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, 3001));\n        }\n        if (extension.sheenRoughnessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsTransmissionExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.transmissionFactor !== void 0) {\n            materialParams.transmission = extension.transmissionFactor;\n        }\n        if (extension.transmissionTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsVolumeExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n        if (extension.thicknessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n        }\n        materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n        const colorArray = extension.attenuationColor || [\n            1,\n            1,\n            1\n        ];\n        materialParams.attenuationColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(colorArray[0], colorArray[1], colorArray[2]);\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsIorExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const extension = materialDef.extensions[this.name];\n        materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n        return Promise.resolve();\n    }\n}\nclass GLTFMaterialsSpecularExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n        if (extension.specularTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n        }\n        const colorArray = extension.specularColorFactor || [\n            1,\n            1,\n            1\n        ];\n        materialParams.specularColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(colorArray[0], colorArray[1], colorArray[2]);\n        if (extension.specularColorTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, 3001));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsAnisotropyExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.anisotropyStrength !== void 0) {\n            materialParams.anisotropy = extension.anisotropyStrength;\n        }\n        if (extension.anisotropyRotation !== void 0) {\n            materialParams.anisotropyRotation = extension.anisotropyRotation;\n        }\n        if (extension.anisotropyTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFTextureBasisUExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n    }\n    loadTexture(textureIndex) {\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[this.name];\n        const loader = parser.options.ktx2Loader;\n        if (!loader) {\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n            } else {\n                return null;\n            }\n        }\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n    }\n}\nclass GLTFTextureWebPExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n        this.isSupported = null;\n    }\n    loadTexture(textureIndex) {\n        const name = this.name;\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[name];\n        const source = json.images[extension.source];\n        let loader = parser.textureLoader;\n        if (source.uri) {\n            const handler = parser.options.manager.getHandler(source.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.detectSupport().then(function(isSupported) {\n            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n            }\n            return parser.loadTexture(textureIndex);\n        });\n    }\n    detectSupport() {\n        if (!this.isSupported) {\n            this.isSupported = new Promise(function(resolve) {\n                const image = new Image();\n                image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n                image.onload = image.onerror = function() {\n                    resolve(image.height === 1);\n                };\n            });\n        }\n        return this.isSupported;\n    }\n}\nclass GLTFTextureAVIFExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n        this.isSupported = null;\n    }\n    loadTexture(textureIndex) {\n        const name = this.name;\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[name];\n        const source = json.images[extension.source];\n        let loader = parser.textureLoader;\n        if (source.uri) {\n            const handler = parser.options.manager.getHandler(source.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.detectSupport().then(function(isSupported) {\n            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n            }\n            return parser.loadTexture(textureIndex);\n        });\n    }\n    detectSupport() {\n        if (!this.isSupported) {\n            this.isSupported = new Promise(function(resolve) {\n                const image = new Image();\n                image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n                image.onload = image.onerror = function() {\n                    resolve(image.height === 1);\n                };\n            });\n        }\n        return this.isSupported;\n    }\n}\nclass GLTFMeshoptCompression {\n    constructor(parser){\n        this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n        this.parser = parser;\n    }\n    loadBufferView(index) {\n        const json = this.parser.json;\n        const bufferView = json.bufferViews[index];\n        if (bufferView.extensions && bufferView.extensions[this.name]) {\n            const extensionDef = bufferView.extensions[this.name];\n            const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n            const decoder = this.parser.options.meshoptDecoder;\n            if (!decoder || !decoder.supported) {\n                if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n                    throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n                } else {\n                    return null;\n                }\n            }\n            return buffer.then(function(res) {\n                const byteOffset = extensionDef.byteOffset || 0;\n                const byteLength = extensionDef.byteLength || 0;\n                const count = extensionDef.count;\n                const stride = extensionDef.byteStride;\n                const source = new Uint8Array(res, byteOffset, byteLength);\n                if (decoder.decodeGltfBufferAsync) {\n                    return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {\n                        return res2.buffer;\n                    });\n                } else {\n                    return decoder.ready.then(function() {\n                        const result = new ArrayBuffer(count * stride);\n                        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\n                        return result;\n                    });\n                }\n            });\n        } else {\n            return null;\n        }\n    }\n}\nclass GLTFMeshGpuInstancing {\n    constructor(parser){\n        this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n        this.parser = parser;\n    }\n    createNodeMesh(nodeIndex) {\n        const json = this.parser.json;\n        const nodeDef = json.nodes[nodeIndex];\n        if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {\n            return null;\n        }\n        const meshDef = json.meshes[nodeDef.mesh];\n        for (const primitive of meshDef.primitives){\n            if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {\n                return null;\n            }\n        }\n        const extensionDef = nodeDef.extensions[this.name];\n        const attributesDef = extensionDef.attributes;\n        const pending = [];\n        const attributes = {};\n        for(const key in attributesDef){\n            pending.push(this.parser.getDependency(\"accessor\", attributesDef[key]).then((accessor)=>{\n                attributes[key] = accessor;\n                return attributes[key];\n            }));\n        }\n        if (pending.length < 1) {\n            return null;\n        }\n        pending.push(this.parser.createNodeMesh(nodeIndex));\n        return Promise.all(pending).then((results)=>{\n            const nodeObject = results.pop();\n            const meshes = nodeObject.isGroup ? nodeObject.children : [\n                nodeObject\n            ];\n            const count = results[0].count;\n            const instancedMeshes = [];\n            for (const mesh of meshes){\n                const m = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n                const s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n                const instancedMesh = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh(mesh.geometry, mesh.material, count);\n                for(let i = 0; i < count; i++){\n                    if (attributes.TRANSLATION) {\n                        p.fromBufferAttribute(attributes.TRANSLATION, i);\n                    }\n                    if (attributes.ROTATION) {\n                        q.fromBufferAttribute(attributes.ROTATION, i);\n                    }\n                    if (attributes.SCALE) {\n                        s.fromBufferAttribute(attributes.SCALE, i);\n                    }\n                    instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n                }\n                for(const attributeName in attributes){\n                    if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n                        mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n                    }\n                }\n                three__WEBPACK_IMPORTED_MODULE_0__.Object3D.prototype.copy.call(instancedMesh, mesh);\n                this.parser.assignFinalMaterial(instancedMesh);\n                instancedMeshes.push(instancedMesh);\n            }\n            if (nodeObject.isGroup) {\n                nodeObject.clear();\n                nodeObject.add(...instancedMeshes);\n                return nodeObject;\n            }\n            return instancedMeshes[0];\n        });\n    }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = {\n    JSON: 1313821514,\n    BIN: 5130562\n};\nclass GLTFBinaryExtension {\n    constructor(data){\n        this.name = EXTENSIONS.KHR_BINARY_GLTF;\n        this.content = null;\n        this.body = null;\n        const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n        this.header = {\n            magic: three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n            version: headerView.getUint32(4, true),\n            length: headerView.getUint32(8, true)\n        };\n        if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n            throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n        } else if (this.header.version < 2) {\n            throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n        }\n        const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n        const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n        let chunkIndex = 0;\n        while(chunkIndex < chunkContentsLength){\n            const chunkLength = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n            const chunkType = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n            if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n                const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n                this.content = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(contentArray);\n            } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n                const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n                this.body = data.slice(byteOffset, byteOffset + chunkLength);\n            }\n            chunkIndex += chunkLength;\n        }\n        if (this.content === null) {\n            throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n        }\n    }\n}\nclass GLTFDracoMeshCompressionExtension {\n    constructor(json, dracoLoader){\n        if (!dracoLoader) {\n            throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n        }\n        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n        this.json = json;\n        this.dracoLoader = dracoLoader;\n        this.dracoLoader.preload();\n    }\n    decodePrimitive(primitive, parser) {\n        const json = this.json;\n        const dracoLoader = this.dracoLoader;\n        const bufferViewIndex = primitive.extensions[this.name].bufferView;\n        const gltfAttributeMap = primitive.extensions[this.name].attributes;\n        const threeAttributeMap = {};\n        const attributeNormalizedMap = {};\n        const attributeTypeMap = {};\n        for(const attributeName in gltfAttributeMap){\n            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n            threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n        }\n        for(const attributeName in primitive.attributes){\n            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n            if (gltfAttributeMap[attributeName] !== void 0) {\n                const accessorDef = json.accessors[primitive.attributes[attributeName]];\n                const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n                attributeTypeMap[threeAttributeName] = componentType.name;\n                attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n            }\n        }\n        return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n            return new Promise(function(resolve) {\n                dracoLoader.decodeDracoFile(bufferView, function(geometry) {\n                    for(const attributeName in geometry.attributes){\n                        const attribute = geometry.attributes[attributeName];\n                        const normalized = attributeNormalizedMap[attributeName];\n                        if (normalized !== void 0) attribute.normalized = normalized;\n                    }\n                    resolve(geometry);\n                }, threeAttributeMap, attributeTypeMap);\n            });\n        });\n    }\n}\nclass GLTFTextureTransformExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n    }\n    extendTexture(texture, transform) {\n        if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n            return texture;\n        }\n        texture = texture.clone();\n        if (transform.texCoord !== void 0) {\n            texture.channel = transform.texCoord;\n        }\n        if (transform.offset !== void 0) {\n            texture.offset.fromArray(transform.offset);\n        }\n        if (transform.rotation !== void 0) {\n            texture.rotation = transform.rotation;\n        }\n        if (transform.scale !== void 0) {\n            texture.repeat.fromArray(transform.scale);\n        }\n        texture.needsUpdate = true;\n        return texture;\n    }\n}\nclass GLTFMeshQuantizationExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n    }\n}\nclass GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {\n    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){\n        super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    }\n    copySampleValue_(index) {\n        const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n        for(let i = 0; i !== valueSize; i++){\n            result[i] = values[offset + i];\n        }\n        return result;\n    }\n    interpolate_(i1, t0, t, t1) {\n        const result = this.resultBuffer;\n        const values = this.sampleValues;\n        const stride = this.valueSize;\n        const stride2 = stride * 2;\n        const stride3 = stride * 3;\n        const td = t1 - t0;\n        const p = (t - t0) / td;\n        const pp = p * p;\n        const ppp = pp * p;\n        const offset1 = i1 * stride3;\n        const offset0 = offset1 - stride3;\n        const s2 = -2 * ppp + 3 * pp;\n        const s3 = ppp - pp;\n        const s0 = 1 - s2;\n        const s1 = s3 - pp + p;\n        for(let i = 0; i !== stride; i++){\n            const p0 = values[offset0 + i + stride];\n            const m0 = values[offset0 + i + stride2] * td;\n            const p1 = values[offset1 + i + stride];\n            const m1 = values[offset1 + i] * td;\n            result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n        }\n        return result;\n    }\n}\nconst _q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n    interpolate_(i1, t0, t, t1) {\n        const result = super.interpolate_(i1, t0, t, t1);\n        _q.fromArray(result).normalize().toArray(result);\n        return result;\n    }\n}\nconst WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    POINTS: 0,\n    LINES: 1,\n    LINE_LOOP: 2,\n    LINE_STRIP: 3,\n    TRIANGLES: 4,\n    TRIANGLE_STRIP: 5,\n    TRIANGLE_FAN: 6,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n    9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n    9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n    9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,\n    9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,\n    9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,\n    9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n    33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n    33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,\n    10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n};\nconst ATTRIBUTES = {\n    POSITION: \"position\",\n    NORMAL: \"normal\",\n    TANGENT: \"tangent\",\n    // uv => uv1, 4 uv channels\n    // https://github.com/mrdoob/three.js/pull/25943\n    // https://github.com/mrdoob/three.js/pull/25788\n    ..._polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__.version >= 152 ? {\n        TEXCOORD_0: \"uv\",\n        TEXCOORD_1: \"uv1\",\n        TEXCOORD_2: \"uv2\",\n        TEXCOORD_3: \"uv3\"\n    } : {\n        TEXCOORD_0: \"uv\",\n        TEXCOORD_1: \"uv2\"\n    },\n    COLOR_0: \"color\",\n    WEIGHTS_0: \"skinWeight\",\n    JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n    scale: \"scale\",\n    translation: \"position\",\n    rotation: \"quaternion\",\n    weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n    CUBICSPLINE: void 0,\n    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n    // keyframe track will be initialized with a default interpolation type, then modified.\n    LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,\n    STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n    OPAQUE: \"OPAQUE\",\n    MASK: \"MASK\",\n    BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache) {\n    if (cache[\"DefaultMaterial\"] === void 0) {\n        cache[\"DefaultMaterial\"] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: 16777215,\n            emissive: 0,\n            metalness: 1,\n            roughness: 1,\n            transparent: false,\n            depthTest: true,\n            side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide\n        });\n    }\n    return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n    for(const name in objectDef.extensions){\n        if (knownExtensions[name] === void 0) {\n            object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n            object.userData.gltfExtensions[name] = objectDef.extensions[name];\n        }\n    }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n    if (gltfDef.extras !== void 0) {\n        if (typeof gltfDef.extras === \"object\") {\n            Object.assign(object.userData, gltfDef.extras);\n        } else {\n            console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n        }\n    }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n    let hasMorphPosition = false;\n    let hasMorphNormal = false;\n    let hasMorphColor = false;\n    for(let i = 0, il = targets.length; i < il; i++){\n        const target = targets[i];\n        if (target.POSITION !== void 0) hasMorphPosition = true;\n        if (target.NORMAL !== void 0) hasMorphNormal = true;\n        if (target.COLOR_0 !== void 0) hasMorphColor = true;\n        if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;\n    }\n    if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);\n    const pendingPositionAccessors = [];\n    const pendingNormalAccessors = [];\n    const pendingColorAccessors = [];\n    for(let i = 0, il = targets.length; i < il; i++){\n        const target = targets[i];\n        if (hasMorphPosition) {\n            const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n            pendingPositionAccessors.push(pendingAccessor);\n        }\n        if (hasMorphNormal) {\n            const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n            pendingNormalAccessors.push(pendingAccessor);\n        }\n        if (hasMorphColor) {\n            const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n            pendingColorAccessors.push(pendingAccessor);\n        }\n    }\n    return Promise.all([\n        Promise.all(pendingPositionAccessors),\n        Promise.all(pendingNormalAccessors),\n        Promise.all(pendingColorAccessors)\n    ]).then(function(accessors) {\n        const morphPositions = accessors[0];\n        const morphNormals = accessors[1];\n        const morphColors = accessors[2];\n        if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n        if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n        if (hasMorphColor) geometry.morphAttributes.color = morphColors;\n        geometry.morphTargetsRelative = true;\n        return geometry;\n    });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n    mesh.updateMorphTargets();\n    if (meshDef.weights !== void 0) {\n        for(let i = 0, il = meshDef.weights.length; i < il; i++){\n            mesh.morphTargetInfluences[i] = meshDef.weights[i];\n        }\n    }\n    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n        const targetNames = meshDef.extras.targetNames;\n        if (mesh.morphTargetInfluences.length === targetNames.length) {\n            mesh.morphTargetDictionary = {};\n            for(let i = 0, il = targetNames.length; i < il; i++){\n                mesh.morphTargetDictionary[targetNames[i]] = i;\n            }\n        } else {\n            console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n        }\n    }\n}\nfunction createPrimitiveKey(primitiveDef) {\n    let geometryKey;\n    const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n    if (dracoExtension) {\n        geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n    } else {\n        geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n    }\n    if (primitiveDef.targets !== void 0) {\n        for(let i = 0, il = primitiveDef.targets.length; i < il; i++){\n            geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n        }\n    }\n    return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n    let attributesKey = \"\";\n    const keys = Object.keys(attributes).sort();\n    for(let i = 0, il = keys.length; i < il; i++){\n        attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n    }\n    return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n    switch(constructor){\n        case Int8Array:\n            return 1 / 127;\n        case Uint8Array:\n            return 1 / 255;\n        case Int16Array:\n            return 1 / 32767;\n        case Uint16Array:\n            return 1 / 65535;\n        default:\n            throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n    }\n}\nfunction getImageURIMimeType(uri) {\n    if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return \"image/jpeg\";\n    if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return \"image/webp\";\n    return \"image/png\";\n}\nconst _identityMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nclass GLTFParser {\n    constructor(json = {}, options = {}){\n        this.json = json;\n        this.extensions = {};\n        this.plugins = {};\n        this.options = options;\n        this.cache = new GLTFRegistry();\n        this.associations = /* @__PURE__ */ new Map();\n        this.primitiveCache = {};\n        this.nodeCache = {};\n        this.meshCache = {\n            refs: {},\n            uses: {}\n        };\n        this.cameraCache = {\n            refs: {},\n            uses: {}\n        };\n        this.lightCache = {\n            refs: {},\n            uses: {}\n        };\n        this.sourceCache = {};\n        this.textureCache = {};\n        this.nodeNamesUsed = {};\n        let isSafari = false;\n        let isFirefox = false;\n        let firefoxVersion = -1;\n        if (typeof navigator !== \"undefined\" && typeof navigator.userAgent !== \"undefined\") {\n            isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n            isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n            firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n        }\n        if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(this.options.manager);\n        } else {\n            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader(this.options.manager);\n        }\n        this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n        this.textureLoader.setRequestHeader(this.options.requestHeader);\n        this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.options.manager);\n        this.fileLoader.setResponseType(\"arraybuffer\");\n        if (this.options.crossOrigin === \"use-credentials\") {\n            this.fileLoader.setWithCredentials(true);\n        }\n    }\n    setExtensions(extensions) {\n        this.extensions = extensions;\n    }\n    setPlugins(plugins) {\n        this.plugins = plugins;\n    }\n    parse(onLoad, onError) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        this.cache.removeAll();\n        this.nodeCache = {};\n        this._invokeAll(function(ext) {\n            return ext._markDefs && ext._markDefs();\n        });\n        Promise.all(this._invokeAll(function(ext) {\n            return ext.beforeRoot && ext.beforeRoot();\n        })).then(function() {\n            return Promise.all([\n                parser.getDependencies(\"scene\"),\n                parser.getDependencies(\"animation\"),\n                parser.getDependencies(\"camera\")\n            ]);\n        }).then(function(dependencies) {\n            const result = {\n                scene: dependencies[0][json.scene || 0],\n                scenes: dependencies[0],\n                animations: dependencies[1],\n                cameras: dependencies[2],\n                asset: json.asset,\n                parser,\n                userData: {}\n            };\n            addUnknownExtensionsToUserData(extensions, result, json);\n            assignExtrasToUserData(result, json);\n            Promise.all(parser._invokeAll(function(ext) {\n                return ext.afterRoot && ext.afterRoot(result);\n            })).then(function() {\n                onLoad(result);\n            });\n        }).catch(onError);\n    }\n    /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */ _markDefs() {\n        const nodeDefs = this.json.nodes || [];\n        const skinDefs = this.json.skins || [];\n        const meshDefs = this.json.meshes || [];\n        for(let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++){\n            const joints = skinDefs[skinIndex].joints;\n            for(let i = 0, il = joints.length; i < il; i++){\n                nodeDefs[joints[i]].isBone = true;\n            }\n        }\n        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){\n            const nodeDef = nodeDefs[nodeIndex];\n            if (nodeDef.mesh !== void 0) {\n                this._addNodeRef(this.meshCache, nodeDef.mesh);\n                if (nodeDef.skin !== void 0) {\n                    meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n                }\n            }\n            if (nodeDef.camera !== void 0) {\n                this._addNodeRef(this.cameraCache, nodeDef.camera);\n            }\n        }\n    }\n    /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */ _addNodeRef(cache, index) {\n        if (index === void 0) return;\n        if (cache.refs[index] === void 0) {\n            cache.refs[index] = cache.uses[index] = 0;\n        }\n        cache.refs[index]++;\n    }\n    /** Returns a reference to a shared resource, cloning it if necessary. */ _getNodeRef(cache, index, object) {\n        if (cache.refs[index] <= 1) return object;\n        const ref = object.clone();\n        const updateMappings = (original, clone)=>{\n            const mappings = this.associations.get(original);\n            if (mappings != null) {\n                this.associations.set(clone, mappings);\n            }\n            for (const [i, child] of original.children.entries()){\n                updateMappings(child, clone.children[i]);\n            }\n        };\n        updateMappings(object, ref);\n        ref.name += \"_instance_\" + cache.uses[index]++;\n        return ref;\n    }\n    _invokeOne(func) {\n        const extensions = Object.values(this.plugins);\n        extensions.push(this);\n        for(let i = 0; i < extensions.length; i++){\n            const result = func(extensions[i]);\n            if (result) return result;\n        }\n        return null;\n    }\n    _invokeAll(func) {\n        const extensions = Object.values(this.plugins);\n        extensions.unshift(this);\n        const pending = [];\n        for(let i = 0; i < extensions.length; i++){\n            const result = func(extensions[i]);\n            if (result) pending.push(result);\n        }\n        return pending;\n    }\n    /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */ getDependency(type, index) {\n        const cacheKey = type + \":\" + index;\n        let dependency = this.cache.get(cacheKey);\n        if (!dependency) {\n            switch(type){\n                case \"scene\":\n                    dependency = this.loadScene(index);\n                    break;\n                case \"node\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadNode && ext.loadNode(index);\n                    });\n                    break;\n                case \"mesh\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadMesh && ext.loadMesh(index);\n                    });\n                    break;\n                case \"accessor\":\n                    dependency = this.loadAccessor(index);\n                    break;\n                case \"bufferView\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadBufferView && ext.loadBufferView(index);\n                    });\n                    break;\n                case \"buffer\":\n                    dependency = this.loadBuffer(index);\n                    break;\n                case \"material\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadMaterial && ext.loadMaterial(index);\n                    });\n                    break;\n                case \"texture\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadTexture && ext.loadTexture(index);\n                    });\n                    break;\n                case \"skin\":\n                    dependency = this.loadSkin(index);\n                    break;\n                case \"animation\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadAnimation && ext.loadAnimation(index);\n                    });\n                    break;\n                case \"camera\":\n                    dependency = this.loadCamera(index);\n                    break;\n                default:\n                    dependency = this._invokeOne(function(ext) {\n                        return ext != this && ext.getDependency && ext.getDependency(type, index);\n                    });\n                    if (!dependency) {\n                        throw new Error(\"Unknown type: \" + type);\n                    }\n                    break;\n            }\n            this.cache.add(cacheKey, dependency);\n        }\n        return dependency;\n    }\n    /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */ getDependencies(type) {\n        let dependencies = this.cache.get(type);\n        if (!dependencies) {\n            const parser = this;\n            const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n            dependencies = Promise.all(defs.map(function(def, index) {\n                return parser.getDependency(type, index);\n            }));\n            this.cache.add(type, dependencies);\n        }\n        return dependencies;\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */ loadBuffer(bufferIndex) {\n        const bufferDef = this.json.buffers[bufferIndex];\n        const loader = this.fileLoader;\n        if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n            throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n        }\n        if (bufferDef.uri === void 0 && bufferIndex === 0) {\n            return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n        }\n        const options = this.options;\n        return new Promise(function(resolve, reject) {\n            loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n                reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n            });\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */ loadBufferView(bufferViewIndex) {\n        const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n        return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n            const byteLength = bufferViewDef.byteLength || 0;\n            const byteOffset = bufferViewDef.byteOffset || 0;\n            return buffer.slice(byteOffset, byteOffset + byteLength);\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */ loadAccessor(accessorIndex) {\n        const parser = this;\n        const json = this.json;\n        const accessorDef = this.json.accessors[accessorIndex];\n        if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n            const normalized = accessorDef.normalized === true;\n            const array = new TypedArray(accessorDef.count * itemSize);\n            return Promise.resolve(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized));\n        }\n        const pendingBufferViews = [];\n        if (accessorDef.bufferView !== void 0) {\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n        } else {\n            pendingBufferViews.push(null);\n        }\n        if (accessorDef.sparse !== void 0) {\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n        }\n        return Promise.all(pendingBufferViews).then(function(bufferViews) {\n            const bufferView = bufferViews[0];\n            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n            const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n            const itemBytes = elementBytes * itemSize;\n            const byteOffset = accessorDef.byteOffset || 0;\n            const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n            const normalized = accessorDef.normalized === true;\n            let array, bufferAttribute;\n            if (byteStride && byteStride !== itemBytes) {\n                const ibSlice = Math.floor(byteOffset / byteStride);\n                const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n                let ib = parser.cache.get(ibCacheKey);\n                if (!ib) {\n                    array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n                    ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(array, byteStride / elementBytes);\n                    parser.cache.add(ibCacheKey, ib);\n                }\n                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n            } else {\n                if (bufferView === null) {\n                    array = new TypedArray(accessorDef.count * itemSize);\n                } else {\n                    array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n                }\n                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n            }\n            if (accessorDef.sparse !== void 0) {\n                const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n                const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n                const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n                const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n                const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n                const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n                if (bufferView !== null) {\n                    bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n                }\n                for(let i = 0, il = sparseIndices.length; i < il; i++){\n                    const index = sparseIndices[i];\n                    bufferAttribute.setX(index, sparseValues[i * itemSize]);\n                    if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n                    if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n                    if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n                    if (itemSize >= 5) throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n                }\n            }\n            return bufferAttribute;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */ loadTexture(textureIndex) {\n        const json = this.json;\n        const options = this.options;\n        const textureDef = json.textures[textureIndex];\n        const sourceIndex = textureDef.source;\n        const sourceDef = json.images[sourceIndex];\n        let loader = this.textureLoader;\n        if (sourceDef.uri) {\n            const handler = options.manager.getHandler(sourceDef.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.loadTextureImage(textureIndex, sourceIndex, loader);\n    }\n    loadTextureImage(textureIndex, sourceIndex, loader) {\n        const parser = this;\n        const json = this.json;\n        const textureDef = json.textures[textureIndex];\n        const sourceDef = json.images[sourceIndex];\n        const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n        if (this.textureCache[cacheKey]) {\n            return this.textureCache[cacheKey];\n        }\n        const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {\n            texture.flipY = false;\n            texture.name = textureDef.name || sourceDef.name || \"\";\n            if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n                texture.name = sourceDef.uri;\n            }\n            const samplers = json.samplers || {};\n            const sampler = samplers[textureDef.sampler] || {};\n            texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;\n            texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            parser.associations.set(texture, {\n                textures: textureIndex\n            });\n            return texture;\n        }).catch(function() {\n            return null;\n        });\n        this.textureCache[cacheKey] = promise;\n        return promise;\n    }\n    loadImageSource(sourceIndex, loader) {\n        const parser = this;\n        const json = this.json;\n        const options = this.options;\n        if (this.sourceCache[sourceIndex] !== void 0) {\n            return this.sourceCache[sourceIndex].then((texture)=>texture.clone());\n        }\n        const sourceDef = json.images[sourceIndex];\n        const URL = self.URL || self.webkitURL;\n        let sourceURI = sourceDef.uri || \"\";\n        let isObjectURL = false;\n        if (sourceDef.bufferView !== void 0) {\n            sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n                isObjectURL = true;\n                const blob = new Blob([\n                    bufferView\n                ], {\n                    type: sourceDef.mimeType\n                });\n                sourceURI = URL.createObjectURL(blob);\n                return sourceURI;\n            });\n        } else if (sourceDef.uri === void 0) {\n            throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n        }\n        const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {\n            return new Promise(function(resolve, reject) {\n                let onLoad = resolve;\n                if (loader.isImageBitmapLoader === true) {\n                    onLoad = function(imageBitmap) {\n                        const texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(imageBitmap);\n                        texture.needsUpdate = true;\n                        resolve(texture);\n                    };\n                }\n                loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n            });\n        }).then(function(texture) {\n            if (isObjectURL === true) {\n                URL.revokeObjectURL(sourceURI);\n            }\n            texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n            return texture;\n        }).catch(function(error) {\n            console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n            throw error;\n        });\n        this.sourceCache[sourceIndex] = promise;\n        return promise;\n    }\n    /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */ assignTexture(materialParams, mapName, mapDef, encoding) {\n        const parser = this;\n        return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n            if (!texture) return null;\n            if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {\n                texture = texture.clone();\n                texture.channel = mapDef.texCoord;\n            }\n            if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n                const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n                if (transform) {\n                    const gltfReference = parser.associations.get(texture);\n                    texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n                    parser.associations.set(texture, gltfReference);\n                }\n            }\n            if (encoding !== void 0) {\n                if (\"colorSpace\" in texture) texture.colorSpace = encoding === 3001 ? \"srgb\" : \"srgb-linear\";\n                else texture.encoding = encoding;\n            }\n            materialParams[mapName] = texture;\n            return texture;\n        });\n    }\n    /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */ assignFinalMaterial(mesh) {\n        const geometry = mesh.geometry;\n        let material = mesh.material;\n        const useDerivativeTangents = geometry.attributes.tangent === void 0;\n        const useVertexColors = geometry.attributes.color !== void 0;\n        const useFlatShading = geometry.attributes.normal === void 0;\n        if (mesh.isPoints) {\n            const cacheKey = \"PointsMaterial:\" + material.uuid;\n            let pointsMaterial = this.cache.get(cacheKey);\n            if (!pointsMaterial) {\n                pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();\n                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(pointsMaterial, material);\n                pointsMaterial.color.copy(material.color);\n                pointsMaterial.map = material.map;\n                pointsMaterial.sizeAttenuation = false;\n                this.cache.add(cacheKey, pointsMaterial);\n            }\n            material = pointsMaterial;\n        } else if (mesh.isLine) {\n            const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n            let lineMaterial = this.cache.get(cacheKey);\n            if (!lineMaterial) {\n                lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(lineMaterial, material);\n                lineMaterial.color.copy(material.color);\n                lineMaterial.map = material.map;\n                this.cache.add(cacheKey, lineMaterial);\n            }\n            material = lineMaterial;\n        }\n        if (useDerivativeTangents || useVertexColors || useFlatShading) {\n            let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n            if (useDerivativeTangents) cacheKey += \"derivative-tangents:\";\n            if (useVertexColors) cacheKey += \"vertex-colors:\";\n            if (useFlatShading) cacheKey += \"flat-shading:\";\n            let cachedMaterial = this.cache.get(cacheKey);\n            if (!cachedMaterial) {\n                cachedMaterial = material.clone();\n                if (useVertexColors) cachedMaterial.vertexColors = true;\n                if (useFlatShading) cachedMaterial.flatShading = true;\n                if (useDerivativeTangents) {\n                    if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\n                    if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;\n                }\n                this.cache.add(cacheKey, cachedMaterial);\n                this.associations.set(cachedMaterial, this.associations.get(material));\n            }\n            material = cachedMaterial;\n        }\n        mesh.material = material;\n    }\n    getMaterialType() {\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */ loadMaterial(materialIndex) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        const materialDef = json.materials[materialIndex];\n        let materialType;\n        const materialParams = {};\n        const materialExtensions = materialDef.extensions || {};\n        const pending = [];\n        if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n            const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n            materialType = kmuExtension.getMaterialType();\n            pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n        } else {\n            const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n            materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n            materialParams.opacity = 1;\n            if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                const array = metallicRoughness.baseColorFactor;\n                materialParams.color.fromArray(array);\n                materialParams.opacity = array[3];\n            }\n            if (metallicRoughness.baseColorTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, 3001));\n            }\n            materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n            materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n            if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n                pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n            }\n            materialType = this._invokeOne(function(ext) {\n                return ext.getMaterialType && ext.getMaterialType(materialIndex);\n            });\n            pending.push(Promise.all(this._invokeAll(function(ext) {\n                return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n            })));\n        }\n        if (materialDef.doubleSided === true) {\n            materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n        }\n        const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n        if (alphaMode === ALPHA_MODES.BLEND) {\n            materialParams.transparent = true;\n            materialParams.depthWrite = false;\n        } else {\n            materialParams.transparent = false;\n            if (alphaMode === ALPHA_MODES.MASK) {\n                materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n            }\n        }\n        if (materialDef.normalTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n            materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);\n            if (materialDef.normalTexture.scale !== void 0) {\n                const scale = materialDef.normalTexture.scale;\n                materialParams.normalScale.set(scale, scale);\n            }\n        }\n        if (materialDef.occlusionTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n            if (materialDef.occlusionTexture.strength !== void 0) {\n                materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n            }\n        }\n        if (materialDef.emissiveFactor !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray(materialDef.emissiveFactor);\n        }\n        if (materialDef.emissiveTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, 3001));\n        }\n        return Promise.all(pending).then(function() {\n            const material = new materialType(materialParams);\n            if (materialDef.name) material.name = materialDef.name;\n            assignExtrasToUserData(material, materialDef);\n            parser.associations.set(material, {\n                materials: materialIndex\n            });\n            if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n            return material;\n        });\n    }\n    /** When Object3D instances are targeted by animation, they need unique names. */ createUniqueName(originalName) {\n        const sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName(originalName || \"\");\n        if (sanitizedName in this.nodeNamesUsed) {\n            return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n        } else {\n            this.nodeNamesUsed[sanitizedName] = 0;\n            return sanitizedName;\n        }\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */ loadGeometries(primitives) {\n        const parser = this;\n        const extensions = this.extensions;\n        const cache = this.primitiveCache;\n        function createDracoPrimitive(primitive) {\n            return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n                return addPrimitiveAttributes(geometry, primitive, parser);\n            });\n        }\n        const pending = [];\n        for(let i = 0, il = primitives.length; i < il; i++){\n            const primitive = primitives[i];\n            const cacheKey = createPrimitiveKey(primitive);\n            const cached = cache[cacheKey];\n            if (cached) {\n                pending.push(cached.promise);\n            } else {\n                let geometryPromise;\n                if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n                    geometryPromise = createDracoPrimitive(primitive);\n                } else {\n                    geometryPromise = addPrimitiveAttributes(new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser);\n                }\n                cache[cacheKey] = {\n                    primitive,\n                    promise: geometryPromise\n                };\n                pending.push(geometryPromise);\n            }\n        }\n        return Promise.all(pending);\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */ loadMesh(meshIndex) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        const meshDef = json.meshes[meshIndex];\n        const primitives = meshDef.primitives;\n        const pending = [];\n        for(let i = 0, il = primitives.length; i < il; i++){\n            const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n            pending.push(material);\n        }\n        pending.push(parser.loadGeometries(primitives));\n        return Promise.all(pending).then(function(results) {\n            const materials = results.slice(0, results.length - 1);\n            const geometries = results[results.length - 1];\n            const meshes = [];\n            for(let i = 0, il = geometries.length; i < il; i++){\n                const geometry = geometries[i];\n                const primitive = primitives[i];\n                let mesh;\n                const material = materials[i];\n                if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n                    mesh = meshDef.isSkinnedMesh === true ? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh(geometry, material) : new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);\n                    if (mesh.isSkinnedMesh === true) {\n                        mesh.normalizeSkinWeights();\n                    }\n                    if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n                        mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_2__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode);\n                    } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n                        mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_2__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode);\n                    }\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(geometry, material);\n                } else {\n                    throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n                }\n                if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n                    updateMorphTargets(mesh, meshDef);\n                }\n                mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n                assignExtrasToUserData(mesh, meshDef);\n                if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\n                parser.assignFinalMaterial(mesh);\n                meshes.push(mesh);\n            }\n            for(let i = 0, il = meshes.length; i < il; i++){\n                parser.associations.set(meshes[i], {\n                    meshes: meshIndex,\n                    primitives: i\n                });\n            }\n            if (meshes.length === 1) {\n                if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n                return meshes[0];\n            }\n            const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n            if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);\n            parser.associations.set(group, {\n                meshes: meshIndex\n            });\n            for(let i = 0, il = meshes.length; i < il; i++){\n                group.add(meshes[i]);\n            }\n            return group;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */ loadCamera(cameraIndex) {\n        let camera;\n        const cameraDef = this.json.cameras[cameraIndex];\n        const params = cameraDef[cameraDef.type];\n        if (!params) {\n            console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n            return;\n        }\n        if (cameraDef.type === \"perspective\") {\n            camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n        } else if (cameraDef.type === \"orthographic\") {\n            camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n        }\n        if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\n        assignExtrasToUserData(camera, cameraDef);\n        return Promise.resolve(camera);\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */ loadSkin(skinIndex) {\n        const skinDef = this.json.skins[skinIndex];\n        const pending = [];\n        for(let i = 0, il = skinDef.joints.length; i < il; i++){\n            pending.push(this._loadNodeShallow(skinDef.joints[i]));\n        }\n        if (skinDef.inverseBindMatrices !== void 0) {\n            pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n        } else {\n            pending.push(null);\n        }\n        return Promise.all(pending).then(function(results) {\n            const inverseBindMatrices = results.pop();\n            const jointNodes = results;\n            const bones = [];\n            const boneInverses = [];\n            for(let i = 0, il = jointNodes.length; i < il; i++){\n                const jointNode = jointNodes[i];\n                if (jointNode) {\n                    bones.push(jointNode);\n                    const mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                    if (inverseBindMatrices !== null) {\n                        mat.fromArray(inverseBindMatrices.array, i * 16);\n                    }\n                    boneInverses.push(mat);\n                } else {\n                    console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n                }\n            }\n            return new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(bones, boneInverses);\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */ loadAnimation(animationIndex) {\n        const json = this.json;\n        const animationDef = json.animations[animationIndex];\n        const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n        const pendingNodes = [];\n        const pendingInputAccessors = [];\n        const pendingOutputAccessors = [];\n        const pendingSamplers = [];\n        const pendingTargets = [];\n        for(let i = 0, il = animationDef.channels.length; i < il; i++){\n            const channel = animationDef.channels[i];\n            const sampler = animationDef.samplers[channel.sampler];\n            const target = channel.target;\n            const name = target.node;\n            const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n            const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n            if (target.node === void 0) continue;\n            pendingNodes.push(this.getDependency(\"node\", name));\n            pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n            pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n            pendingSamplers.push(sampler);\n            pendingTargets.push(target);\n        }\n        return Promise.all([\n            Promise.all(pendingNodes),\n            Promise.all(pendingInputAccessors),\n            Promise.all(pendingOutputAccessors),\n            Promise.all(pendingSamplers),\n            Promise.all(pendingTargets)\n        ]).then(function(dependencies) {\n            const nodes = dependencies[0];\n            const inputAccessors = dependencies[1];\n            const outputAccessors = dependencies[2];\n            const samplers = dependencies[3];\n            const targets = dependencies[4];\n            const tracks = [];\n            for(let i = 0, il = nodes.length; i < il; i++){\n                const node = nodes[i];\n                const inputAccessor = inputAccessors[i];\n                const outputAccessor = outputAccessors[i];\n                const sampler = samplers[i];\n                const target = targets[i];\n                if (node === void 0) continue;\n                node.updateMatrix();\n                let TypedKeyframeTrack;\n                switch(PATH_PROPERTIES[target.path]){\n                    case PATH_PROPERTIES.weights:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n                        break;\n                    case PATH_PROPERTIES.rotation:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;\n                        break;\n                    case PATH_PROPERTIES.position:\n                    case PATH_PROPERTIES.scale:\n                    default:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n                        break;\n                }\n                const targetName = node.name ? node.name : node.uuid;\n                const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;\n                const targetNames = [];\n                if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n                    node.traverse(function(object) {\n                        if (object.morphTargetInfluences) {\n                            targetNames.push(object.name ? object.name : object.uuid);\n                        }\n                    });\n                } else {\n                    targetNames.push(targetName);\n                }\n                let outputArray = outputAccessor.array;\n                if (outputAccessor.normalized) {\n                    const scale = getNormalizedComponentScale(outputArray.constructor);\n                    const scaled = new Float32Array(outputArray.length);\n                    for(let j = 0, jl = outputArray.length; j < jl; j++){\n                        scaled[j] = outputArray[j] * scale;\n                    }\n                    outputArray = scaled;\n                }\n                for(let j = 0, jl = targetNames.length; j < jl; j++){\n                    const track = new TypedKeyframeTrack(targetNames[j] + \".\" + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);\n                    if (sampler.interpolation === \"CUBICSPLINE\") {\n                        track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n                            const interpolantType = this instanceof three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n                            return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n                        };\n                        track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n                    }\n                    tracks.push(track);\n                }\n            }\n            return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(animationName, void 0, tracks);\n        });\n    }\n    createNodeMesh(nodeIndex) {\n        const json = this.json;\n        const parser = this;\n        const nodeDef = json.nodes[nodeIndex];\n        if (nodeDef.mesh === void 0) return null;\n        return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n            const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n            if (nodeDef.weights !== void 0) {\n                node.traverse(function(o) {\n                    if (!o.isMesh) return;\n                    for(let i = 0, il = nodeDef.weights.length; i < il; i++){\n                        o.morphTargetInfluences[i] = nodeDef.weights[i];\n                    }\n                });\n            }\n            return node;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */ loadNode(nodeIndex) {\n        const json = this.json;\n        const parser = this;\n        const nodeDef = json.nodes[nodeIndex];\n        const nodePending = parser._loadNodeShallow(nodeIndex);\n        const childPending = [];\n        const childrenDef = nodeDef.children || [];\n        for(let i = 0, il = childrenDef.length; i < il; i++){\n            childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n        }\n        const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n        return Promise.all([\n            nodePending,\n            Promise.all(childPending),\n            skeletonPending\n        ]).then(function(results) {\n            const node = results[0];\n            const children = results[1];\n            const skeleton = results[2];\n            if (skeleton !== null) {\n                node.traverse(function(mesh) {\n                    if (!mesh.isSkinnedMesh) return;\n                    mesh.bind(skeleton, _identityMatrix);\n                });\n            }\n            for(let i = 0, il = children.length; i < il; i++){\n                node.add(children[i]);\n            }\n            return node;\n        });\n    }\n    // ._loadNodeShallow() parses a single node.\n    // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n    _loadNodeShallow(nodeIndex) {\n        const json = this.json;\n        const extensions = this.extensions;\n        const parser = this;\n        if (this.nodeCache[nodeIndex] !== void 0) {\n            return this.nodeCache[nodeIndex];\n        }\n        const nodeDef = json.nodes[nodeIndex];\n        const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n        const pending = [];\n        const meshPromise = parser._invokeOne(function(ext) {\n            return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n        });\n        if (meshPromise) {\n            pending.push(meshPromise);\n        }\n        if (nodeDef.camera !== void 0) {\n            pending.push(parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n                return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n            }));\n        }\n        parser._invokeAll(function(ext) {\n            return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n        }).forEach(function(promise) {\n            pending.push(promise);\n        });\n        this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {\n            let node;\n            if (nodeDef.isBone === true) {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n            } else if (objects.length > 1) {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n            } else if (objects.length === 1) {\n                node = objects[0];\n            } else {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n            }\n            if (node !== objects[0]) {\n                for(let i = 0, il = objects.length; i < il; i++){\n                    node.add(objects[i]);\n                }\n            }\n            if (nodeDef.name) {\n                node.userData.name = nodeDef.name;\n                node.name = nodeName;\n            }\n            assignExtrasToUserData(node, nodeDef);\n            if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n            if (nodeDef.matrix !== void 0) {\n                const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                matrix.fromArray(nodeDef.matrix);\n                node.applyMatrix4(matrix);\n            } else {\n                if (nodeDef.translation !== void 0) {\n                    node.position.fromArray(nodeDef.translation);\n                }\n                if (nodeDef.rotation !== void 0) {\n                    node.quaternion.fromArray(nodeDef.rotation);\n                }\n                if (nodeDef.scale !== void 0) {\n                    node.scale.fromArray(nodeDef.scale);\n                }\n            }\n            if (!parser.associations.has(node)) {\n                parser.associations.set(node, {});\n            }\n            parser.associations.get(node).nodes = nodeIndex;\n            return node;\n        });\n        return this.nodeCache[nodeIndex];\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */ loadScene(sceneIndex) {\n        const extensions = this.extensions;\n        const sceneDef = this.json.scenes[sceneIndex];\n        const parser = this;\n        const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n        if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\n        assignExtrasToUserData(scene, sceneDef);\n        if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n        const nodeIds = sceneDef.nodes || [];\n        const pending = [];\n        for(let i = 0, il = nodeIds.length; i < il; i++){\n            pending.push(parser.getDependency(\"node\", nodeIds[i]));\n        }\n        return Promise.all(pending).then(function(nodes) {\n            for(let i = 0, il = nodes.length; i < il; i++){\n                scene.add(nodes[i]);\n            }\n            const reduceAssociations = (node)=>{\n                const reducedAssociations = /* @__PURE__ */ new Map();\n                for (const [key, value] of parser.associations){\n                    if (key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) {\n                        reducedAssociations.set(key, value);\n                    }\n                }\n                node.traverse((node2)=>{\n                    const mappings = parser.associations.get(node2);\n                    if (mappings != null) {\n                        reducedAssociations.set(node2, mappings);\n                    }\n                });\n                return reducedAssociations;\n            };\n            parser.associations = reduceAssociations(scene);\n            return scene;\n        });\n    }\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n    if (attributes.POSITION !== void 0) {\n        const accessor = parser.json.accessors[attributes.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n            box.set(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(min[0], min[1], min[2]), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(max[0], max[1], max[2]));\n            if (accessor.normalized) {\n                const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n                box.min.multiplyScalar(boxScale);\n                box.max.multiplyScalar(boxScale);\n            }\n        } else {\n            console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n            return;\n        }\n    } else {\n        return;\n    }\n    const targets = primitiveDef.targets;\n    if (targets !== void 0) {\n        const maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        for(let i = 0, il = targets.length; i < il; i++){\n            const target = targets[i];\n            if (target.POSITION !== void 0) {\n                const accessor = parser.json.accessors[target.POSITION];\n                const min = accessor.min;\n                const max = accessor.max;\n                if (min !== void 0 && max !== void 0) {\n                    vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n                    vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n                    vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n                    if (accessor.normalized) {\n                        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n                        vector.multiplyScalar(boxScale);\n                    }\n                    maxDisplacement.max(vector);\n                } else {\n                    console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n                }\n            }\n        }\n        box.expandByVector(maxDisplacement);\n    }\n    geometry.boundingBox = box;\n    const sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n    box.getCenter(sphere.center);\n    sphere.radius = box.min.distanceTo(box.max) / 2;\n    geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const pending = [];\n    function assignAttributeAccessor(accessorIndex, attributeName) {\n        return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n            geometry.setAttribute(attributeName, accessor);\n        });\n    }\n    for(const gltfAttributeName in attributes){\n        const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n        if (threeAttributeName in geometry.attributes) continue;\n        pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n    }\n    if (primitiveDef.indices !== void 0 && !geometry.index) {\n        const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n            geometry.setIndex(accessor2);\n        });\n        pending.push(accessor);\n    }\n    assignExtrasToUserData(geometry, primitiveDef);\n    computeBounds(geometry, primitiveDef, parser);\n    return Promise.all(pending).then(function() {\n        return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n    });\n}\n //# sourceMappingURL=GLTFLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvR0xURkxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWc4QjtBQUMxM0I7QUFDbEI7QUFDcEQsTUFBTStELG1CQUFtQi9ELHlDQUFNQTtJQUM3QmdFLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxlQUFlLEdBQUcsRUFBRTtRQUN6QixJQUFJLENBQUNDLFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSUMsZ0NBQWdDRDtRQUM3QztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJRSwyQkFBMkJGO1FBQ3hDO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlHLHlCQUF5Qkg7UUFDdEM7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSUkseUJBQXlCSjtRQUN0QztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJSyw0QkFBNEJMO1FBQ3pDO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlNLG1DQUFtQ047UUFDaEQ7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSU8sNkJBQTZCUDtRQUMxQztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJUSwwQkFBMEJSO1FBQ3ZDO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlTLHVD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QUFDLFNBQVN5SCxRQUFRO1lBQzNFWSxTQUFTUyxZQUFZLENBQUNELGVBQWVwQjtRQUN2QztJQUNGO0lBQ0EsSUFBSyxNQUFNc2MscUJBQXFCdmMsV0FBWTtRQUMxQyxNQUFNaUQscUJBQXFCQyxVQUFVLENBQUNxWixrQkFBa0IsSUFBSUEsa0JBQWtCcFosV0FBVztRQUN6RixJQUFJRixzQkFBc0JwQyxTQUFTYixVQUFVLEVBQzNDO1FBQ0ZsSCxRQUFRbEgsSUFBSSxDQUFDMHFCLHdCQUF3QnRjLFVBQVUsQ0FBQ3VjLGtCQUFrQixFQUFFdFo7SUFDdEU7SUFDQSxJQUFJMkksYUFBYUcsT0FBTyxLQUFLLEtBQUssS0FBSyxDQUFDbEwsU0FBU3hJLEtBQUssRUFBRTtRQUN0RCxNQUFNNEgsV0FBV3RSLE9BQU95SixhQUFhLENBQUMsWUFBWXdULGFBQWFHLE9BQU8sRUFBRXZULElBQUksQ0FBQyxTQUFTZ2tCLFNBQVM7WUFDN0YzYixTQUFTNGIsUUFBUSxDQUFDRDtRQUNwQjtRQUNBMWpCLFFBQVFsSCxJQUFJLENBQUNxTztJQUNmO0lBQ0FoSSx1QkFBdUI0SSxVQUFVK0s7SUFDakN5UCxjQUFjeGEsVUFBVStLLGNBQWNqZDtJQUN0QyxPQUFPeUYsUUFBUW9GLEdBQUcsQ0FBQ1YsU0FBU04sSUFBSSxDQUFDO1FBQy9CLE9BQU9vVCxhQUFhcEIsT0FBTyxLQUFLLEtBQUssSUFBSUQsZ0JBQWdCMUosVUFBVStLLGFBQWFwQixPQUFPLEVBQUU3YixVQUFVa1M7SUFDckc7QUFDRjtBQUdFLENBQ0Ysc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vM0QtQUktRW5nbGlzaC8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbG9hZGVycy9HTFRGTG9hZGVyLmpzP2JmYzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9hZGVyLCBMb2FkZXJVdGlscywgRmlsZUxvYWRlciwgQ29sb3IsIFNwb3RMaWdodCwgUG9pbnRMaWdodCwgRGlyZWN0aW9uYWxMaWdodCwgTWVzaEJhc2ljTWF0ZXJpYWwsIE1lc2hQaHlzaWNhbE1hdGVyaWFsLCBWZWN0b3IyLCBNYXRyaXg0LCBWZWN0b3IzLCBRdWF0ZXJuaW9uLCBJbnN0YW5jZWRNZXNoLCBPYmplY3QzRCwgVGV4dHVyZUxvYWRlciwgSW1hZ2VCaXRtYXBMb2FkZXIsIEJ1ZmZlckF0dHJpYnV0ZSwgSW50ZXJsZWF2ZWRCdWZmZXIsIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLCBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcG1hcExpbmVhckZpbHRlciwgUmVwZWF0V3JhcHBpbmcsIFBvaW50c01hdGVyaWFsLCBNYXRlcmlhbCwgTGluZUJhc2ljTWF0ZXJpYWwsIE1lc2hTdGFuZGFyZE1hdGVyaWFsLCBEb3VibGVTaWRlLCBQcm9wZXJ0eUJpbmRpbmcsIEJ1ZmZlckdlb21ldHJ5LCBTa2lubmVkTWVzaCwgTWVzaCwgVHJpYW5nbGVTdHJpcERyYXdNb2RlLCBUcmlhbmdsZUZhbkRyYXdNb2RlLCBMaW5lU2VnbWVudHMsIExpbmUsIExpbmVMb29wLCBQb2ludHMsIEdyb3VwLCBQZXJzcGVjdGl2ZUNhbWVyYSwgTWF0aFV0aWxzLCBPcnRob2dyYXBoaWNDYW1lcmEsIFNrZWxldG9uLCBJbnRlcnBvbGF0ZUxpbmVhciwgQW5pbWF0aW9uQ2xpcCwgQm9uZSwgTmVhcmVzdEZpbHRlciwgTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsIExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsIE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsIENsYW1wVG9FZGdlV3JhcHBpbmcsIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcsIEludGVycG9sYXRlRGlzY3JldGUsIEZyb250U2lkZSwgVGV4dHVyZSwgVmVjdG9yS2V5ZnJhbWVUcmFjaywgUXVhdGVybmlvbktleWZyYW1lVHJhY2ssIE51bWJlcktleWZyYW1lVHJhY2ssIEJveDMsIFNwaGVyZSwgSW50ZXJwb2xhbnQgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IHRvVHJpYW5nbGVzRHJhd01vZGUgfSBmcm9tIFwiLi4vdXRpbHMvQnVmZmVyR2VvbWV0cnlVdGlscy5qc1wiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi9fcG9seWZpbGwvY29uc3RhbnRzLmpzXCI7XG5jbGFzcyBHTFRGTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgIHRoaXMuZHJhY29Mb2FkZXIgPSBudWxsO1xuICAgIHRoaXMua3R4MkxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5tZXNob3B0RGVjb2RlciA9IG51bGw7XG4gICAgdGhpcy5wbHVnaW5DYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURlRleHR1cmVCYXNpc1VFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGVGV4dHVyZVdlYlBFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGVGV4dHVyZUFWSUZFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzU2hlZW5FeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzVHJhbnNtaXNzaW9uRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1ZvbHVtZUV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNJb3JFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzRW1pc3NpdmVTdHJlbmd0aEV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNTcGVjdWxhckV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNJcmlkZXNjZW5jZUV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNBbmlzb3Ryb3B5RXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURkxpZ2h0c0V4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNZXNob3B0Q29tcHJlc3Npb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWVzaEdwdUluc3RhbmNpbmcocGFyc2VyKTtcbiAgICB9KTtcbiAgfVxuICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzO1xuICAgIGxldCByZXNvdXJjZVBhdGg7XG4gICAgaWYgKHRoaXMucmVzb3VyY2VQYXRoICE9PSBcIlwiKSB7XG4gICAgICByZXNvdXJjZVBhdGggPSB0aGlzLnJlc291cmNlUGF0aDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGF0aCAhPT0gXCJcIikge1xuICAgICAgcmVzb3VyY2VQYXRoID0gdGhpcy5wYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvdXJjZVBhdGggPSBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSh1cmwpO1xuICAgIH1cbiAgICB0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KHVybCk7XG4gICAgY29uc3QgX29uRXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAob25FcnJvcikge1xuICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIH1cbiAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG4gICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcbiAgICB9O1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG4gICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICBsb2FkZXIubG9hZChcbiAgICAgIHVybCxcbiAgICAgIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzY29wZS5wYXJzZShcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICByZXNvdXJjZVBhdGgsXG4gICAgICAgICAgICBmdW5jdGlvbihnbHRmKSB7XG4gICAgICAgICAgICAgIG9uTG9hZChnbHRmKTtcbiAgICAgICAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX29uRXJyb3JcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgX29uRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblByb2dyZXNzLFxuICAgICAgX29uRXJyb3JcbiAgICApO1xuICB9XG4gIHNldERSQUNPTG9hZGVyKGRyYWNvTG9hZGVyKSB7XG4gICAgdGhpcy5kcmFjb0xvYWRlciA9IGRyYWNvTG9hZGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldEREU0xvYWRlcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RIUkVFLkdMVEZMb2FkZXI6IFwiTVNGVF90ZXh0dXJlX2Rkc1wiIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSB1cGRhdGUgdG8gXCJLSFJfdGV4dHVyZV9iYXNpc3VcIi4nKTtcbiAgfVxuICBzZXRLVFgyTG9hZGVyKGt0eDJMb2FkZXIpIHtcbiAgICB0aGlzLmt0eDJMb2FkZXIgPSBrdHgyTG9hZGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldE1lc2hvcHREZWNvZGVyKG1lc2hvcHREZWNvZGVyKSB7XG4gICAgdGhpcy5tZXNob3B0RGVjb2RlciA9IG1lc2hvcHREZWNvZGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlZ2lzdGVyKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucGx1Z2luQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spID09PSAtMSkge1xuICAgICAgdGhpcy5wbHVnaW5DYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHVucmVnaXN0ZXIoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjaykgIT09IC0xKSB7XG4gICAgICB0aGlzLnBsdWdpbkNhbGxiYWNrcy5zcGxpY2UodGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayksIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwYXJzZShkYXRhLCBwYXRoLCBvbkxvYWQsIG9uRXJyb3IpIHtcbiAgICBsZXQganNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0ge307XG4gICAgY29uc3QgcGx1Z2lucyA9IHt9O1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAganNvbiA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIGNvbnN0IG1hZ2ljID0gTG9hZGVyVXRpbHMuZGVjb2RlVGV4dChuZXcgVWludDhBcnJheShkYXRhLnNsaWNlKDAsIDQpKSk7XG4gICAgICBpZiAobWFnaWMgPT09IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9CSU5BUllfR0xURl0gPSBuZXcgR0xURkJpbmFyeUV4dGVuc2lvbihkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBpZiAob25FcnJvcilcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBqc29uID0gSlNPTi5wYXJzZShleHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGXS5jb250ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpzb24gPSBKU09OLnBhcnNlKExvYWRlclV0aWxzLmRlY29kZVRleHQobmV3IFVpbnQ4QXJyYXkoZGF0YSkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAganNvbiA9IGRhdGE7XG4gICAgfVxuICAgIGlmIChqc29uLmFzc2V0ID09PSB2b2lkIDAgfHwganNvbi5hc3NldC52ZXJzaW9uWzBdIDwgMikge1xuICAgICAgaWYgKG9uRXJyb3IpXG4gICAgICAgIG9uRXJyb3IobmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgYXNzZXQuIGdsVEYgdmVyc2lvbnMgPj0yLjAgYXJlIHN1cHBvcnRlZC5cIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgR0xURlBhcnNlcihqc29uLCB7XG4gICAgICBwYXRoOiBwYXRoIHx8IHRoaXMucmVzb3VyY2VQYXRoIHx8IFwiXCIsXG4gICAgICBjcm9zc09yaWdpbjogdGhpcy5jcm9zc09yaWdpbixcbiAgICAgIHJlcXVlc3RIZWFkZXI6IHRoaXMucmVxdWVzdEhlYWRlcixcbiAgICAgIG1hbmFnZXI6IHRoaXMubWFuYWdlcixcbiAgICAgIGt0eDJMb2FkZXI6IHRoaXMua3R4MkxvYWRlcixcbiAgICAgIG1lc2hvcHREZWNvZGVyOiB0aGlzLm1lc2hvcHREZWNvZGVyXG4gICAgfSk7XG4gICAgcGFyc2VyLmZpbGVMb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5DYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMucGx1Z2luQ2FsbGJhY2tzW2ldKHBhcnNlcik7XG4gICAgICBwbHVnaW5zW3BsdWdpbi5uYW1lXSA9IHBsdWdpbjtcbiAgICAgIGV4dGVuc2lvbnNbcGx1Z2luLm5hbWVdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGpzb24uZXh0ZW5zaW9uc1VzZWQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwganNvbi5leHRlbnNpb25zVXNlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBleHRlbnNpb25OYW1lID0ganNvbi5leHRlbnNpb25zVXNlZFtpXTtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uc1JlcXVpcmVkID0ganNvbi5leHRlbnNpb25zUmVxdWlyZWQgfHwgW107XG4gICAgICAgIHN3aXRjaCAoZXh0ZW5zaW9uTmFtZSkge1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUOlxuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSA9IG5ldyBHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTjpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uKGpzb24sIHRoaXMuZHJhY29Mb2FkZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STTpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfTUVTSF9RVUFOVElaQVRJT046XG4gICAgICAgICAgICBleHRlbnNpb25zW2V4dGVuc2lvbk5hbWVdID0gbmV3IEdMVEZNZXNoUXVhbnRpemF0aW9uRXh0ZW5zaW9uKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKGV4dGVuc2lvbk5hbWUpID49IDAgJiYgcGx1Z2luc1tleHRlbnNpb25OYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignVEhSRUUuR0xURkxvYWRlcjogVW5rbm93biBleHRlbnNpb24gXCInICsgZXh0ZW5zaW9uTmFtZSArICdcIi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwYXJzZXIuc2V0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgICBwYXJzZXIuc2V0UGx1Z2lucyhwbHVnaW5zKTtcbiAgICBwYXJzZXIucGFyc2Uob25Mb2FkLCBvbkVycm9yKTtcbiAgfVxuICBwYXJzZUFzeW5jKGRhdGEsIHBhdGgpIHtcbiAgICBjb25zdCBzY29wZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgc2NvcGUucGFyc2UoZGF0YSwgcGF0aCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gR0xURlJlZ2lzdHJ5KCkge1xuICBsZXQgb2JqZWN0cyA9IHt9O1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0c1trZXldO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbihrZXksIG9iamVjdCkge1xuICAgICAgb2JqZWN0c1trZXldID0gb2JqZWN0O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGRlbGV0ZSBvYmplY3RzW2tleV07XG4gICAgfSxcbiAgICByZW1vdmVBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgb2JqZWN0cyA9IHt9O1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IEVYVEVOU0lPTlMgPSB7XG4gIEtIUl9CSU5BUllfR0xURjogXCJLSFJfYmluYXJ5X2dsVEZcIixcbiAgS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT046IFwiS0hSX2RyYWNvX21lc2hfY29tcHJlc3Npb25cIixcbiAgS0hSX0xJR0hUU19QVU5DVFVBTDogXCJLSFJfbGlnaHRzX3B1bmN0dWFsXCIsXG4gIEtIUl9NQVRFUklBTFNfQ0xFQVJDT0FUOiBcIktIUl9tYXRlcmlhbHNfY2xlYXJjb2F0XCIsXG4gIEtIUl9NQVRFUklBTFNfSU9SOiBcIktIUl9tYXRlcmlhbHNfaW9yXCIsXG4gIEtIUl9NQVRFUklBTFNfU0hFRU46IFwiS0hSX21hdGVyaWFsc19zaGVlblwiLFxuICBLSFJfTUFURVJJQUxTX1NQRUNVTEFSOiBcIktIUl9tYXRlcmlhbHNfc3BlY3VsYXJcIixcbiAgS0hSX01BVEVSSUFMU19UUkFOU01JU1NJT046IFwiS0hSX21hdGVyaWFsc190cmFuc21pc3Npb25cIixcbiAgS0hSX01BVEVSSUFMU19JUklERVNDRU5DRTogXCJLSFJfbWF0ZXJpYWxzX2lyaWRlc2NlbmNlXCIsXG4gIEtIUl9NQVRFUklBTFNfQU5JU09UUk9QWTogXCJLSFJfbWF0ZXJpYWxzX2FuaXNvdHJvcHlcIixcbiAgS0hSX01BVEVSSUFMU19VTkxJVDogXCJLSFJfbWF0ZXJpYWxzX3VubGl0XCIsXG4gIEtIUl9NQVRFUklBTFNfVk9MVU1FOiBcIktIUl9tYXRlcmlhbHNfdm9sdW1lXCIsXG4gIEtIUl9URVhUVVJFX0JBU0lTVTogXCJLSFJfdGV4dHVyZV9iYXNpc3VcIixcbiAgS0hSX1RFWFRVUkVfVFJBTlNGT1JNOiBcIktIUl90ZXh0dXJlX3RyYW5zZm9ybVwiLFxuICBLSFJfTUVTSF9RVUFOVElaQVRJT046IFwiS0hSX21lc2hfcXVhbnRpemF0aW9uXCIsXG4gIEtIUl9NQVRFUklBTFNfRU1JU1NJVkVfU1RSRU5HVEg6IFwiS0hSX21hdGVyaWFsc19lbWlzc2l2ZV9zdHJlbmd0aFwiLFxuICBFWFRfVEVYVFVSRV9XRUJQOiBcIkVYVF90ZXh0dXJlX3dlYnBcIixcbiAgRVhUX1RFWFRVUkVfQVZJRjogXCJFWFRfdGV4dHVyZV9hdmlmXCIsXG4gIEVYVF9NRVNIT1BUX0NPTVBSRVNTSU9OOiBcIkVYVF9tZXNob3B0X2NvbXByZXNzaW9uXCIsXG4gIEVYVF9NRVNIX0dQVV9JTlNUQU5DSU5HOiBcIkVYVF9tZXNoX2dwdV9pbnN0YW5jaW5nXCJcbn07XG5jbGFzcyBHTFRGTGlnaHRzRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTElHSFRTX1BVTkNUVUFMO1xuICAgIHRoaXMuY2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICB9XG4gIF9tYXJrRGVmcygpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBub2RlRGVmcyA9IHRoaXMucGFyc2VyLmpzb24ubm9kZXMgfHwgW107XG4gICAgZm9yIChsZXQgbm9kZUluZGV4ID0gMCwgbm9kZUxlbmd0aCA9IG5vZGVEZWZzLmxlbmd0aDsgbm9kZUluZGV4IDwgbm9kZUxlbmd0aDsgbm9kZUluZGV4KyspIHtcbiAgICAgIGNvbnN0IG5vZGVEZWYgPSBub2RlRGVmc1tub2RlSW5kZXhdO1xuICAgICAgaWYgKG5vZGVEZWYuZXh0ZW5zaW9ucyAmJiBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSAmJiBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5saWdodCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHBhcnNlci5fYWRkTm9kZVJlZih0aGlzLmNhY2hlLCBub2RlRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5saWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9sb2FkTGlnaHQobGlnaHRJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gXCJsaWdodDpcIiArIGxpZ2h0SW5kZXg7XG4gICAgbGV0IGRlcGVuZGVuY3kgPSBwYXJzZXIuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoZGVwZW5kZW5jeSlcbiAgICAgIHJldHVybiBkZXBlbmRlbmN5O1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0ganNvbi5leHRlbnNpb25zICYmIGpzb24uZXh0ZW5zaW9uc1t0aGlzLm5hbWVdIHx8IHt9O1xuICAgIGNvbnN0IGxpZ2h0RGVmcyA9IGV4dGVuc2lvbnMubGlnaHRzIHx8IFtdO1xuICAgIGNvbnN0IGxpZ2h0RGVmID0gbGlnaHREZWZzW2xpZ2h0SW5kZXhdO1xuICAgIGxldCBsaWdodE5vZGU7XG4gICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3IoMTY3NzcyMTUpO1xuICAgIGlmIChsaWdodERlZi5jb2xvciAhPT0gdm9pZCAwKVxuICAgICAgY29sb3IuZnJvbUFycmF5KGxpZ2h0RGVmLmNvbG9yKTtcbiAgICBjb25zdCByYW5nZSA9IGxpZ2h0RGVmLnJhbmdlICE9PSB2b2lkIDAgPyBsaWdodERlZi5yYW5nZSA6IDA7XG4gICAgc3dpdGNoIChsaWdodERlZi50eXBlKSB7XG4gICAgICBjYXNlIFwiZGlyZWN0aW9uYWxcIjpcbiAgICAgICAgbGlnaHROb2RlID0gbmV3IERpcmVjdGlvbmFsTGlnaHQoY29sb3IpO1xuICAgICAgICBsaWdodE5vZGUudGFyZ2V0LnBvc2l0aW9uLnNldCgwLCAwLCAtMSk7XG4gICAgICAgIGxpZ2h0Tm9kZS5hZGQobGlnaHROb2RlLnRhcmdldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvaW50XCI6XG4gICAgICAgIGxpZ2h0Tm9kZSA9IG5ldyBQb2ludExpZ2h0KGNvbG9yKTtcbiAgICAgICAgbGlnaHROb2RlLmRpc3RhbmNlID0gcmFuZ2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNwb3RcIjpcbiAgICAgICAgbGlnaHROb2RlID0gbmV3IFNwb3RMaWdodChjb2xvcik7XG4gICAgICAgIGxpZ2h0Tm9kZS5kaXN0YW5jZSA9IHJhbmdlO1xuICAgICAgICBsaWdodERlZi5zcG90ID0gbGlnaHREZWYuc3BvdCB8fCB7fTtcbiAgICAgICAgbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSA9IGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgIT09IHZvaWQgMCA/IGxpZ2h0RGVmLnNwb3QuaW5uZXJDb25lQW5nbGUgOiAwO1xuICAgICAgICBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlID0gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSAhPT0gdm9pZCAwID8gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZSA6IE1hdGguUEkgLyA0O1xuICAgICAgICBsaWdodE5vZGUuYW5nbGUgPSBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlO1xuICAgICAgICBsaWdodE5vZGUucGVudW1icmEgPSAxIC0gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSAvIGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGU7XG4gICAgICAgIGxpZ2h0Tm9kZS50YXJnZXQucG9zaXRpb24uc2V0KDAsIDAsIC0xKTtcbiAgICAgICAgbGlnaHROb2RlLmFkZChsaWdodE5vZGUudGFyZ2V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBVbmV4cGVjdGVkIGxpZ2h0IHR5cGU6IFwiICsgbGlnaHREZWYudHlwZSk7XG4gICAgfVxuICAgIGxpZ2h0Tm9kZS5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgbGlnaHROb2RlLmRlY2F5ID0gMjtcbiAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKGxpZ2h0Tm9kZSwgbGlnaHREZWYpO1xuICAgIGlmIChsaWdodERlZi5pbnRlbnNpdHkgIT09IHZvaWQgMClcbiAgICAgIGxpZ2h0Tm9kZS5pbnRlbnNpdHkgPSBsaWdodERlZi5pbnRlbnNpdHk7XG4gICAgbGlnaHROb2RlLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZShsaWdodERlZi5uYW1lIHx8IFwibGlnaHRfXCIgKyBsaWdodEluZGV4KTtcbiAgICBkZXBlbmRlbmN5ID0gUHJvbWlzZS5yZXNvbHZlKGxpZ2h0Tm9kZSk7XG4gICAgcGFyc2VyLmNhY2hlLmFkZChjYWNoZUtleSwgZGVwZW5kZW5jeSk7XG4gICAgcmV0dXJuIGRlcGVuZGVuY3k7XG4gIH1cbiAgZ2V0RGVwZW5kZW5jeSh0eXBlLCBpbmRleCkge1xuICAgIGlmICh0eXBlICE9PSBcImxpZ2h0XCIpXG4gICAgICByZXR1cm47XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRMaWdodChpbmRleCk7XG4gIH1cbiAgY3JlYXRlTm9kZUF0dGFjaG1lbnQobm9kZUluZGV4KSB7XG4gICAgY29uc3Qgc2VsZjIgPSB0aGlzO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IGpzb24gPSBwYXJzZXIuanNvbjtcbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGNvbnN0IGxpZ2h0RGVmID0gbm9kZURlZi5leHRlbnNpb25zICYmIG5vZGVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdIHx8IHt9O1xuICAgIGNvbnN0IGxpZ2h0SW5kZXggPSBsaWdodERlZi5saWdodDtcbiAgICBpZiAobGlnaHRJbmRleCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRMaWdodChsaWdodEluZGV4KS50aGVuKGZ1bmN0aW9uKGxpZ2h0KSB7XG4gICAgICByZXR1cm4gcGFyc2VyLl9nZXROb2RlUmVmKHNlbGYyLmNhY2hlLCBsaWdodEluZGV4LCBsaWdodCk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNVbmxpdEV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVDtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUoKSB7XG4gICAgcmV0dXJuIE1lc2hCYXNpY01hdGVyaWFsO1xuICB9XG4gIGV4dGVuZFBhcmFtcyhtYXRlcmlhbFBhcmFtcywgbWF0ZXJpYWxEZWYsIHBhcnNlcikge1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5jb2xvciA9IG5ldyBDb2xvcigxLCAxLCAxKTtcbiAgICBtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gMTtcbiAgICBjb25zdCBtZXRhbGxpY1JvdWdobmVzcyA9IG1hdGVyaWFsRGVmLnBick1ldGFsbGljUm91Z2huZXNzO1xuICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yKSkge1xuICAgICAgICBjb25zdCBhcnJheSA9IG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcjtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuY29sb3IuZnJvbUFycmF5KGFycmF5KTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IGFycmF5WzNdO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvclRleHR1cmUsIDMwMDEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzRW1pc3NpdmVTdHJlbmd0aEV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19FTUlTU0lWRV9TVFJFTkdUSDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IGVtaXNzaXZlU3RyZW5ndGggPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0uZW1pc3NpdmVTdHJlbmd0aDtcbiAgICBpZiAoZW1pc3NpdmVTdHJlbmd0aCAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZUludGVuc2l0eSA9IGVtaXNzaXZlU3RyZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0NsZWFyY29hdEV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19DTEVBUkNPQVQ7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXRGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuY2xlYXJjb2F0ID0gZXh0ZW5zaW9uLmNsZWFyY29hdEZhY3RvcjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXRUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJjbGVhcmNvYXRNYXBcIiwgZXh0ZW5zaW9uLmNsZWFyY29hdFRleHR1cmUpKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuY2xlYXJjb2F0Um91Z2huZXNzID0gZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc0ZhY3RvcjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJjbGVhcmNvYXRSb3VnaG5lc3NNYXBcIiwgZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUpKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJjbGVhcmNvYXROb3JtYWxNYXBcIiwgZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUpKTtcbiAgICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZS5zY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUuc2NhbGU7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdE5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoc2NhbGUsIHNjYWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzSXJpZGVzY2VuY2VFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfSVJJREVTQ0VOQ0U7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZUZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZSA9IGV4dGVuc2lvbi5pcmlkZXNjZW5jZUZhY3RvcjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImlyaWRlc2NlbmNlTWFwXCIsIGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRleHR1cmUpKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZUlvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZUlPUiA9IGV4dGVuc2lvbi5pcmlkZXNjZW5jZUlvcjtcbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgPT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9IFsxMDAsIDQwMF07XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbMF0gPSBleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bSAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlWzFdID0gZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICBwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJpcmlkZXNjZW5jZVRoaWNrbmVzc01hcFwiLCBleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NUZXh0dXJlKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzU2hlZW5FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfU0hFRU47XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5zaGVlbkNvbG9yID0gbmV3IENvbG9yKDAsIDAsIDApO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuUm91Z2huZXNzID0gMDtcbiAgICBtYXRlcmlhbFBhcmFtcy5zaGVlbiA9IDE7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24uc2hlZW5Db2xvckZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5zaGVlbkNvbG9yLmZyb21BcnJheShleHRlbnNpb24uc2hlZW5Db2xvckZhY3Rvcik7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Sb3VnaG5lc3MgPSBleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NGYWN0b3I7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uc2hlZW5Db2xvclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInNoZWVuQ29sb3JNYXBcIiwgZXh0ZW5zaW9uLnNoZWVuQ29sb3JUZXh0dXJlLCAzMDAxKSk7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJzaGVlblJvdWdobmVzc01hcFwiLCBleHRlbnNpb24uc2hlZW5Sb3VnaG5lc3NUZXh0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19UUkFOU01JU1NJT047XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi50cmFuc21pc3Npb25GYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMudHJhbnNtaXNzaW9uID0gZXh0ZW5zaW9uLnRyYW5zbWlzc2lvbkZhY3RvcjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi50cmFuc21pc3Npb25UZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJ0cmFuc21pc3Npb25NYXBcIiwgZXh0ZW5zaW9uLnRyYW5zbWlzc2lvblRleHR1cmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzVm9sdW1lRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1ZPTFVNRTtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy50aGlja25lc3MgPSBleHRlbnNpb24udGhpY2tuZXNzRmFjdG9yICE9PSB2b2lkIDAgPyBleHRlbnNpb24udGhpY2tuZXNzRmFjdG9yIDogMDtcbiAgICBpZiAoZXh0ZW5zaW9uLnRoaWNrbmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInRoaWNrbmVzc01hcFwiLCBleHRlbnNpb24udGhpY2tuZXNzVGV4dHVyZSkpO1xuICAgIH1cbiAgICBtYXRlcmlhbFBhcmFtcy5hdHRlbnVhdGlvbkRpc3RhbmNlID0gZXh0ZW5zaW9uLmF0dGVudWF0aW9uRGlzdGFuY2UgfHwgSW5maW5pdHk7XG4gICAgY29uc3QgY29sb3JBcnJheSA9IGV4dGVuc2lvbi5hdHRlbnVhdGlvbkNvbG9yIHx8IFsxLCAxLCAxXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5hdHRlbnVhdGlvbkNvbG9yID0gbmV3IENvbG9yKGNvbG9yQXJyYXlbMF0sIGNvbG9yQXJyYXlbMV0sIGNvbG9yQXJyYXlbMl0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0lvckV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19JT1I7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5pb3IgPSBleHRlbnNpb24uaW9yICE9PSB2b2lkIDAgPyBleHRlbnNpb24uaW9yIDogMS41O1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1NwZWN1bGFyRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1NQRUNVTEFSO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNwZWN1bGFySW50ZW5zaXR5ID0gZXh0ZW5zaW9uLnNwZWN1bGFyRmFjdG9yICE9PSB2b2lkIDAgPyBleHRlbnNpb24uc3BlY3VsYXJGYWN0b3IgOiAxO1xuICAgIGlmIChleHRlbnNpb24uc3BlY3VsYXJUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJzcGVjdWxhckludGVuc2l0eU1hcFwiLCBleHRlbnNpb24uc3BlY3VsYXJUZXh0dXJlKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yQXJyYXkgPSBleHRlbnNpb24uc3BlY3VsYXJDb2xvckZhY3RvciB8fCBbMSwgMSwgMV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuc3BlY3VsYXJDb2xvciA9IG5ldyBDb2xvcihjb2xvckFycmF5WzBdLCBjb2xvckFycmF5WzFdLCBjb2xvckFycmF5WzJdKTtcbiAgICBpZiAoZXh0ZW5zaW9uLnNwZWN1bGFyQ29sb3JUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChcbiAgICAgICAgcGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic3BlY3VsYXJDb2xvck1hcFwiLCBleHRlbnNpb24uc3BlY3VsYXJDb2xvclRleHR1cmUsIDMwMDEpXG4gICAgICAgIC8vIHNSR0JFbmNvZGluZ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzQW5pc290cm9weUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19BTklTT1RST1BZO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24uYW5pc290cm9weVN0cmVuZ3RoICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmFuaXNvdHJvcHkgPSBleHRlbnNpb24uYW5pc290cm9weVN0cmVuZ3RoO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmFuaXNvdHJvcHlSb3RhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5hbmlzb3Ryb3B5Um90YXRpb24gPSBleHRlbnNpb24uYW5pc290cm9weVJvdGF0aW9uO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmFuaXNvdHJvcHlUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJhbmlzb3Ryb3B5TWFwXCIsIGV4dGVuc2lvbi5hbmlzb3Ryb3B5VGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9CQVNJU1U7XG4gIH1cbiAgbG9hZFRleHR1cmUodGV4dHVyZUluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgaWYgKCF0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgIXRleHR1cmVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGV4dHVyZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgY29uc3QgbG9hZGVyID0gcGFyc2VyLm9wdGlvbnMua3R4MkxvYWRlcjtcbiAgICBpZiAoIWxvYWRlcikge1xuICAgICAgaWYgKGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YodGhpcy5uYW1lKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IHNldEtUWDJMb2FkZXIgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgS1RYMiB0ZXh0dXJlc1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlSW1hZ2UodGV4dHVyZUluZGV4LCBleHRlbnNpb24uc291cmNlLCBsb2FkZXIpO1xuICB9XG59XG5jbGFzcyBHTFRGVGV4dHVyZVdlYlBFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9URVhUVVJFX1dFQlA7XG4gICAgdGhpcy5pc1N1cHBvcnRlZCA9IG51bGw7XG4gIH1cbiAgbG9hZFRleHR1cmUodGV4dHVyZUluZGV4KSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZTtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBpZiAoIXRleHR1cmVEZWYuZXh0ZW5zaW9ucyB8fCAhdGV4dHVyZURlZi5leHRlbnNpb25zW25hbWVdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGV4dHVyZURlZi5leHRlbnNpb25zW25hbWVdO1xuICAgIGNvbnN0IHNvdXJjZSA9IGpzb24uaW1hZ2VzW2V4dGVuc2lvbi5zb3VyY2VdO1xuICAgIGxldCBsb2FkZXIgPSBwYXJzZXIudGV4dHVyZUxvYWRlcjtcbiAgICBpZiAoc291cmNlLnVyaSkge1xuICAgICAgY29uc3QgaGFuZGxlciA9IHBhcnNlci5vcHRpb25zLm1hbmFnZXIuZ2V0SGFuZGxlcihzb3VyY2UudXJpKTtcbiAgICAgIGlmIChoYW5kbGVyICE9PSBudWxsKVxuICAgICAgICBsb2FkZXIgPSBoYW5kbGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kZXRlY3RTdXBwb3J0KCkudGhlbihmdW5jdGlvbihpc1N1cHBvcnRlZCkge1xuICAgICAgaWYgKGlzU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlSW1hZ2UodGV4dHVyZUluZGV4LCBleHRlbnNpb24uc291cmNlLCBsb2FkZXIpO1xuICAgICAgaWYgKGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YobmFtZSkgPj0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBXZWJQIHJlcXVpcmVkIGJ5IGFzc2V0IGJ1dCB1bnN1cHBvcnRlZC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCk7XG4gICAgfSk7XG4gIH1cbiAgZGV0ZWN0U3VwcG9ydCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltYWdlLnNyYyA9IFwiZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCxVa2xHUmlJQUFBQlhSVUpRVmxBNElCWUFBQUF3QVFDZEFTb0JBQUVBRHNEK0phUUFBM0FBQUFBQVwiO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVzb2x2ZShpbWFnZS5oZWlnaHQgPT09IDEpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzU3VwcG9ydGVkO1xuICB9XG59XG5jbGFzcyBHTFRGVGV4dHVyZUFWSUZFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9URVhUVVJFX0FWSUY7XG4gICAgdGhpcy5pc1N1cHBvcnRlZCA9IG51bGw7XG4gIH1cbiAgbG9hZFRleHR1cmUodGV4dHVyZUluZGV4KSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZTtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBpZiAoIXRleHR1cmVEZWYuZXh0ZW5zaW9ucyB8fCAhdGV4dHVyZURlZi5leHRlbnNpb25zW25hbWVdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGV4dHVyZURlZi5leHRlbnNpb25zW25hbWVdO1xuICAgIGNvbnN0IHNvdXJjZSA9IGpzb24uaW1hZ2VzW2V4dGVuc2lvbi5zb3VyY2VdO1xuICAgIGxldCBsb2FkZXIgPSBwYXJzZXIudGV4dHVyZUxvYWRlcjtcbiAgICBpZiAoc291cmNlLnVyaSkge1xuICAgICAgY29uc3QgaGFuZGxlciA9IHBhcnNlci5vcHRpb25zLm1hbmFnZXIuZ2V0SGFuZGxlcihzb3VyY2UudXJpKTtcbiAgICAgIGlmIChoYW5kbGVyICE9PSBudWxsKVxuICAgICAgICBsb2FkZXIgPSBoYW5kbGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kZXRlY3RTdXBwb3J0KCkudGhlbihmdW5jdGlvbihpc1N1cHBvcnRlZCkge1xuICAgICAgaWYgKGlzU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlSW1hZ2UodGV4dHVyZUluZGV4LCBleHRlbnNpb24uc291cmNlLCBsb2FkZXIpO1xuICAgICAgaWYgKGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YobmFtZSkgPj0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBBVklGIHJlcXVpcmVkIGJ5IGFzc2V0IGJ1dCB1bnN1cHBvcnRlZC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCk7XG4gICAgfSk7XG4gIH1cbiAgZGV0ZWN0U3VwcG9ydCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltYWdlLnNyYyA9IFwiZGF0YTppbWFnZS9hdmlmO2Jhc2U2NCxBQUFBSUdaMGVYQmhkbWxtQUFBQUFHRjJhV1p0YVdZeGJXbGhaazFCTVVJQUFBRHliV1YwWVFBQUFBQUFBQUFvYUdSc2NnQUFBQUFBQUFBQWNHbGpkQUFBQUFBQUFBQUFBQUFBQUd4cFltRjJhV1lBQUFBQURuQnBkRzBBQUFBQUFBRUFBQUFlYVd4dll3QUFBQUJFQUFBQkFBRUFBQUFCQUFBQkdnQUFBQmNBQUFBb2FXbHVaZ0FBQUFBQUFRQUFBQnBwYm1abEFnQUFBQUFCQUFCaGRqQXhRMjlzYjNJQUFBQUFhbWx3Y25BQUFBQkxhWEJqYndBQUFCUnBjM0JsQUFBQUFBQUFBQUVBQUFBQkFBQUFFSEJwZUdrQUFBQUFBd2dJQ0FBQUFBeGhkakZEZ1FBTUFBQUFBQk5qYjJ4eWJtTnNlQUFDQUFJQUJvQUFBQUFYYVhCdFlRQUFBQUFBQUFBQkFBRUVBUUtEQkFBQUFCOXRaR0YwRWdBS0NCZ0FCb2dRRURRZ01na1FBQUFBQjhkU0xmST1cIjtcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlc29sdmUoaW1hZ2UuaGVpZ2h0ID09PSAxKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc1N1cHBvcnRlZDtcbiAgfVxufVxuY2xhc3MgR0xURk1lc2hvcHRDb21wcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX01FU0hPUFRfQ09NUFJFU1NJT047XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gIH1cbiAgbG9hZEJ1ZmZlclZpZXcoaW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5wYXJzZXIuanNvbjtcbiAgICBjb25zdCBidWZmZXJWaWV3ID0ganNvbi5idWZmZXJWaWV3c1tpbmRleF07XG4gICAgaWYgKGJ1ZmZlclZpZXcuZXh0ZW5zaW9ucyAmJiBidWZmZXJWaWV3LmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgY29uc3QgZXh0ZW5zaW9uRGVmID0gYnVmZmVyVmlldy5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgICBjb25zdCBidWZmZXIgPSB0aGlzLnBhcnNlci5nZXREZXBlbmRlbmN5KFwiYnVmZmVyXCIsIGV4dGVuc2lvbkRlZi5idWZmZXIpO1xuICAgICAgY29uc3QgZGVjb2RlciA9IHRoaXMucGFyc2VyLm9wdGlvbnMubWVzaG9wdERlY29kZXI7XG4gICAgICBpZiAoIWRlY29kZXIgfHwgIWRlY29kZXIuc3VwcG9ydGVkKSB7XG4gICAgICAgIGlmIChqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKHRoaXMubmFtZSkgPj0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IHNldE1lc2hvcHREZWNvZGVyIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBsb2FkaW5nIGNvbXByZXNzZWQgZmlsZXNcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXIudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IGV4dGVuc2lvbkRlZi5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBleHRlbnNpb25EZWYuYnl0ZUxlbmd0aCB8fCAwO1xuICAgICAgICBjb25zdCBjb3VudCA9IGV4dGVuc2lvbkRlZi5jb3VudDtcbiAgICAgICAgY29uc3Qgc3RyaWRlID0gZXh0ZW5zaW9uRGVmLmJ5dGVTdHJpZGU7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KHJlcywgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgIGlmIChkZWNvZGVyLmRlY29kZUdsdGZCdWZmZXJBc3luYykge1xuICAgICAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZUdsdGZCdWZmZXJBc3luYyhjb3VudCwgc3RyaWRlLCBzb3VyY2UsIGV4dGVuc2lvbkRlZi5tb2RlLCBleHRlbnNpb25EZWYuZmlsdGVyKS50aGVuKGZ1bmN0aW9uKHJlczIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMyLmJ1ZmZlcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVjb2Rlci5yZWFkeS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5QnVmZmVyKGNvdW50ICogc3RyaWRlKTtcbiAgICAgICAgICAgIGRlY29kZXIuZGVjb2RlR2x0ZkJ1ZmZlcihcbiAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KSxcbiAgICAgICAgICAgICAgY291bnQsXG4gICAgICAgICAgICAgIHN0cmlkZSxcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICBleHRlbnNpb25EZWYubW9kZSxcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uRGVmLmZpbHRlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEdMVEZNZXNoR3B1SW5zdGFuY2luZyB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX01FU0hfR1BVX0lOU1RBTkNJTkc7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gIH1cbiAgY3JlYXRlTm9kZU1lc2gobm9kZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMucGFyc2VyLmpzb247XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBpZiAoIW5vZGVEZWYuZXh0ZW5zaW9ucyB8fCAhbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0gfHwgbm9kZURlZi5tZXNoID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBtZXNoRGVmID0ganNvbi5tZXNoZXNbbm9kZURlZi5tZXNoXTtcbiAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBtZXNoRGVmLnByaW1pdGl2ZXMpIHtcbiAgICAgIGlmIChwcmltaXRpdmUubW9kZSAhPT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFUyAmJiBwcmltaXRpdmUubW9kZSAhPT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX1NUUklQICYmIHByaW1pdGl2ZS5tb2RlICE9PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfRkFOICYmIHByaW1pdGl2ZS5tb2RlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbkRlZiA9IG5vZGVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXNEZWYgPSBleHRlbnNpb25EZWYuYXR0cmlidXRlcztcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXNEZWYpIHtcbiAgICAgIHBlbmRpbmcucHVzaChcbiAgICAgICAgdGhpcy5wYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIGF0dHJpYnV0ZXNEZWZba2V5XSkudGhlbigoYWNjZXNzb3IpID0+IHtcbiAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSBhY2Nlc3NvcjtcbiAgICAgICAgICByZXR1cm4gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHBlbmRpbmcubGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBlbmRpbmcucHVzaCh0aGlzLnBhcnNlci5jcmVhdGVOb2RlTWVzaChub2RlSW5kZXgpKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbigocmVzdWx0cykgPT4ge1xuICAgICAgY29uc3Qgbm9kZU9iamVjdCA9IHJlc3VsdHMucG9wKCk7XG4gICAgICBjb25zdCBtZXNoZXMgPSBub2RlT2JqZWN0LmlzR3JvdXAgPyBub2RlT2JqZWN0LmNoaWxkcmVuIDogW25vZGVPYmplY3RdO1xuICAgICAgY29uc3QgY291bnQgPSByZXN1bHRzWzBdLmNvdW50O1xuICAgICAgY29uc3QgaW5zdGFuY2VkTWVzaGVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IG1lc2ggb2YgbWVzaGVzKSB7XG4gICAgICAgIGNvbnN0IG0gPSBuZXcgTWF0cml4NCgpO1xuICAgICAgICBjb25zdCBwID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgY29uc3QgcSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgICAgIGNvbnN0IHMgPSBuZXcgVmVjdG9yMygxLCAxLCAxKTtcbiAgICAgICAgY29uc3QgaW5zdGFuY2VkTWVzaCA9IG5ldyBJbnN0YW5jZWRNZXNoKG1lc2guZ2VvbWV0cnksIG1lc2gubWF0ZXJpYWwsIGNvdW50KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuVFJBTlNMQVRJT04pIHtcbiAgICAgICAgICAgIHAuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGVzLlRSQU5TTEFUSU9OLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuUk9UQVRJT04pIHtcbiAgICAgICAgICAgIHEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGVzLlJPVEFUSU9OLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuU0NBTEUpIHtcbiAgICAgICAgICAgIHMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGVzLlNDQUxFLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zdGFuY2VkTWVzaC5zZXRNYXRyaXhBdChpLCBtLmNvbXBvc2UocCwgcSwgcykpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgIT09IFwiVFJBTlNMQVRJT05cIiAmJiBhdHRyaWJ1dGVOYW1lICE9PSBcIlJPVEFUSU9OXCIgJiYgYXR0cmlidXRlTmFtZSAhPT0gXCJTQ0FMRVwiKSB7XG4gICAgICAgICAgICBtZXNoLmdlb21ldHJ5LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbChpbnN0YW5jZWRNZXNoLCBtZXNoKTtcbiAgICAgICAgdGhpcy5wYXJzZXIuYXNzaWduRmluYWxNYXRlcmlhbChpbnN0YW5jZWRNZXNoKTtcbiAgICAgICAgaW5zdGFuY2VkTWVzaGVzLnB1c2goaW5zdGFuY2VkTWVzaCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZU9iamVjdC5pc0dyb3VwKSB7XG4gICAgICAgIG5vZGVPYmplY3QuY2xlYXIoKTtcbiAgICAgICAgbm9kZU9iamVjdC5hZGQoLi4uaW5zdGFuY2VkTWVzaGVzKTtcbiAgICAgICAgcmV0dXJuIG5vZGVPYmplY3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zdGFuY2VkTWVzaGVzWzBdO1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQyA9IFwiZ2xURlwiO1xuY29uc3QgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIID0gMTI7XG5jb25zdCBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTID0geyBKU09OOiAxMzEzODIxNTE0LCBCSU46IDUxMzA1NjIgfTtcbmNsYXNzIEdMVEZCaW5hcnlFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEY7XG4gICAgdGhpcy5jb250ZW50ID0gbnVsbDtcbiAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgIGNvbnN0IGhlYWRlclZpZXcgPSBuZXcgRGF0YVZpZXcoZGF0YSwgMCwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIKTtcbiAgICB0aGlzLmhlYWRlciA9IHtcbiAgICAgIG1hZ2ljOiBMb2FkZXJVdGlscy5kZWNvZGVUZXh0KG5ldyBVaW50OEFycmF5KGRhdGEuc2xpY2UoMCwgNCkpKSxcbiAgICAgIHZlcnNpb246IGhlYWRlclZpZXcuZ2V0VWludDMyKDQsIHRydWUpLFxuICAgICAgbGVuZ3RoOiBoZWFkZXJWaWV3LmdldFVpbnQzMig4LCB0cnVlKVxuICAgIH07XG4gICAgaWYgKHRoaXMuaGVhZGVyLm1hZ2ljICE9PSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9NQUdJQykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgZ2xURi1CaW5hcnkgaGVhZGVyLlwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaGVhZGVyLnZlcnNpb24gPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBMZWdhY3kgYmluYXJ5IGZpbGUgZGV0ZWN0ZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjaHVua0NvbnRlbnRzTGVuZ3RoID0gdGhpcy5oZWFkZXIubGVuZ3RoIC0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIO1xuICAgIGNvbnN0IGNodW5rVmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLCBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEgpO1xuICAgIGxldCBjaHVua0luZGV4ID0gMDtcbiAgICB3aGlsZSAoY2h1bmtJbmRleCA8IGNodW5rQ29udGVudHNMZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNodW5rTGVuZ3RoID0gY2h1bmtWaWV3LmdldFVpbnQzMihjaHVua0luZGV4LCB0cnVlKTtcbiAgICAgIGNodW5rSW5kZXggKz0gNDtcbiAgICAgIGNvbnN0IGNodW5rVHlwZSA9IGNodW5rVmlldy5nZXRVaW50MzIoY2h1bmtJbmRleCwgdHJ1ZSk7XG4gICAgICBjaHVua0luZGV4ICs9IDQ7XG4gICAgICBpZiAoY2h1bmtUeXBlID09PSBCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTLkpTT04pIHtcbiAgICAgICAgY29uc3QgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIICsgY2h1bmtJbmRleCwgY2h1bmtMZW5ndGgpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBMb2FkZXJVdGlscy5kZWNvZGVUZXh0KGNvbnRlbnRBcnJheSk7XG4gICAgICB9IGVsc2UgaWYgKGNodW5rVHlwZSA9PT0gQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUy5CSU4pIHtcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCArIGNodW5rSW5kZXg7XG4gICAgICAgIHRoaXMuYm9keSA9IGRhdGEuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGNodW5rTGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGNodW5rSW5kZXggKz0gY2h1bmtMZW5ndGg7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IEpTT04gY29udGVudCBub3QgZm91bmQuXCIpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgR0xURkRyYWNvTWVzaENvbXByZXNzaW9uRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IoanNvbiwgZHJhY29Mb2FkZXIpIHtcbiAgICBpZiAoIWRyYWNvTG9hZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBObyBEUkFDT0xvYWRlciBpbnN0YW5jZSBwcm92aWRlZC5cIik7XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT047XG4gICAgdGhpcy5qc29uID0ganNvbjtcbiAgICB0aGlzLmRyYWNvTG9hZGVyID0gZHJhY29Mb2FkZXI7XG4gICAgdGhpcy5kcmFjb0xvYWRlci5wcmVsb2FkKCk7XG4gIH1cbiAgZGVjb2RlUHJpbWl0aXZlKHByaW1pdGl2ZSwgcGFyc2VyKSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBkcmFjb0xvYWRlciA9IHRoaXMuZHJhY29Mb2FkZXI7XG4gICAgY29uc3QgYnVmZmVyVmlld0luZGV4ID0gcHJpbWl0aXZlLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5idWZmZXJWaWV3O1xuICAgIGNvbnN0IGdsdGZBdHRyaWJ1dGVNYXAgPSBwcmltaXRpdmUuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgdGhyZWVBdHRyaWJ1dGVNYXAgPSB7fTtcbiAgICBjb25zdCBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwID0ge307XG4gICAgY29uc3QgYXR0cmlidXRlVHlwZU1hcCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBnbHRmQXR0cmlidXRlTWFwKSB7XG4gICAgICBjb25zdCB0aHJlZUF0dHJpYnV0ZU5hbWUgPSBBVFRSSUJVVEVTW2F0dHJpYnV0ZU5hbWVdIHx8IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHRocmVlQXR0cmlidXRlTWFwW3RocmVlQXR0cmlidXRlTmFtZV0gPSBnbHRmQXR0cmlidXRlTWFwW2F0dHJpYnV0ZU5hbWVdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gcHJpbWl0aXZlLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IHRocmVlQXR0cmlidXRlTmFtZSA9IEFUVFJJQlVURVNbYXR0cmlidXRlTmFtZV0gfHwgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGdsdGZBdHRyaWJ1dGVNYXBbYXR0cmlidXRlTmFtZV0gIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NvckRlZiA9IGpzb24uYWNjZXNzb3JzW3ByaW1pdGl2ZS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdXTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50VHlwZSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlXTtcbiAgICAgICAgYXR0cmlidXRlVHlwZU1hcFt0aHJlZUF0dHJpYnV0ZU5hbWVdID0gY29tcG9uZW50VHlwZS5uYW1lO1xuICAgICAgICBhdHRyaWJ1dGVOb3JtYWxpemVkTWFwW3RocmVlQXR0cmlidXRlTmFtZV0gPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIGJ1ZmZlclZpZXdJbmRleCkudGhlbihmdW5jdGlvbihidWZmZXJWaWV3KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICBkcmFjb0xvYWRlci5kZWNvZGVEcmFjb0ZpbGUoXG4gICAgICAgICAgYnVmZmVyVmlldyxcbiAgICAgICAgICBmdW5jdGlvbihnZW9tZXRyeSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXBbYXR0cmlidXRlTmFtZV07XG4gICAgICAgICAgICAgIGlmIChub3JtYWxpemVkICE9PSB2b2lkIDApXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShnZW9tZXRyeSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aHJlZUF0dHJpYnV0ZU1hcCxcbiAgICAgICAgICBhdHRyaWJ1dGVUeXBlTWFwXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgR0xURlRleHR1cmVUcmFuc2Zvcm1FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STTtcbiAgfVxuICBleHRlbmRUZXh0dXJlKHRleHR1cmUsIHRyYW5zZm9ybSkge1xuICAgIGlmICgodHJhbnNmb3JtLnRleENvb3JkID09PSB2b2lkIDAgfHwgdHJhbnNmb3JtLnRleENvb3JkID09PSB0ZXh0dXJlLmNoYW5uZWwpICYmIHRyYW5zZm9ybS5vZmZzZXQgPT09IHZvaWQgMCAmJiB0cmFuc2Zvcm0ucm90YXRpb24gPT09IHZvaWQgMCAmJiB0cmFuc2Zvcm0uc2NhbGUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfVxuICAgIHRleHR1cmUgPSB0ZXh0dXJlLmNsb25lKCk7XG4gICAgaWYgKHRyYW5zZm9ybS50ZXhDb29yZCAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLmNoYW5uZWwgPSB0cmFuc2Zvcm0udGV4Q29vcmQ7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm0ub2Zmc2V0ICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUub2Zmc2V0LmZyb21BcnJheSh0cmFuc2Zvcm0ub2Zmc2V0KTtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybS5yb3RhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLnJvdGF0aW9uID0gdHJhbnNmb3JtLnJvdGF0aW9uO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgIHRleHR1cmUucmVwZWF0LmZyb21BcnJheSh0cmFuc2Zvcm0uc2NhbGUpO1xuICAgIH1cbiAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbiAgfVxufVxuY2xhc3MgR0xURk1lc2hRdWFudGl6YXRpb25FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NRVNIX1FVQU5USVpBVElPTjtcbiAgfVxufVxuY2xhc3MgR0xURkN1YmljU3BsaW5lSW50ZXJwb2xhbnQgZXh0ZW5kcyBJbnRlcnBvbGFudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKTtcbiAgfVxuICBjb3B5U2FtcGxlVmFsdWVfKGluZGV4KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsIHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLCB2YWx1ZVNpemUgPSB0aGlzLnZhbHVlU2l6ZSwgb2Zmc2V0ID0gaW5kZXggKiB2YWx1ZVNpemUgKiAzICsgdmFsdWVTaXplO1xuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSB2YWx1ZVNpemU7IGkrKykge1xuICAgICAgcmVzdWx0W2ldID0gdmFsdWVzW29mZnNldCArIGldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXI7XG4gICAgY29uc3QgdmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXM7XG4gICAgY29uc3Qgc3RyaWRlID0gdGhpcy52YWx1ZVNpemU7XG4gICAgY29uc3Qgc3RyaWRlMiA9IHN0cmlkZSAqIDI7XG4gICAgY29uc3Qgc3RyaWRlMyA9IHN0cmlkZSAqIDM7XG4gICAgY29uc3QgdGQgPSB0MSAtIHQwO1xuICAgIGNvbnN0IHAgPSAodCAtIHQwKSAvIHRkO1xuICAgIGNvbnN0IHBwID0gcCAqIHA7XG4gICAgY29uc3QgcHBwID0gcHAgKiBwO1xuICAgIGNvbnN0IG9mZnNldDEgPSBpMSAqIHN0cmlkZTM7XG4gICAgY29uc3Qgb2Zmc2V0MCA9IG9mZnNldDEgLSBzdHJpZGUzO1xuICAgIGNvbnN0IHMyID0gLTIgKiBwcHAgKyAzICogcHA7XG4gICAgY29uc3QgczMgPSBwcHAgLSBwcDtcbiAgICBjb25zdCBzMCA9IDEgLSBzMjtcbiAgICBjb25zdCBzMSA9IHMzIC0gcHAgKyBwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpICE9PSBzdHJpZGU7IGkrKykge1xuICAgICAgY29uc3QgcDAgPSB2YWx1ZXNbb2Zmc2V0MCArIGkgKyBzdHJpZGVdO1xuICAgICAgY29uc3QgbTAgPSB2YWx1ZXNbb2Zmc2V0MCArIGkgKyBzdHJpZGUyXSAqIHRkO1xuICAgICAgY29uc3QgcDEgPSB2YWx1ZXNbb2Zmc2V0MSArIGkgKyBzdHJpZGVdO1xuICAgICAgY29uc3QgbTEgPSB2YWx1ZXNbb2Zmc2V0MSArIGldICogdGQ7XG4gICAgICByZXN1bHRbaV0gPSBzMCAqIHAwICsgczEgKiBtMCArIHMyICogcDEgKyBzMyAqIG0xO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5jb25zdCBfcSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5jbGFzcyBHTFRGQ3ViaWNTcGxpbmVRdWF0ZXJuaW9uSW50ZXJwb2xhbnQgZXh0ZW5kcyBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCB7XG4gIGludGVycG9sYXRlXyhpMSwgdDAsIHQsIHQxKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuaW50ZXJwb2xhdGVfKGkxLCB0MCwgdCwgdDEpO1xuICAgIF9xLmZyb21BcnJheShyZXN1bHQpLm5vcm1hbGl6ZSgpLnRvQXJyYXkocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5jb25zdCBXRUJHTF9DT05TVEFOVFMgPSB7XG4gIEZMT0FUOiA1MTI2LFxuICAvL0ZMT0FUX01BVDI6IDM1Njc0LFxuICBGTE9BVF9NQVQzOiAzNTY3NSxcbiAgRkxPQVRfTUFUNDogMzU2NzYsXG4gIEZMT0FUX1ZFQzI6IDM1NjY0LFxuICBGTE9BVF9WRUMzOiAzNTY2NSxcbiAgRkxPQVRfVkVDNDogMzU2NjYsXG4gIExJTkVBUjogOTcyOSxcbiAgUkVQRUFUOiAxMDQ5NyxcbiAgU0FNUExFUl8yRDogMzU2NzgsXG4gIFBPSU5UUzogMCxcbiAgTElORVM6IDEsXG4gIExJTkVfTE9PUDogMixcbiAgTElORV9TVFJJUDogMyxcbiAgVFJJQU5HTEVTOiA0LFxuICBUUklBTkdMRV9TVFJJUDogNSxcbiAgVFJJQU5HTEVfRkFOOiA2LFxuICBVTlNJR05FRF9CWVRFOiA1MTIxLFxuICBVTlNJR05FRF9TSE9SVDogNTEyM1xufTtcbmNvbnN0IFdFQkdMX0NPTVBPTkVOVF9UWVBFUyA9IHtcbiAgNTEyMDogSW50OEFycmF5LFxuICA1MTIxOiBVaW50OEFycmF5LFxuICA1MTIyOiBJbnQxNkFycmF5LFxuICA1MTIzOiBVaW50MTZBcnJheSxcbiAgNTEyNTogVWludDMyQXJyYXksXG4gIDUxMjY6IEZsb2F0MzJBcnJheVxufTtcbmNvbnN0IFdFQkdMX0ZJTFRFUlMgPSB7XG4gIDk3Mjg6IE5lYXJlc3RGaWx0ZXIsXG4gIDk3Mjk6IExpbmVhckZpbHRlcixcbiAgOTk4NDogTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIsXG4gIDk5ODU6IExpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIsXG4gIDk5ODY6IE5lYXJlc3RNaXBtYXBMaW5lYXJGaWx0ZXIsXG4gIDk5ODc6IExpbmVhck1pcG1hcExpbmVhckZpbHRlclxufTtcbmNvbnN0IFdFQkdMX1dSQVBQSU5HUyA9IHtcbiAgMzMwNzE6IENsYW1wVG9FZGdlV3JhcHBpbmcsXG4gIDMzNjQ4OiBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nLFxuICAxMDQ5NzogUmVwZWF0V3JhcHBpbmdcbn07XG5jb25zdCBXRUJHTF9UWVBFX1NJWkVTID0ge1xuICBTQ0FMQVI6IDEsXG4gIFZFQzI6IDIsXG4gIFZFQzM6IDMsXG4gIFZFQzQ6IDQsXG4gIE1BVDI6IDQsXG4gIE1BVDM6IDksXG4gIE1BVDQ6IDE2XG59O1xuY29uc3QgQVRUUklCVVRFUyA9IHtcbiAgUE9TSVRJT046IFwicG9zaXRpb25cIixcbiAgTk9STUFMOiBcIm5vcm1hbFwiLFxuICBUQU5HRU5UOiBcInRhbmdlbnRcIixcbiAgLy8gdXYgPT4gdXYxLCA0IHV2IGNoYW5uZWxzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yNTk0M1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL3B1bGwvMjU3ODhcbiAgLi4udmVyc2lvbiA+PSAxNTIgPyB7XG4gICAgVEVYQ09PUkRfMDogXCJ1dlwiLFxuICAgIFRFWENPT1JEXzE6IFwidXYxXCIsXG4gICAgVEVYQ09PUkRfMjogXCJ1djJcIixcbiAgICBURVhDT09SRF8zOiBcInV2M1wiXG4gIH0gOiB7XG4gICAgVEVYQ09PUkRfMDogXCJ1dlwiLFxuICAgIFRFWENPT1JEXzE6IFwidXYyXCJcbiAgfSxcbiAgQ09MT1JfMDogXCJjb2xvclwiLFxuICBXRUlHSFRTXzA6IFwic2tpbldlaWdodFwiLFxuICBKT0lOVFNfMDogXCJza2luSW5kZXhcIlxufTtcbmNvbnN0IFBBVEhfUFJPUEVSVElFUyA9IHtcbiAgc2NhbGU6IFwic2NhbGVcIixcbiAgdHJhbnNsYXRpb246IFwicG9zaXRpb25cIixcbiAgcm90YXRpb246IFwicXVhdGVybmlvblwiLFxuICB3ZWlnaHRzOiBcIm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1wiXG59O1xuY29uc3QgSU5URVJQT0xBVElPTiA9IHtcbiAgQ1VCSUNTUExJTkU6IHZvaWQgMCxcbiAgLy8gV2UgdXNlIGEgY3VzdG9tIGludGVycG9sYW50IChHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGF0aW9uKSBmb3IgQ1VCSUNTUExJTkUgdHJhY2tzLiBFYWNoXG4gIC8vIGtleWZyYW1lIHRyYWNrIHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIGRlZmF1bHQgaW50ZXJwb2xhdGlvbiB0eXBlLCB0aGVuIG1vZGlmaWVkLlxuICBMSU5FQVI6IEludGVycG9sYXRlTGluZWFyLFxuICBTVEVQOiBJbnRlcnBvbGF0ZURpc2NyZXRlXG59O1xuY29uc3QgQUxQSEFfTU9ERVMgPSB7XG4gIE9QQVFVRTogXCJPUEFRVUVcIixcbiAgTUFTSzogXCJNQVNLXCIsXG4gIEJMRU5EOiBcIkJMRU5EXCJcbn07XG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0TWF0ZXJpYWwoY2FjaGUpIHtcbiAgaWYgKGNhY2hlW1wiRGVmYXVsdE1hdGVyaWFsXCJdID09PSB2b2lkIDApIHtcbiAgICBjYWNoZVtcIkRlZmF1bHRNYXRlcmlhbFwiXSA9IG5ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7XG4gICAgICBjb2xvcjogMTY3NzcyMTUsXG4gICAgICBlbWlzc2l2ZTogMCxcbiAgICAgIG1ldGFsbmVzczogMSxcbiAgICAgIHJvdWdobmVzczogMSxcbiAgICAgIHRyYW5zcGFyZW50OiBmYWxzZSxcbiAgICAgIGRlcHRoVGVzdDogdHJ1ZSxcbiAgICAgIHNpZGU6IEZyb250U2lkZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBjYWNoZVtcIkRlZmF1bHRNYXRlcmlhbFwiXTtcbn1cbmZ1bmN0aW9uIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShrbm93bkV4dGVuc2lvbnMsIG9iamVjdCwgb2JqZWN0RGVmKSB7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBvYmplY3REZWYuZXh0ZW5zaW9ucykge1xuICAgIGlmIChrbm93bkV4dGVuc2lvbnNbbmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zID0gb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zIHx8IHt9O1xuICAgICAgb2JqZWN0LnVzZXJEYXRhLmdsdGZFeHRlbnNpb25zW25hbWVdID0gb2JqZWN0RGVmLmV4dGVuc2lvbnNbbmFtZV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG9iamVjdCwgZ2x0ZkRlZikge1xuICBpZiAoZ2x0ZkRlZi5leHRyYXMgIT09IHZvaWQgMCkge1xuICAgIGlmICh0eXBlb2YgZ2x0ZkRlZi5leHRyYXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ob2JqZWN0LnVzZXJEYXRhLCBnbHRmRGVmLmV4dHJhcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IElnbm9yaW5nIHByaW1pdGl2ZSB0eXBlIC5leHRyYXMsIFwiICsgZ2x0ZkRlZi5leHRyYXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYWRkTW9ycGhUYXJnZXRzKGdlb21ldHJ5LCB0YXJnZXRzLCBwYXJzZXIpIHtcbiAgbGV0IGhhc01vcnBoUG9zaXRpb24gPSBmYWxzZTtcbiAgbGV0IGhhc01vcnBoTm9ybWFsID0gZmFsc2U7XG4gIGxldCBoYXNNb3JwaENvbG9yID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgaWYgKHRhcmdldC5QT1NJVElPTiAhPT0gdm9pZCAwKVxuICAgICAgaGFzTW9ycGhQb3NpdGlvbiA9IHRydWU7XG4gICAgaWYgKHRhcmdldC5OT1JNQUwgIT09IHZvaWQgMClcbiAgICAgIGhhc01vcnBoTm9ybWFsID0gdHJ1ZTtcbiAgICBpZiAodGFyZ2V0LkNPTE9SXzAgIT09IHZvaWQgMClcbiAgICAgIGhhc01vcnBoQ29sb3IgPSB0cnVlO1xuICAgIGlmIChoYXNNb3JwaFBvc2l0aW9uICYmIGhhc01vcnBoTm9ybWFsICYmIGhhc01vcnBoQ29sb3IpXG4gICAgICBicmVhaztcbiAgfVxuICBpZiAoIWhhc01vcnBoUG9zaXRpb24gJiYgIWhhc01vcnBoTm9ybWFsICYmICFoYXNNb3JwaENvbG9yKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZ2VvbWV0cnkpO1xuICBjb25zdCBwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMgPSBbXTtcbiAgY29uc3QgcGVuZGluZ05vcm1hbEFjY2Vzc29ycyA9IFtdO1xuICBjb25zdCBwZW5kaW5nQ29sb3JBY2Nlc3NvcnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICBpZiAoaGFzTW9ycGhQb3NpdGlvbikge1xuICAgICAgY29uc3QgcGVuZGluZ0FjY2Vzc29yID0gdGFyZ2V0LlBPU0lUSU9OICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5QT1NJVElPTikgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICAgICAgcGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzLnB1c2gocGVuZGluZ0FjY2Vzc29yKTtcbiAgICB9XG4gICAgaWYgKGhhc01vcnBoTm9ybWFsKSB7XG4gICAgICBjb25zdCBwZW5kaW5nQWNjZXNzb3IgPSB0YXJnZXQuTk9STUFMICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5OT1JNQUwpIDogZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG4gICAgICBwZW5kaW5nTm9ybWFsQWNjZXNzb3JzLnB1c2gocGVuZGluZ0FjY2Vzc29yKTtcbiAgICB9XG4gICAgaWYgKGhhc01vcnBoQ29sb3IpIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5DT0xPUl8wICE9PSB2b2lkIDAgPyBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHRhcmdldC5DT0xPUl8wKSA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3I7XG4gICAgICBwZW5kaW5nQ29sb3JBY2Nlc3NvcnMucHVzaChwZW5kaW5nQWNjZXNzb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgIFByb21pc2UuYWxsKHBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycyksXG4gICAgUHJvbWlzZS5hbGwocGVuZGluZ05vcm1hbEFjY2Vzc29ycyksXG4gICAgUHJvbWlzZS5hbGwocGVuZGluZ0NvbG9yQWNjZXNzb3JzKVxuICBdKS50aGVuKGZ1bmN0aW9uKGFjY2Vzc29ycykge1xuICAgIGNvbnN0IG1vcnBoUG9zaXRpb25zID0gYWNjZXNzb3JzWzBdO1xuICAgIGNvbnN0IG1vcnBoTm9ybWFscyA9IGFjY2Vzc29yc1sxXTtcbiAgICBjb25zdCBtb3JwaENvbG9ycyA9IGFjY2Vzc29yc1syXTtcbiAgICBpZiAoaGFzTW9ycGhQb3NpdGlvbilcbiAgICAgIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbiA9IG1vcnBoUG9zaXRpb25zO1xuICAgIGlmIChoYXNNb3JwaE5vcm1hbClcbiAgICAgIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWwgPSBtb3JwaE5vcm1hbHM7XG4gICAgaWYgKGhhc01vcnBoQ29sb3IpXG4gICAgICBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuY29sb3IgPSBtb3JwaENvbG9ycztcbiAgICBnZW9tZXRyeS5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHRydWU7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1vcnBoVGFyZ2V0cyhtZXNoLCBtZXNoRGVmKSB7XG4gIG1lc2gudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG4gIGlmIChtZXNoRGVmLndlaWdodHMgIT09IHZvaWQgMCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG1lc2hEZWYud2VpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBtZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tpXSA9IG1lc2hEZWYud2VpZ2h0c1tpXTtcbiAgICB9XG4gIH1cbiAgaWYgKG1lc2hEZWYuZXh0cmFzICYmIEFycmF5LmlzQXJyYXkobWVzaERlZi5leHRyYXMudGFyZ2V0TmFtZXMpKSB7XG4gICAgY29uc3QgdGFyZ2V0TmFtZXMgPSBtZXNoRGVmLmV4dHJhcy50YXJnZXROYW1lcztcbiAgICBpZiAobWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoID09PSB0YXJnZXROYW1lcy5sZW5ndGgpIHtcbiAgICAgIG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSB0YXJnZXROYW1lcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIG1lc2gubW9ycGhUYXJnZXREaWN0aW9uYXJ5W3RhcmdldE5hbWVzW2ldXSA9IGk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IEludmFsaWQgZXh0cmFzLnRhcmdldE5hbWVzIGxlbmd0aC4gSWdub3JpbmcgbmFtZXMuXCIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlS2V5KHByaW1pdGl2ZURlZikge1xuICBsZXQgZ2VvbWV0cnlLZXk7XG4gIGNvbnN0IGRyYWNvRXh0ZW5zaW9uID0gcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnMgJiYgcHJpbWl0aXZlRGVmLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTl07XG4gIGlmIChkcmFjb0V4dGVuc2lvbikge1xuICAgIGdlb21ldHJ5S2V5ID0gXCJkcmFjbzpcIiArIGRyYWNvRXh0ZW5zaW9uLmJ1ZmZlclZpZXcgKyBcIjpcIiArIGRyYWNvRXh0ZW5zaW9uLmluZGljZXMgKyBcIjpcIiArIGNyZWF0ZUF0dHJpYnV0ZXNLZXkoZHJhY29FeHRlbnNpb24uYXR0cmlidXRlcyk7XG4gIH0gZWxzZSB7XG4gICAgZ2VvbWV0cnlLZXkgPSBwcmltaXRpdmVEZWYuaW5kaWNlcyArIFwiOlwiICsgY3JlYXRlQXR0cmlidXRlc0tleShwcmltaXRpdmVEZWYuYXR0cmlidXRlcykgKyBcIjpcIiArIHByaW1pdGl2ZURlZi5tb2RlO1xuICB9XG4gIGlmIChwcmltaXRpdmVEZWYudGFyZ2V0cyAhPT0gdm9pZCAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gcHJpbWl0aXZlRGVmLnRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgZ2VvbWV0cnlLZXkgKz0gXCI6XCIgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KHByaW1pdGl2ZURlZi50YXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdlb21ldHJ5S2V5O1xufVxuZnVuY3Rpb24gY3JlYXRlQXR0cmlidXRlc0tleShhdHRyaWJ1dGVzKSB7XG4gIGxldCBhdHRyaWJ1dGVzS2V5ID0gXCJcIjtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLnNvcnQoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0ga2V5cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgYXR0cmlidXRlc0tleSArPSBrZXlzW2ldICsgXCI6XCIgKyBhdHRyaWJ1dGVzW2tleXNbaV1dICsgXCI7XCI7XG4gIH1cbiAgcmV0dXJuIGF0dHJpYnV0ZXNLZXk7XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoY29uc3RydWN0b3IpIHtcbiAgc3dpdGNoIChjb25zdHJ1Y3Rvcikge1xuICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAxMjc7XG4gICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAyNTU7XG4gICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIDEgLyAzMjc2NztcbiAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgcmV0dXJuIDEgLyA2NTUzNTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogVW5zdXBwb3J0ZWQgbm9ybWFsaXplZCBhY2Nlc3NvciBjb21wb25lbnQgdHlwZS5cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEltYWdlVVJJTWltZVR5cGUodXJpKSB7XG4gIGlmICh1cmkuc2VhcmNoKC9cXC5qcGU/ZygkfFxcPykvaSkgPiAwIHx8IHVyaS5zZWFyY2goL15kYXRhXFw6aW1hZ2VcXC9qcGVnLykgPT09IDApXG4gICAgcmV0dXJuIFwiaW1hZ2UvanBlZ1wiO1xuICBpZiAodXJpLnNlYXJjaCgvXFwud2VicCgkfFxcPykvaSkgPiAwIHx8IHVyaS5zZWFyY2goL15kYXRhXFw6aW1hZ2VcXC93ZWJwLykgPT09IDApXG4gICAgcmV0dXJuIFwiaW1hZ2Uvd2VicFwiO1xuICByZXR1cm4gXCJpbWFnZS9wbmdcIjtcbn1cbmNvbnN0IF9pZGVudGl0eU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5jbGFzcyBHTFRGUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoanNvbiA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmpzb24gPSBqc29uO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHt9O1xuICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jYWNoZSA9IG5ldyBHTFRGUmVnaXN0cnkoKTtcbiAgICB0aGlzLmFzc29jaWF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5wcmltaXRpdmVDYWNoZSA9IHt9O1xuICAgIHRoaXMubm9kZUNhY2hlID0ge307XG4gICAgdGhpcy5tZXNoQ2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICAgIHRoaXMuY2FtZXJhQ2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICAgIHRoaXMubGlnaHRDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG4gICAgdGhpcy5zb3VyY2VDYWNoZSA9IHt9O1xuICAgIHRoaXMudGV4dHVyZUNhY2hlID0ge307XG4gICAgdGhpcy5ub2RlTmFtZXNVc2VkID0ge307XG4gICAgbGV0IGlzU2FmYXJpID0gZmFsc2U7XG4gICAgbGV0IGlzRmlyZWZveCA9IGZhbHNlO1xuICAgIGxldCBmaXJlZm94VmVyc2lvbiA9IC0xO1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgPT09IHRydWU7XG4gICAgICBpc0ZpcmVmb3ggPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpID4gLTE7XG4gICAgICBmaXJlZm94VmVyc2lvbiA9IGlzRmlyZWZveCA/IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8oWzAtOV0rKVxcLi8pWzFdIDogLTE7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09IFwidW5kZWZpbmVkXCIgfHwgaXNTYWZhcmkgfHwgaXNGaXJlZm94ICYmIGZpcmVmb3hWZXJzaW9uIDwgOTgpIHtcbiAgICAgIHRoaXMudGV4dHVyZUxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKHRoaXMub3B0aW9ucy5tYW5hZ2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0dXJlTG9hZGVyID0gbmV3IEltYWdlQml0bWFwTG9hZGVyKHRoaXMub3B0aW9ucy5tYW5hZ2VyKTtcbiAgICB9XG4gICAgdGhpcy50ZXh0dXJlTG9hZGVyLnNldENyb3NzT3JpZ2luKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbik7XG4gICAgdGhpcy50ZXh0dXJlTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5vcHRpb25zLnJlcXVlc3RIZWFkZXIpO1xuICAgIHRoaXMuZmlsZUxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMub3B0aW9ucy5tYW5hZ2VyKTtcbiAgICB0aGlzLmZpbGVMb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gXCJ1c2UtY3JlZGVudGlhbHNcIikge1xuICAgICAgdGhpcy5maWxlTG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0cnVlKTtcbiAgICB9XG4gIH1cbiAgc2V0RXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gICAgdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgfVxuICBzZXRQbHVnaW5zKHBsdWdpbnMpIHtcbiAgICB0aGlzLnBsdWdpbnMgPSBwbHVnaW5zO1xuICB9XG4gIHBhcnNlKG9uTG9hZCwgb25FcnJvcikge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIHRoaXMuY2FjaGUucmVtb3ZlQWxsKCk7XG4gICAgdGhpcy5ub2RlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICByZXR1cm4gZXh0Ll9tYXJrRGVmcyAmJiBleHQuX21hcmtEZWZzKCk7XG4gICAgfSk7XG4gICAgUHJvbWlzZS5hbGwoXG4gICAgICB0aGlzLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgIHJldHVybiBleHQuYmVmb3JlUm9vdCAmJiBleHQuYmVmb3JlUm9vdCgpO1xuICAgICAgfSlcbiAgICApLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICBwYXJzZXIuZ2V0RGVwZW5kZW5jaWVzKFwic2NlbmVcIiksXG4gICAgICAgIHBhcnNlci5nZXREZXBlbmRlbmNpZXMoXCJhbmltYXRpb25cIiksXG4gICAgICAgIHBhcnNlci5nZXREZXBlbmRlbmNpZXMoXCJjYW1lcmFcIilcbiAgICAgIF0pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24oZGVwZW5kZW5jaWVzKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHNjZW5lOiBkZXBlbmRlbmNpZXNbMF1banNvbi5zY2VuZSB8fCAwXSxcbiAgICAgICAgc2NlbmVzOiBkZXBlbmRlbmNpZXNbMF0sXG4gICAgICAgIGFuaW1hdGlvbnM6IGRlcGVuZGVuY2llc1sxXSxcbiAgICAgICAgY2FtZXJhczogZGVwZW5kZW5jaWVzWzJdLFxuICAgICAgICBhc3NldDoganNvbi5hc3NldCxcbiAgICAgICAgcGFyc2VyLFxuICAgICAgICB1c2VyRGF0YToge31cbiAgICAgIH07XG4gICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgcmVzdWx0LCBqc29uKTtcbiAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEocmVzdWx0LCBqc29uKTtcbiAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICBwYXJzZXIuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICByZXR1cm4gZXh0LmFmdGVyUm9vdCAmJiBleHQuYWZ0ZXJSb290KHJlc3VsdCk7XG4gICAgICAgIH0pXG4gICAgICApLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIG9uTG9hZChyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSkuY2F0Y2gob25FcnJvcik7XG4gIH1cbiAgLyoqXG4gICAqIE1hcmtzIHRoZSBzcGVjaWFsIG5vZGVzL21lc2hlcyBpbiBqc29uIGZvciBlZmZpY2llbnQgcGFyc2UuXG4gICAqL1xuICBfbWFya0RlZnMoKSB7XG4gICAgY29uc3Qgbm9kZURlZnMgPSB0aGlzLmpzb24ubm9kZXMgfHwgW107XG4gICAgY29uc3Qgc2tpbkRlZnMgPSB0aGlzLmpzb24uc2tpbnMgfHwgW107XG4gICAgY29uc3QgbWVzaERlZnMgPSB0aGlzLmpzb24ubWVzaGVzIHx8IFtdO1xuICAgIGZvciAobGV0IHNraW5JbmRleCA9IDAsIHNraW5MZW5ndGggPSBza2luRGVmcy5sZW5ndGg7IHNraW5JbmRleCA8IHNraW5MZW5ndGg7IHNraW5JbmRleCsrKSB7XG4gICAgICBjb25zdCBqb2ludHMgPSBza2luRGVmc1tza2luSW5kZXhdLmpvaW50cztcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGpvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIG5vZGVEZWZzW2pvaW50c1tpXV0uaXNCb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgbm9kZUluZGV4ID0gMCwgbm9kZUxlbmd0aCA9IG5vZGVEZWZzLmxlbmd0aDsgbm9kZUluZGV4IDwgbm9kZUxlbmd0aDsgbm9kZUluZGV4KyspIHtcbiAgICAgIGNvbnN0IG5vZGVEZWYgPSBub2RlRGVmc1tub2RlSW5kZXhdO1xuICAgICAgaWYgKG5vZGVEZWYubWVzaCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuX2FkZE5vZGVSZWYodGhpcy5tZXNoQ2FjaGUsIG5vZGVEZWYubWVzaCk7XG4gICAgICAgIGlmIChub2RlRGVmLnNraW4gIT09IHZvaWQgMCkge1xuICAgICAgICAgIG1lc2hEZWZzW25vZGVEZWYubWVzaF0uaXNTa2lubmVkTWVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlRGVmLmNhbWVyYSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuX2FkZE5vZGVSZWYodGhpcy5jYW1lcmFDYWNoZSwgbm9kZURlZi5jYW1lcmEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ291bnRzIHJlZmVyZW5jZXMgdG8gc2hhcmVkIG5vZGUgLyBPYmplY3QzRCByZXNvdXJjZXMuIFRoZXNlIHJlc291cmNlc1xuICAgKiBjYW4gYmUgcmV1c2VkLCBvciBcImluc3RhbnRpYXRlZFwiLCBhdCBtdWx0aXBsZSBub2RlcyBpbiB0aGUgc2NlbmVcbiAgICogaGllcmFyY2h5LiBNZXNoLCBDYW1lcmEsIGFuZCBMaWdodCBpbnN0YW5jZXMgYXJlIGluc3RhbnRpYXRlZCBhbmQgbXVzdFxuICAgKiBiZSBtYXJrZWQuIE5vbi1zY2VuZWdyYXBoIHJlc291cmNlcyAobGlrZSBNYXRlcmlhbHMsIEdlb21ldHJpZXMsIGFuZFxuICAgKiBUZXh0dXJlcykgY2FuIGJlIHJldXNlZCBkaXJlY3RseSBhbmQgYXJlIG5vdCBtYXJrZWQgaGVyZS5cbiAgICpcbiAgICogRXhhbXBsZTogQ2VzaXVtTWlsa1RydWNrIHNhbXBsZSBtb2RlbCByZXVzZXMgXCJXaGVlbFwiIG1lc2hlcy5cbiAgICovXG4gIF9hZGROb2RlUmVmKGNhY2hlLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChjYWNoZS5yZWZzW2luZGV4XSA9PT0gdm9pZCAwKSB7XG4gICAgICBjYWNoZS5yZWZzW2luZGV4XSA9IGNhY2hlLnVzZXNbaW5kZXhdID0gMDtcbiAgICB9XG4gICAgY2FjaGUucmVmc1tpbmRleF0rKztcbiAgfVxuICAvKiogUmV0dXJucyBhIHJlZmVyZW5jZSB0byBhIHNoYXJlZCByZXNvdXJjZSwgY2xvbmluZyBpdCBpZiBuZWNlc3NhcnkuICovXG4gIF9nZXROb2RlUmVmKGNhY2hlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgaWYgKGNhY2hlLnJlZnNbaW5kZXhdIDw9IDEpXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIGNvbnN0IHJlZiA9IG9iamVjdC5jbG9uZSgpO1xuICAgIGNvbnN0IHVwZGF0ZU1hcHBpbmdzID0gKG9yaWdpbmFsLCBjbG9uZSkgPT4ge1xuICAgICAgY29uc3QgbWFwcGluZ3MgPSB0aGlzLmFzc29jaWF0aW9ucy5nZXQob3JpZ2luYWwpO1xuICAgICAgaWYgKG1hcHBpbmdzICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5hc3NvY2lhdGlvbnMuc2V0KGNsb25lLCBtYXBwaW5ncyk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFtpLCBjaGlsZF0gb2Ygb3JpZ2luYWwuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgIHVwZGF0ZU1hcHBpbmdzKGNoaWxkLCBjbG9uZS5jaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB1cGRhdGVNYXBwaW5ncyhvYmplY3QsIHJlZik7XG4gICAgcmVmLm5hbWUgKz0gXCJfaW5zdGFuY2VfXCIgKyBjYWNoZS51c2VzW2luZGV4XSsrO1xuICAgIHJldHVybiByZWY7XG4gIH1cbiAgX2ludm9rZU9uZShmdW5jKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IE9iamVjdC52YWx1ZXModGhpcy5wbHVnaW5zKTtcbiAgICBleHRlbnNpb25zLnB1c2godGhpcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBmdW5jKGV4dGVuc2lvbnNbaV0pO1xuICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgX2ludm9rZUFsbChmdW5jKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IE9iamVjdC52YWx1ZXModGhpcy5wbHVnaW5zKTtcbiAgICBleHRlbnNpb25zLnVuc2hpZnQodGhpcyk7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZnVuYyhleHRlbnNpb25zW2ldKTtcbiAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgIHBlbmRpbmcucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgdGhlIHNwZWNpZmllZCBkZXBlbmRlbmN5IGFzeW5jaHJvbm91c2x5LCB3aXRoIGNhY2hpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdDNEfE1hdGVyaWFsfFRIUkVFLlRleHR1cmV8QW5pbWF0aW9uQ2xpcHxBcnJheUJ1ZmZlcnxPYmplY3Q+fVxuICAgKi9cbiAgZ2V0RGVwZW5kZW5jeSh0eXBlLCBpbmRleCkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gdHlwZSArIFwiOlwiICsgaW5kZXg7XG4gICAgbGV0IGRlcGVuZGVuY3kgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCFkZXBlbmRlbmN5KSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInNjZW5lXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZFNjZW5lKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5vZGVcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkTm9kZSAmJiBleHQubG9hZE5vZGUoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWVzaFwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRNZXNoICYmIGV4dC5sb2FkTWVzaChpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhY2Nlc3NvclwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRBY2Nlc3NvcihpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJidWZmZXJWaWV3XCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZEJ1ZmZlclZpZXcgJiYgZXh0LmxvYWRCdWZmZXJWaWV3KGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJ1ZmZlclwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRCdWZmZXIoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWF0ZXJpYWxcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkTWF0ZXJpYWwgJiYgZXh0LmxvYWRNYXRlcmlhbChpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0ZXh0dXJlXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZFRleHR1cmUgJiYgZXh0LmxvYWRUZXh0dXJlKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNraW5cIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkU2tpbihpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhbmltYXRpb25cIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkQW5pbWF0aW9uICYmIGV4dC5sb2FkQW5pbWF0aW9uKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhbWVyYVwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRDYW1lcmEoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0ICE9IHRoaXMgJiYgZXh0LmdldERlcGVuZGVuY3kgJiYgZXh0LmdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghZGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUuYWRkKGNhY2hlS2V5LCBkZXBlbmRlbmN5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcGVuZGVuY3k7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGFsbCBkZXBlbmRlbmNpZXMgb2YgdGhlIHNwZWNpZmllZCB0eXBlIGFzeW5jaHJvbm91c2x5LCB3aXRoIGNhY2hpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8T2JqZWN0Pj59XG4gICAqL1xuICBnZXREZXBlbmRlbmNpZXModHlwZSkge1xuICAgIGxldCBkZXBlbmRlbmNpZXMgPSB0aGlzLmNhY2hlLmdldCh0eXBlKTtcbiAgICBpZiAoIWRlcGVuZGVuY2llcykge1xuICAgICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICAgIGNvbnN0IGRlZnMgPSB0aGlzLmpzb25bdHlwZSArICh0eXBlID09PSBcIm1lc2hcIiA/IFwiZXNcIiA6IFwic1wiKV0gfHwgW107XG4gICAgICBkZXBlbmRlbmNpZXMgPSBQcm9taXNlLmFsbChcbiAgICAgICAgZGVmcy5tYXAoZnVuY3Rpb24oZGVmLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeSh0eXBlLCBpbmRleCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgdGhpcy5jYWNoZS5hZGQodHlwZSwgZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNidWZmZXJzLWFuZC1idWZmZXItdmlld3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlckluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuICAgKi9cbiAgbG9hZEJ1ZmZlcihidWZmZXJJbmRleCkge1xuICAgIGNvbnN0IGJ1ZmZlckRlZiA9IHRoaXMuanNvbi5idWZmZXJzW2J1ZmZlckluZGV4XTtcbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmZpbGVMb2FkZXI7XG4gICAgaWYgKGJ1ZmZlckRlZi50eXBlICYmIGJ1ZmZlckRlZi50eXBlICE9PSBcImFycmF5YnVmZmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFwiICsgYnVmZmVyRGVmLnR5cGUgKyBcIiBidWZmZXIgdHlwZSBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gICAgaWYgKGJ1ZmZlckRlZi51cmkgPT09IHZvaWQgMCAmJiBidWZmZXJJbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEZdLmJvZHkpO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGxvYWRlci5sb2FkKExvYWRlclV0aWxzLnJlc29sdmVVUkwoYnVmZmVyRGVmLnVyaSwgb3B0aW9ucy5wYXRoKSwgcmVzb2x2ZSwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVEhSRUUuR0xURkxvYWRlcjogRmFpbGVkIHRvIGxvYWQgYnVmZmVyIFwiJyArIGJ1ZmZlckRlZi51cmkgKyAnXCIuJykpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYnVmZmVycy1hbmQtYnVmZmVyLXZpZXdzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXJWaWV3SW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheUJ1ZmZlcj59XG4gICAqL1xuICBsb2FkQnVmZmVyVmlldyhidWZmZXJWaWV3SW5kZXgpIHtcbiAgICBjb25zdCBidWZmZXJWaWV3RGVmID0gdGhpcy5qc29uLmJ1ZmZlclZpZXdzW2J1ZmZlclZpZXdJbmRleF07XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclwiLCBidWZmZXJWaWV3RGVmLmJ1ZmZlcikudGhlbihmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBidWZmZXJWaWV3RGVmLmJ5dGVMZW5ndGggfHwgMDtcbiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBidWZmZXJWaWV3RGVmLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2FjY2Vzc29yc1xuICAgKiBAcGFyYW0ge251bWJlcn0gYWNjZXNzb3JJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEJ1ZmZlckF0dHJpYnV0ZXxJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZT59XG4gICAqL1xuICBsb2FkQWNjZXNzb3IoYWNjZXNzb3JJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBhY2Nlc3NvckRlZiA9IHRoaXMuanNvbi5hY2Nlc3NvcnNbYWNjZXNzb3JJbmRleF07XG4gICAgaWYgKGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgPT09IHZvaWQgMCAmJiBhY2Nlc3NvckRlZi5zcGFyc2UgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBXRUJHTF9UWVBFX1NJWkVTW2FjY2Vzc29yRGVmLnR5cGVdO1xuICAgICAgY29uc3QgVHlwZWRBcnJheSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlXTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShhY2Nlc3NvckRlZi5jb3VudCAqIGl0ZW1TaXplKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZ0J1ZmZlclZpZXdzID0gW107XG4gICAgaWYgKGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZ0J1ZmZlclZpZXdzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBhY2Nlc3NvckRlZi5idWZmZXJWaWV3KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKG51bGwpO1xuICAgIH1cbiAgICBpZiAoYWNjZXNzb3JEZWYuc3BhcnNlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuYnVmZmVyVmlldykpO1xuICAgICAgcGVuZGluZ0J1ZmZlclZpZXdzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBhY2Nlc3NvckRlZi5zcGFyc2UudmFsdWVzLmJ1ZmZlclZpZXcpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmdCdWZmZXJWaWV3cykudGhlbihmdW5jdGlvbihidWZmZXJWaWV3cykge1xuICAgICAgY29uc3QgYnVmZmVyVmlldyA9IGJ1ZmZlclZpZXdzWzBdO1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBXRUJHTF9UWVBFX1NJWkVTW2FjY2Vzc29yRGVmLnR5cGVdO1xuICAgICAgY29uc3QgVHlwZWRBcnJheSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlXTtcbiAgICAgIGNvbnN0IGVsZW1lbnRCeXRlcyA9IFR5cGVkQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICBjb25zdCBpdGVtQnl0ZXMgPSBlbGVtZW50Qnl0ZXMgKiBpdGVtU2l6ZTtcbiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBhY2Nlc3NvckRlZi5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICBjb25zdCBieXRlU3RyaWRlID0gYWNjZXNzb3JEZWYuYnVmZmVyVmlldyAhPT0gdm9pZCAwID8ganNvbi5idWZmZXJWaWV3c1thY2Nlc3NvckRlZi5idWZmZXJWaWV3XS5ieXRlU3RyaWRlIDogdm9pZCAwO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGFjY2Vzc29yRGVmLm5vcm1hbGl6ZWQgPT09IHRydWU7XG4gICAgICBsZXQgYXJyYXksIGJ1ZmZlckF0dHJpYnV0ZTtcbiAgICAgIGlmIChieXRlU3RyaWRlICYmIGJ5dGVTdHJpZGUgIT09IGl0ZW1CeXRlcykge1xuICAgICAgICBjb25zdCBpYlNsaWNlID0gTWF0aC5mbG9vcihieXRlT2Zmc2V0IC8gYnl0ZVN0cmlkZSk7XG4gICAgICAgIGNvbnN0IGliQ2FjaGVLZXkgPSBcIkludGVybGVhdmVkQnVmZmVyOlwiICsgYWNjZXNzb3JEZWYuYnVmZmVyVmlldyArIFwiOlwiICsgYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZSArIFwiOlwiICsgaWJTbGljZSArIFwiOlwiICsgYWNjZXNzb3JEZWYuY291bnQ7XG4gICAgICAgIGxldCBpYiA9IHBhcnNlci5jYWNoZS5nZXQoaWJDYWNoZUtleSk7XG4gICAgICAgIGlmICghaWIpIHtcbiAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGJ1ZmZlclZpZXcsIGliU2xpY2UgKiBieXRlU3RyaWRlLCBhY2Nlc3NvckRlZi5jb3VudCAqIGJ5dGVTdHJpZGUgLyBlbGVtZW50Qnl0ZXMpO1xuICAgICAgICAgIGliID0gbmV3IEludGVybGVhdmVkQnVmZmVyKGFycmF5LCBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzKTtcbiAgICAgICAgICBwYXJzZXIuY2FjaGUuYWRkKGliQ2FjaGVLZXksIGliKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoXG4gICAgICAgICAgaWIsXG4gICAgICAgICAgaXRlbVNpemUsXG4gICAgICAgICAgYnl0ZU9mZnNldCAlIGJ5dGVTdHJpZGUgLyBlbGVtZW50Qnl0ZXMsXG4gICAgICAgICAgbm9ybWFsaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJ1ZmZlclZpZXcgPT09IG51bGwpIHtcbiAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYnVmZmVyVmlldywgYnl0ZU9mZnNldCwgYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuICAgICAgfVxuICAgICAgaWYgKGFjY2Vzc29yRGVmLnNwYXJzZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1TaXplSW5kaWNlcyA9IFdFQkdMX1RZUEVfU0laRVMuU0NBTEFSO1xuICAgICAgICBjb25zdCBUeXBlZEFycmF5SW5kaWNlcyA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5jb21wb25lbnRUeXBlXTtcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldEluZGljZXMgPSBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXRWYWx1ZXMgPSBhY2Nlc3NvckRlZi5zcGFyc2UudmFsdWVzLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3Qgc3BhcnNlSW5kaWNlcyA9IG5ldyBUeXBlZEFycmF5SW5kaWNlcyhcbiAgICAgICAgICBidWZmZXJWaWV3c1sxXSxcbiAgICAgICAgICBieXRlT2Zmc2V0SW5kaWNlcyxcbiAgICAgICAgICBhY2Nlc3NvckRlZi5zcGFyc2UuY291bnQgKiBpdGVtU2l6ZUluZGljZXNcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgc3BhcnNlVmFsdWVzID0gbmV3IFR5cGVkQXJyYXkoYnVmZmVyVmlld3NbMl0sIGJ5dGVPZmZzZXRWYWx1ZXMsIGFjY2Vzc29yRGVmLnNwYXJzZS5jb3VudCAqIGl0ZW1TaXplKTtcbiAgICAgICAgaWYgKGJ1ZmZlclZpZXcgIT09IG51bGwpIHtcbiAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKFxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLmFycmF5LnNsaWNlKCksXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuaXRlbVNpemUsXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUubm9ybWFsaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gc3BhcnNlSW5kaWNlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBzcGFyc2VJbmRpY2VzW2ldO1xuICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5zZXRYKGluZGV4LCBzcGFyc2VWYWx1ZXNbaSAqIGl0ZW1TaXplXSk7XG4gICAgICAgICAgaWYgKGl0ZW1TaXplID49IDIpXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuc2V0WShpbmRleCwgc3BhcnNlVmFsdWVzW2kgKiBpdGVtU2l6ZSArIDFdKTtcbiAgICAgICAgICBpZiAoaXRlbVNpemUgPj0gMylcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5zZXRaKGluZGV4LCBzcGFyc2VWYWx1ZXNbaSAqIGl0ZW1TaXplICsgMl0pO1xuICAgICAgICAgIGlmIChpdGVtU2l6ZSA+PSA0KVxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLnNldFcoaW5kZXgsIHNwYXJzZVZhbHVlc1tpICogaXRlbVNpemUgKyAzXSk7XG4gICAgICAgICAgaWYgKGl0ZW1TaXplID49IDUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBpdGVtU2l6ZSBpbiBzcGFyc2UgQnVmZmVyQXR0cmlidXRlLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlckF0dHJpYnV0ZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3RleHR1cmVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0ZXh0dXJlSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxUSFJFRS5UZXh0dXJlfG51bGw+fVxuICAgKi9cbiAgbG9hZFRleHR1cmUodGV4dHVyZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgY29uc3Qgc291cmNlSW5kZXggPSB0ZXh0dXJlRGVmLnNvdXJjZTtcbiAgICBjb25zdCBzb3VyY2VEZWYgPSBqc29uLmltYWdlc1tzb3VyY2VJbmRleF07XG4gICAgbGV0IGxvYWRlciA9IHRoaXMudGV4dHVyZUxvYWRlcjtcbiAgICBpZiAoc291cmNlRGVmLnVyaSkge1xuICAgICAgY29uc3QgaGFuZGxlciA9IG9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKHNvdXJjZURlZi51cmkpO1xuICAgICAgaWYgKGhhbmRsZXIgIT09IG51bGwpXG4gICAgICAgIGxvYWRlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvYWRUZXh0dXJlSW1hZ2UodGV4dHVyZUluZGV4LCBzb3VyY2VJbmRleCwgbG9hZGVyKTtcbiAgfVxuICBsb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgc291cmNlSW5kZXgsIGxvYWRlcikge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGNvbnN0IHNvdXJjZURlZiA9IGpzb24uaW1hZ2VzW3NvdXJjZUluZGV4XTtcbiAgICBjb25zdCBjYWNoZUtleSA9IChzb3VyY2VEZWYudXJpIHx8IHNvdXJjZURlZi5idWZmZXJWaWV3KSArIFwiOlwiICsgdGV4dHVyZURlZi5zYW1wbGVyO1xuICAgIGlmICh0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV0pIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV07XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmxvYWRJbWFnZVNvdXJjZShzb3VyY2VJbmRleCwgbG9hZGVyKS50aGVuKGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICAgIHRleHR1cmUuZmxpcFkgPSBmYWxzZTtcbiAgICAgIHRleHR1cmUubmFtZSA9IHRleHR1cmVEZWYubmFtZSB8fCBzb3VyY2VEZWYubmFtZSB8fCBcIlwiO1xuICAgICAgaWYgKHRleHR1cmUubmFtZSA9PT0gXCJcIiAmJiB0eXBlb2Ygc291cmNlRGVmLnVyaSA9PT0gXCJzdHJpbmdcIiAmJiBzb3VyY2VEZWYudXJpLnN0YXJ0c1dpdGgoXCJkYXRhOmltYWdlL1wiKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGV4dHVyZS5uYW1lID0gc291cmNlRGVmLnVyaTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNhbXBsZXJzID0ganNvbi5zYW1wbGVycyB8fCB7fTtcbiAgICAgIGNvbnN0IHNhbXBsZXIgPSBzYW1wbGVyc1t0ZXh0dXJlRGVmLnNhbXBsZXJdIHx8IHt9O1xuICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBXRUJHTF9GSUxURVJTW3NhbXBsZXIubWFnRmlsdGVyXSB8fCBMaW5lYXJGaWx0ZXI7XG4gICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IFdFQkdMX0ZJTFRFUlNbc2FtcGxlci5taW5GaWx0ZXJdIHx8IExpbmVhck1pcG1hcExpbmVhckZpbHRlcjtcbiAgICAgIHRleHR1cmUud3JhcFMgPSBXRUJHTF9XUkFQUElOR1Nbc2FtcGxlci53cmFwU10gfHwgUmVwZWF0V3JhcHBpbmc7XG4gICAgICB0ZXh0dXJlLndyYXBUID0gV0VCR0xfV1JBUFBJTkdTW3NhbXBsZXIud3JhcFRdIHx8IFJlcGVhdFdyYXBwaW5nO1xuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQodGV4dHVyZSwgeyB0ZXh0dXJlczogdGV4dHVyZUluZGV4IH0pO1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICB0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGxvYWRJbWFnZVNvdXJjZShzb3VyY2VJbmRleCwgbG9hZGVyKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHRoaXMuc291cmNlQ2FjaGVbc291cmNlSW5kZXhdICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZUNhY2hlW3NvdXJjZUluZGV4XS50aGVuKCh0ZXh0dXJlKSA9PiB0ZXh0dXJlLmNsb25lKCkpO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VEZWYgPSBqc29uLmltYWdlc1tzb3VyY2VJbmRleF07XG4gICAgY29uc3QgVVJMID0gc2VsZi5VUkwgfHwgc2VsZi53ZWJraXRVUkw7XG4gICAgbGV0IHNvdXJjZVVSSSA9IHNvdXJjZURlZi51cmkgfHwgXCJcIjtcbiAgICBsZXQgaXNPYmplY3RVUkwgPSBmYWxzZTtcbiAgICBpZiAoc291cmNlRGVmLmJ1ZmZlclZpZXcgIT09IHZvaWQgMCkge1xuICAgICAgc291cmNlVVJJID0gcGFyc2VyLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIHNvdXJjZURlZi5idWZmZXJWaWV3KS50aGVuKGZ1bmN0aW9uKGJ1ZmZlclZpZXcpIHtcbiAgICAgICAgaXNPYmplY3RVUkwgPSB0cnVlO1xuICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZlclZpZXddLCB7IHR5cGU6IHNvdXJjZURlZi5taW1lVHlwZSB9KTtcbiAgICAgICAgc291cmNlVVJJID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZVVSSTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc291cmNlRGVmLnVyaSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBJbWFnZSBcIiArIHNvdXJjZUluZGV4ICsgXCIgaXMgbWlzc2luZyBVUkkgYW5kIGJ1ZmZlclZpZXdcIik7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoc291cmNlVVJJKS50aGVuKGZ1bmN0aW9uKHNvdXJjZVVSSTIpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbGV0IG9uTG9hZCA9IHJlc29sdmU7XG4gICAgICAgIGlmIChsb2FkZXIuaXNJbWFnZUJpdG1hcExvYWRlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG9uTG9hZCA9IGZ1bmN0aW9uKGltYWdlQml0bWFwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoaW1hZ2VCaXRtYXApO1xuICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKHRleHR1cmUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGVyLmxvYWQoTG9hZGVyVXRpbHMucmVzb2x2ZVVSTChzb3VyY2VVUkkyLCBvcHRpb25zLnBhdGgpLCBvbkxvYWQsIHZvaWQgMCwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24odGV4dHVyZSkge1xuICAgICAgaWYgKGlzT2JqZWN0VVJMID09PSB0cnVlKSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoc291cmNlVVJJKTtcbiAgICAgIH1cbiAgICAgIHRleHR1cmUudXNlckRhdGEubWltZVR5cGUgPSBzb3VyY2VEZWYubWltZVR5cGUgfHwgZ2V0SW1hZ2VVUklNaW1lVHlwZShzb3VyY2VEZWYudXJpKTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogQ291bGRuJ3QgbG9hZCB0ZXh0dXJlXCIsIHNvdXJjZVVSSSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgICB0aGlzLnNvdXJjZUNhY2hlW3NvdXJjZUluZGV4XSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91c2x5IGFzc2lnbnMgYSB0ZXh0dXJlIHRvIHRoZSBnaXZlbiBtYXRlcmlhbCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWF0ZXJpYWxQYXJhbXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcE5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcERlZlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFRleHR1cmU+fVxuICAgKi9cbiAgYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgbWFwTmFtZSwgbWFwRGVmLCBlbmNvZGluZykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jeShcInRleHR1cmVcIiwgbWFwRGVmLmluZGV4KS50aGVuKGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICAgIGlmICghdGV4dHVyZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBpZiAobWFwRGVmLnRleENvb3JkICE9PSB2b2lkIDAgJiYgbWFwRGVmLnRleENvb3JkID4gMCkge1xuICAgICAgICB0ZXh0dXJlID0gdGV4dHVyZS5jbG9uZSgpO1xuICAgICAgICB0ZXh0dXJlLmNoYW5uZWwgPSBtYXBEZWYudGV4Q29vcmQ7XG4gICAgICB9XG4gICAgICBpZiAocGFyc2VyLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk1dKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IG1hcERlZi5leHRlbnNpb25zICE9PSB2b2lkIDAgPyBtYXBEZWYuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STV0gOiB2b2lkIDA7XG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICBjb25zdCBnbHRmUmVmZXJlbmNlID0gcGFyc2VyLmFzc29jaWF0aW9ucy5nZXQodGV4dHVyZSk7XG4gICAgICAgICAgdGV4dHVyZSA9IHBhcnNlci5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNXS5leHRlbmRUZXh0dXJlKHRleHR1cmUsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQodGV4dHVyZSwgZ2x0ZlJlZmVyZW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlbmNvZGluZyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChcImNvbG9yU3BhY2VcIiBpbiB0ZXh0dXJlKVxuICAgICAgICAgIHRleHR1cmUuY29sb3JTcGFjZSA9IGVuY29kaW5nID09PSAzMDAxID8gXCJzcmdiXCIgOiBcInNyZ2ItbGluZWFyXCI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0ZXh0dXJlLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbFBhcmFtc1ttYXBOYW1lXSA9IHRleHR1cmU7XG4gICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQXNzaWducyBmaW5hbCBtYXRlcmlhbCB0byBhIE1lc2gsIExpbmUsIG9yIFBvaW50cyBpbnN0YW5jZS4gVGhlIGluc3RhbmNlXG4gICAqIGFscmVhZHkgaGFzIGEgbWF0ZXJpYWwgKGdlbmVyYXRlZCBmcm9tIHRoZSBnbFRGIG1hdGVyaWFsIG9wdGlvbnMgYWxvbmUpXG4gICAqIGJ1dCByZXVzZSBvZiB0aGUgc2FtZSBnbFRGIG1hdGVyaWFsIG1heSByZXF1aXJlIG11bHRpcGxlIHRocmVlanMgbWF0ZXJpYWxzXG4gICAqIHRvIGFjY29tbW9kYXRlIGRpZmZlcmVudCBwcmltaXRpdmUgdHlwZXMsIGRlZmluZXMsIGV0Yy4gTmV3IG1hdGVyaWFscyB3aWxsXG4gICAqIGJlIGNyZWF0ZWQgaWYgbmVjZXNzYXJ5LCBhbmQgcmV1c2VkIGZyb20gYSBjYWNoZS5cbiAgICogQHBhcmFtICB7T2JqZWN0M0R9IG1lc2ggTWVzaCwgTGluZSwgb3IgUG9pbnRzIGluc3RhbmNlLlxuICAgKi9cbiAgYXNzaWduRmluYWxNYXRlcmlhbChtZXNoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBtZXNoLmdlb21ldHJ5O1xuICAgIGxldCBtYXRlcmlhbCA9IG1lc2gubWF0ZXJpYWw7XG4gICAgY29uc3QgdXNlRGVyaXZhdGl2ZVRhbmdlbnRzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy50YW5nZW50ID09PSB2b2lkIDA7XG4gICAgY29uc3QgdXNlVmVydGV4Q29sb3JzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvciAhPT0gdm9pZCAwO1xuICAgIGNvbnN0IHVzZUZsYXRTaGFkaW5nID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwgPT09IHZvaWQgMDtcbiAgICBpZiAobWVzaC5pc1BvaW50cykge1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBcIlBvaW50c01hdGVyaWFsOlwiICsgbWF0ZXJpYWwudXVpZDtcbiAgICAgIGxldCBwb2ludHNNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmICghcG9pbnRzTWF0ZXJpYWwpIHtcbiAgICAgICAgcG9pbnRzTWF0ZXJpYWwgPSBuZXcgUG9pbnRzTWF0ZXJpYWwoKTtcbiAgICAgICAgTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbChwb2ludHNNYXRlcmlhbCwgbWF0ZXJpYWwpO1xuICAgICAgICBwb2ludHNNYXRlcmlhbC5jb2xvci5jb3B5KG1hdGVyaWFsLmNvbG9yKTtcbiAgICAgICAgcG9pbnRzTWF0ZXJpYWwubWFwID0gbWF0ZXJpYWwubWFwO1xuICAgICAgICBwb2ludHNNYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWNoZS5hZGQoY2FjaGVLZXksIHBvaW50c01hdGVyaWFsKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsID0gcG9pbnRzTWF0ZXJpYWw7XG4gICAgfSBlbHNlIGlmIChtZXNoLmlzTGluZSkge1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBcIkxpbmVCYXNpY01hdGVyaWFsOlwiICsgbWF0ZXJpYWwudXVpZDtcbiAgICAgIGxldCBsaW5lTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoIWxpbmVNYXRlcmlhbCkge1xuICAgICAgICBsaW5lTWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoKTtcbiAgICAgICAgTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbChsaW5lTWF0ZXJpYWwsIG1hdGVyaWFsKTtcbiAgICAgICAgbGluZU1hdGVyaWFsLmNvbG9yLmNvcHkobWF0ZXJpYWwuY29sb3IpO1xuICAgICAgICBsaW5lTWF0ZXJpYWwubWFwID0gbWF0ZXJpYWwubWFwO1xuICAgICAgICB0aGlzLmNhY2hlLmFkZChjYWNoZUtleSwgbGluZU1hdGVyaWFsKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsID0gbGluZU1hdGVyaWFsO1xuICAgIH1cbiAgICBpZiAodXNlRGVyaXZhdGl2ZVRhbmdlbnRzIHx8IHVzZVZlcnRleENvbG9ycyB8fCB1c2VGbGF0U2hhZGluZykge1xuICAgICAgbGV0IGNhY2hlS2V5ID0gXCJDbG9uZWRNYXRlcmlhbDpcIiArIG1hdGVyaWFsLnV1aWQgKyBcIjpcIjtcbiAgICAgIGlmICh1c2VEZXJpdmF0aXZlVGFuZ2VudHMpXG4gICAgICAgIGNhY2hlS2V5ICs9IFwiZGVyaXZhdGl2ZS10YW5nZW50czpcIjtcbiAgICAgIGlmICh1c2VWZXJ0ZXhDb2xvcnMpXG4gICAgICAgIGNhY2hlS2V5ICs9IFwidmVydGV4LWNvbG9yczpcIjtcbiAgICAgIGlmICh1c2VGbGF0U2hhZGluZylcbiAgICAgICAgY2FjaGVLZXkgKz0gXCJmbGF0LXNoYWRpbmc6XCI7XG4gICAgICBsZXQgY2FjaGVkTWF0ZXJpYWwgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoIWNhY2hlZE1hdGVyaWFsKSB7XG4gICAgICAgIGNhY2hlZE1hdGVyaWFsID0gbWF0ZXJpYWwuY2xvbmUoKTtcbiAgICAgICAgaWYgKHVzZVZlcnRleENvbG9ycylcbiAgICAgICAgICBjYWNoZWRNYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0cnVlO1xuICAgICAgICBpZiAodXNlRmxhdFNoYWRpbmcpXG4gICAgICAgICAgY2FjaGVkTWF0ZXJpYWwuZmxhdFNoYWRpbmcgPSB0cnVlO1xuICAgICAgICBpZiAodXNlRGVyaXZhdGl2ZVRhbmdlbnRzKSB7XG4gICAgICAgICAgaWYgKGNhY2hlZE1hdGVyaWFsLm5vcm1hbFNjYWxlKVxuICAgICAgICAgICAgY2FjaGVkTWF0ZXJpYWwubm9ybWFsU2NhbGUueSAqPSAtMTtcbiAgICAgICAgICBpZiAoY2FjaGVkTWF0ZXJpYWwuY2xlYXJjb2F0Tm9ybWFsU2NhbGUpXG4gICAgICAgICAgICBjYWNoZWRNYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxTY2FsZS55ICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FjaGUuYWRkKGNhY2hlS2V5LCBjYWNoZWRNYXRlcmlhbCk7XG4gICAgICAgIHRoaXMuYXNzb2NpYXRpb25zLnNldChjYWNoZWRNYXRlcmlhbCwgdGhpcy5hc3NvY2lhdGlvbnMuZ2V0KG1hdGVyaWFsKSk7XG4gICAgICB9XG4gICAgICBtYXRlcmlhbCA9IGNhY2hlZE1hdGVyaWFsO1xuICAgIH1cbiAgICBtZXNoLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKCkge1xuICAgIHJldHVybiBNZXNoU3RhbmRhcmRNYXRlcmlhbDtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNtYXRlcmlhbHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1hdGVyaWFsSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxNYXRlcmlhbD59XG4gICAqL1xuICBsb2FkTWF0ZXJpYWwobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0ganNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgbGV0IG1hdGVyaWFsVHlwZTtcbiAgICBjb25zdCBtYXRlcmlhbFBhcmFtcyA9IHt9O1xuICAgIGNvbnN0IG1hdGVyaWFsRXh0ZW5zaW9ucyA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwge307XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGlmIChtYXRlcmlhbEV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUXSkge1xuICAgICAgY29uc3Qga211RXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVRdO1xuICAgICAgbWF0ZXJpYWxUeXBlID0ga211RXh0ZW5zaW9uLmdldE1hdGVyaWFsVHlwZSgpO1xuICAgICAgcGVuZGluZy5wdXNoKGttdUV4dGVuc2lvbi5leHRlbmRQYXJhbXMobWF0ZXJpYWxQYXJhbXMsIG1hdGVyaWFsRGVmLCBwYXJzZXIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWV0YWxsaWNSb3VnaG5lc3MgPSBtYXRlcmlhbERlZi5wYnJNZXRhbGxpY1JvdWdobmVzcyB8fCB7fTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmNvbG9yID0gbmV3IENvbG9yKDEsIDEsIDEpO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMub3BhY2l0eSA9IDE7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3IpKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5jb2xvci5mcm9tQXJyYXkoYXJyYXkpO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gYXJyYXlbM107XG4gICAgICB9XG4gICAgICBpZiAobWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJtYXBcIiwgbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSwgMzAwMSkpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWxQYXJhbXMubWV0YWxuZXNzID0gbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNGYWN0b3IgIT09IHZvaWQgMCA/IG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljRmFjdG9yIDogMTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnJvdWdobmVzcyA9IG1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3RvciAhPT0gdm9pZCAwID8gbWV0YWxsaWNSb3VnaG5lc3Mucm91Z2huZXNzRmFjdG9yIDogMTtcbiAgICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibWV0YWxuZXNzTWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkpO1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwicm91Z2huZXNzTWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWxUeXBlID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICByZXR1cm4gZXh0LmdldE1hdGVyaWFsVHlwZSAmJiBleHQuZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgIHRoaXMuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQuZXh0ZW5kTWF0ZXJpYWxQYXJhbXMgJiYgZXh0LmV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYuZG91YmxlU2lkZWQgPT09IHRydWUpIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnNpZGUgPSBEb3VibGVTaWRlO1xuICAgIH1cbiAgICBjb25zdCBhbHBoYU1vZGUgPSBtYXRlcmlhbERlZi5hbHBoYU1vZGUgfHwgQUxQSEFfTU9ERVMuT1BBUVVFO1xuICAgIGlmIChhbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLkJMRU5EKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5kZXB0aFdyaXRlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnRyYW5zcGFyZW50ID0gZmFsc2U7XG4gICAgICBpZiAoYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5NQVNLKSB7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmFscGhhVGVzdCA9IG1hdGVyaWFsRGVmLmFscGhhQ3V0b2ZmICE9PSB2b2lkIDAgPyBtYXRlcmlhbERlZi5hbHBoYUN1dG9mZiA6IDAuNTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUgIT09IHZvaWQgMCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibm9ybWFsTWFwXCIsIG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUpKTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoMSwgMSk7XG4gICAgICBpZiAobWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMubm9ybWFsU2NhbGUuc2V0KHNjYWxlLCBzY2FsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImFvTWFwXCIsIG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUpKTtcbiAgICAgIGlmIChtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoICE9PSB2b2lkIDApIHtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuYW9NYXBJbnRlbnNpdHkgPSBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYuZW1pc3NpdmVGYWN0b3IgIT09IHZvaWQgMCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZSA9IG5ldyBDb2xvcigpLmZyb21BcnJheShtYXRlcmlhbERlZi5lbWlzc2l2ZUZhY3Rvcik7XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5lbWlzc2l2ZVRleHR1cmUgIT09IHZvaWQgMCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiZW1pc3NpdmVNYXBcIiwgbWF0ZXJpYWxEZWYuZW1pc3NpdmVUZXh0dXJlLCAzMDAxKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgbWF0ZXJpYWxUeXBlKG1hdGVyaWFsUGFyYW1zKTtcbiAgICAgIGlmIChtYXRlcmlhbERlZi5uYW1lKVxuICAgICAgICBtYXRlcmlhbC5uYW1lID0gbWF0ZXJpYWxEZWYubmFtZTtcbiAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEobWF0ZXJpYWwsIG1hdGVyaWFsRGVmKTtcbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KG1hdGVyaWFsLCB7IG1hdGVyaWFsczogbWF0ZXJpYWxJbmRleCB9KTtcbiAgICAgIGlmIChtYXRlcmlhbERlZi5leHRlbnNpb25zKVxuICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgbWF0ZXJpYWwsIG1hdGVyaWFsRGVmKTtcbiAgICAgIHJldHVybiBtYXRlcmlhbDtcbiAgICB9KTtcbiAgfVxuICAvKiogV2hlbiBPYmplY3QzRCBpbnN0YW5jZXMgYXJlIHRhcmdldGVkIGJ5IGFuaW1hdGlvbiwgdGhleSBuZWVkIHVuaXF1ZSBuYW1lcy4gKi9cbiAgY3JlYXRlVW5pcXVlTmFtZShvcmlnaW5hbE5hbWUpIHtcbiAgICBjb25zdCBzYW5pdGl6ZWROYW1lID0gUHJvcGVydHlCaW5kaW5nLnNhbml0aXplTm9kZU5hbWUob3JpZ2luYWxOYW1lIHx8IFwiXCIpO1xuICAgIGlmIChzYW5pdGl6ZWROYW1lIGluIHRoaXMubm9kZU5hbWVzVXNlZCkge1xuICAgICAgcmV0dXJuIHNhbml0aXplZE5hbWUgKyBcIl9cIiArICsrdGhpcy5ub2RlTmFtZXNVc2VkW3Nhbml0aXplZE5hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vZGVOYW1lc1VzZWRbc2FuaXRpemVkTmFtZV0gPSAwO1xuICAgICAgcmV0dXJuIHNhbml0aXplZE5hbWU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2dlb21ldHJ5XG4gICAqXG4gICAqIENyZWF0ZXMgQnVmZmVyR2VvbWV0cmllcyBmcm9tIHByaW1pdGl2ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8R0xURi5QcmltaXRpdmU+fSBwcmltaXRpdmVzXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8QnVmZmVyR2VvbWV0cnk+Pn1cbiAgICovXG4gIGxvYWRHZW9tZXRyaWVzKHByaW1pdGl2ZXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLnByaW1pdGl2ZUNhY2hlO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURyYWNvUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xuICAgICAgcmV0dXJuIGV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTl0uZGVjb2RlUHJpbWl0aXZlKHByaW1pdGl2ZSwgcGFyc2VyKS50aGVuKGZ1bmN0aW9uKGdlb21ldHJ5KSB7XG4gICAgICAgIHJldHVybiBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKGdlb21ldHJ5LCBwcmltaXRpdmUsIHBhcnNlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHByaW1pdGl2ZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3QgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1tpXTtcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlUHJpbWl0aXZlS2V5KHByaW1pdGl2ZSk7XG4gICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgIHBlbmRpbmcucHVzaChjYWNoZWQucHJvbWlzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZ2VvbWV0cnlQcm9taXNlO1xuICAgICAgICBpZiAocHJpbWl0aXZlLmV4dGVuc2lvbnMgJiYgcHJpbWl0aXZlLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTl0pIHtcbiAgICAgICAgICBnZW9tZXRyeVByb21pc2UgPSBjcmVhdGVEcmFjb1ByaW1pdGl2ZShwcmltaXRpdmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlb21ldHJ5UHJvbWlzZSA9IGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMobmV3IEJ1ZmZlckdlb21ldHJ5KCksIHByaW1pdGl2ZSwgcGFyc2VyKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZVtjYWNoZUtleV0gPSB7IHByaW1pdGl2ZSwgcHJvbWlzZTogZ2VvbWV0cnlQcm9taXNlIH07XG4gICAgICAgIHBlbmRpbmcucHVzaChnZW9tZXRyeVByb21pc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjbWVzaGVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtZXNoSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxHcm91cHxNZXNofFNraW5uZWRNZXNoPn1cbiAgICovXG4gIGxvYWRNZXNoKG1lc2hJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IG1lc2hEZWYgPSBqc29uLm1lc2hlc1ttZXNoSW5kZXhdO1xuICAgIGNvbnN0IHByaW1pdGl2ZXMgPSBtZXNoRGVmLnByaW1pdGl2ZXM7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHByaW1pdGl2ZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3QgbWF0ZXJpYWwgPSBwcmltaXRpdmVzW2ldLm1hdGVyaWFsID09PSB2b2lkIDAgPyBjcmVhdGVEZWZhdWx0TWF0ZXJpYWwodGhpcy5jYWNoZSkgOiB0aGlzLmdldERlcGVuZGVuY3koXCJtYXRlcmlhbFwiLCBwcmltaXRpdmVzW2ldLm1hdGVyaWFsKTtcbiAgICAgIHBlbmRpbmcucHVzaChtYXRlcmlhbCk7XG4gICAgfVxuICAgIHBlbmRpbmcucHVzaChwYXJzZXIubG9hZEdlb21ldHJpZXMocHJpbWl0aXZlcykpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIGNvbnN0IG1hdGVyaWFscyA9IHJlc3VsdHMuc2xpY2UoMCwgcmVzdWx0cy5sZW5ndGggLSAxKTtcbiAgICAgIGNvbnN0IGdlb21ldHJpZXMgPSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBtZXNoZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGdlb21ldHJpZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IGdlb21ldHJpZXNbaV07XG4gICAgICAgIGNvbnN0IHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbaV07XG4gICAgICAgIGxldCBtZXNoO1xuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IG1hdGVyaWFsc1tpXTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVTIHx8IHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfU1RSSVAgfHwgcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4gfHwgcHJpbWl0aXZlLm1vZGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIG1lc2ggPSBtZXNoRGVmLmlzU2tpbm5lZE1lc2ggPT09IHRydWUgPyBuZXcgU2tpbm5lZE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKSA6IG5ldyBNZXNoKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgICAgaWYgKG1lc2guaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbWVzaC5ub3JtYWxpemVTa2luV2VpZ2h0cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCkge1xuICAgICAgICAgICAgbWVzaC5nZW9tZXRyeSA9IHRvVHJpYW5nbGVzRHJhd01vZGUobWVzaC5nZW9tZXRyeSwgVHJpYW5nbGVTdHJpcERyYXdNb2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByaW1pdGl2ZS5tb2RlID09PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfRkFOKSB7XG4gICAgICAgICAgICBtZXNoLmdlb21ldHJ5ID0gdG9UcmlhbmdsZXNEcmF3TW9kZShtZXNoLmdlb21ldHJ5LCBUcmlhbmdsZUZhbkRyYXdNb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FUykge1xuICAgICAgICAgIG1lc2ggPSBuZXcgTGluZVNlZ21lbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FX1NUUklQKSB7XG4gICAgICAgICAgbWVzaCA9IG5ldyBMaW5lKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5MSU5FX0xPT1ApIHtcbiAgICAgICAgICBtZXNoID0gbmV3IExpbmVMb29wKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5QT0lOVFMpIHtcbiAgICAgICAgICBtZXNoID0gbmV3IFBvaW50cyhnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFByaW1pdGl2ZSBtb2RlIHVuc3VwcG9ydGVkOiBcIiArIHByaW1pdGl2ZS5tb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMobWVzaC5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB1cGRhdGVNb3JwaFRhcmdldHMobWVzaCwgbWVzaERlZik7XG4gICAgICAgIH1cbiAgICAgICAgbWVzaC5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUobWVzaERlZi5uYW1lIHx8IFwibWVzaF9cIiArIG1lc2hJbmRleCk7XG4gICAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEobWVzaCwgbWVzaERlZik7XG4gICAgICAgIGlmIChwcmltaXRpdmUuZXh0ZW5zaW9ucylcbiAgICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgbWVzaCwgcHJpbWl0aXZlKTtcbiAgICAgICAgcGFyc2VyLmFzc2lnbkZpbmFsTWF0ZXJpYWwobWVzaCk7XG4gICAgICAgIG1lc2hlcy5wdXNoKG1lc2gpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbWVzaGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQobWVzaGVzW2ldLCB7XG4gICAgICAgICAgbWVzaGVzOiBtZXNoSW5kZXgsXG4gICAgICAgICAgcHJpbWl0aXZlczogaVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChtZXNoRGVmLmV4dGVuc2lvbnMpXG4gICAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIG1lc2hlc1swXSwgbWVzaERlZik7XG4gICAgICAgIHJldHVybiBtZXNoZXNbMF07XG4gICAgICB9XG4gICAgICBjb25zdCBncm91cCA9IG5ldyBHcm91cCgpO1xuICAgICAgaWYgKG1lc2hEZWYuZXh0ZW5zaW9ucylcbiAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIGdyb3VwLCBtZXNoRGVmKTtcbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KGdyb3VwLCB7IG1lc2hlczogbWVzaEluZGV4IH0pO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbWVzaGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgZ3JvdXAuYWRkKG1lc2hlc1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNjYW1lcmFzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjYW1lcmFJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFRIUkVFLkNhbWVyYT59XG4gICAqL1xuICBsb2FkQ2FtZXJhKGNhbWVyYUluZGV4KSB7XG4gICAgbGV0IGNhbWVyYTtcbiAgICBjb25zdCBjYW1lcmFEZWYgPSB0aGlzLmpzb24uY2FtZXJhc1tjYW1lcmFJbmRleF07XG4gICAgY29uc3QgcGFyYW1zID0gY2FtZXJhRGVmW2NhbWVyYURlZi50eXBlXTtcbiAgICBpZiAoIXBhcmFtcykge1xuICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBjYW1lcmEgcGFyYW1ldGVycy5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYW1lcmFEZWYudHlwZSA9PT0gXCJwZXJzcGVjdGl2ZVwiKSB7XG4gICAgICBjYW1lcmEgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoXG4gICAgICAgIE1hdGhVdGlscy5yYWRUb0RlZyhwYXJhbXMueWZvdiksXG4gICAgICAgIHBhcmFtcy5hc3BlY3RSYXRpbyB8fCAxLFxuICAgICAgICBwYXJhbXMuem5lYXIgfHwgMSxcbiAgICAgICAgcGFyYW1zLnpmYXIgfHwgMmU2XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY2FtZXJhRGVmLnR5cGUgPT09IFwib3J0aG9ncmFwaGljXCIpIHtcbiAgICAgIGNhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoLXBhcmFtcy54bWFnLCBwYXJhbXMueG1hZywgcGFyYW1zLnltYWcsIC1wYXJhbXMueW1hZywgcGFyYW1zLnpuZWFyLCBwYXJhbXMuemZhcik7XG4gICAgfVxuICAgIGlmIChjYW1lcmFEZWYubmFtZSlcbiAgICAgIGNhbWVyYS5uYW1lID0gdGhpcy5jcmVhdGVVbmlxdWVOYW1lKGNhbWVyYURlZi5uYW1lKTtcbiAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKGNhbWVyYSwgY2FtZXJhRGVmKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhbWVyYSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNza2luc1xuICAgKiBAcGFyYW0ge251bWJlcn0gc2tpbkluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8U2tlbGV0b24+fVxuICAgKi9cbiAgbG9hZFNraW4oc2tpbkluZGV4KSB7XG4gICAgY29uc3Qgc2tpbkRlZiA9IHRoaXMuanNvbi5za2luc1tza2luSW5kZXhdO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBza2luRGVmLmpvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBwZW5kaW5nLnB1c2godGhpcy5fbG9hZE5vZGVTaGFsbG93KHNraW5EZWYuam9pbnRzW2ldKSk7XG4gICAgfVxuICAgIGlmIChza2luRGVmLmludmVyc2VCaW5kTWF0cmljZXMgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHNraW5EZWYuaW52ZXJzZUJpbmRNYXRyaWNlcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nLnB1c2gobnVsbCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgIGNvbnN0IGludmVyc2VCaW5kTWF0cmljZXMgPSByZXN1bHRzLnBvcCgpO1xuICAgICAgY29uc3Qgam9pbnROb2RlcyA9IHJlc3VsdHM7XG4gICAgICBjb25zdCBib25lcyA9IFtdO1xuICAgICAgY29uc3QgYm9uZUludmVyc2VzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBqb2ludE5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgY29uc3Qgam9pbnROb2RlID0gam9pbnROb2Rlc1tpXTtcbiAgICAgICAgaWYgKGpvaW50Tm9kZSkge1xuICAgICAgICAgIGJvbmVzLnB1c2goam9pbnROb2RlKTtcbiAgICAgICAgICBjb25zdCBtYXQgPSBuZXcgTWF0cml4NCgpO1xuICAgICAgICAgIGlmIChpbnZlcnNlQmluZE1hdHJpY2VzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXQuZnJvbUFycmF5KGludmVyc2VCaW5kTWF0cmljZXMuYXJyYXksIGkgKiAxNik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJvbmVJbnZlcnNlcy5wdXNoKG1hdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdUSFJFRS5HTFRGTG9hZGVyOiBKb2ludCBcIiVzXCIgY291bGQgbm90IGJlIGZvdW5kLicsIHNraW5EZWYuam9pbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBTa2VsZXRvbihib25lcywgYm9uZUludmVyc2VzKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI2FuaW1hdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFuaW1hdGlvbkluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8QW5pbWF0aW9uQ2xpcD59XG4gICAqL1xuICBsb2FkQW5pbWF0aW9uKGFuaW1hdGlvbkluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBhbmltYXRpb25EZWYgPSBqc29uLmFuaW1hdGlvbnNbYW5pbWF0aW9uSW5kZXhdO1xuICAgIGNvbnN0IGFuaW1hdGlvbk5hbWUgPSBhbmltYXRpb25EZWYubmFtZSA/IGFuaW1hdGlvbkRlZi5uYW1lIDogXCJhbmltYXRpb25fXCIgKyBhbmltYXRpb25JbmRleDtcbiAgICBjb25zdCBwZW5kaW5nTm9kZXMgPSBbXTtcbiAgICBjb25zdCBwZW5kaW5nSW5wdXRBY2Nlc3NvcnMgPSBbXTtcbiAgICBjb25zdCBwZW5kaW5nT3V0cHV0QWNjZXNzb3JzID0gW107XG4gICAgY29uc3QgcGVuZGluZ1NhbXBsZXJzID0gW107XG4gICAgY29uc3QgcGVuZGluZ1RhcmdldHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBhbmltYXRpb25EZWYuY2hhbm5lbHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IGFuaW1hdGlvbkRlZi5jaGFubmVsc1tpXTtcbiAgICAgIGNvbnN0IHNhbXBsZXIgPSBhbmltYXRpb25EZWYuc2FtcGxlcnNbY2hhbm5lbC5zYW1wbGVyXTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGNoYW5uZWwudGFyZ2V0O1xuICAgICAgY29uc3QgbmFtZSA9IHRhcmdldC5ub2RlO1xuICAgICAgY29uc3QgaW5wdXQgPSBhbmltYXRpb25EZWYucGFyYW1ldGVycyAhPT0gdm9pZCAwID8gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnNbc2FtcGxlci5pbnB1dF0gOiBzYW1wbGVyLmlucHV0O1xuICAgICAgY29uc3Qgb3V0cHV0ID0gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnMgIT09IHZvaWQgMCA/IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzW3NhbXBsZXIub3V0cHV0XSA6IHNhbXBsZXIub3V0cHV0O1xuICAgICAgaWYgKHRhcmdldC5ub2RlID09PSB2b2lkIDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcGVuZGluZ05vZGVzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwibm9kZVwiLCBuYW1lKSk7XG4gICAgICBwZW5kaW5nSW5wdXRBY2Nlc3NvcnMucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBpbnB1dCkpO1xuICAgICAgcGVuZGluZ091dHB1dEFjY2Vzc29ycy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIG91dHB1dCkpO1xuICAgICAgcGVuZGluZ1NhbXBsZXJzLnB1c2goc2FtcGxlcik7XG4gICAgICBwZW5kaW5nVGFyZ2V0cy5wdXNoKHRhcmdldCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nTm9kZXMpLFxuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ0lucHV0QWNjZXNzb3JzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMpLFxuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ1NhbXBsZXJzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdUYXJnZXRzKVxuICAgIF0pLnRoZW4oZnVuY3Rpb24oZGVwZW5kZW5jaWVzKSB7XG4gICAgICBjb25zdCBub2RlcyA9IGRlcGVuZGVuY2llc1swXTtcbiAgICAgIGNvbnN0IGlucHV0QWNjZXNzb3JzID0gZGVwZW5kZW5jaWVzWzFdO1xuICAgICAgY29uc3Qgb3V0cHV0QWNjZXNzb3JzID0gZGVwZW5kZW5jaWVzWzJdO1xuICAgICAgY29uc3Qgc2FtcGxlcnMgPSBkZXBlbmRlbmNpZXNbM107XG4gICAgICBjb25zdCB0YXJnZXRzID0gZGVwZW5kZW5jaWVzWzRdO1xuICAgICAgY29uc3QgdHJhY2tzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBub2Rlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgY29uc3QgaW5wdXRBY2Nlc3NvciA9IGlucHV0QWNjZXNzb3JzW2ldO1xuICAgICAgICBjb25zdCBvdXRwdXRBY2Nlc3NvciA9IG91dHB1dEFjY2Vzc29yc1tpXTtcbiAgICAgICAgY29uc3Qgc2FtcGxlciA9IHNhbXBsZXJzW2ldO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgICBpZiAobm9kZSA9PT0gdm9pZCAwKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBub2RlLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgICBsZXQgVHlwZWRLZXlmcmFtZVRyYWNrO1xuICAgICAgICBzd2l0Y2ggKFBBVEhfUFJPUEVSVElFU1t0YXJnZXQucGF0aF0pIHtcbiAgICAgICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy53ZWlnaHRzOlxuICAgICAgICAgICAgVHlwZWRLZXlmcmFtZVRyYWNrID0gTnVtYmVyS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUEFUSF9QUk9QRVJUSUVTLnJvdGF0aW9uOlxuICAgICAgICAgICAgVHlwZWRLZXlmcmFtZVRyYWNrID0gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy5wb3NpdGlvbjpcbiAgICAgICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy5zY2FsZTpcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgVHlwZWRLZXlmcmFtZVRyYWNrID0gVmVjdG9yS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldE5hbWUgPSBub2RlLm5hbWUgPyBub2RlLm5hbWUgOiBub2RlLnV1aWQ7XG4gICAgICAgIGNvbnN0IGludGVycG9sYXRpb24gPSBzYW1wbGVyLmludGVycG9sYXRpb24gIT09IHZvaWQgMCA/IElOVEVSUE9MQVRJT05bc2FtcGxlci5pbnRlcnBvbGF0aW9uXSA6IEludGVycG9sYXRlTGluZWFyO1xuICAgICAgICBjb25zdCB0YXJnZXROYW1lcyA9IFtdO1xuICAgICAgICBpZiAoUEFUSF9QUk9QRVJUSUVTW3RhcmdldC5wYXRoXSA9PT0gUEFUSF9QUk9QRVJUSUVTLndlaWdodHMpIHtcbiAgICAgICAgICBub2RlLnRyYXZlcnNlKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXMpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0TmFtZXMucHVzaChvYmplY3QubmFtZSA/IG9iamVjdC5uYW1lIDogb2JqZWN0LnV1aWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldE5hbWVzLnB1c2godGFyZ2V0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dHB1dEFycmF5ID0gb3V0cHV0QWNjZXNzb3IuYXJyYXk7XG4gICAgICAgIGlmIChvdXRwdXRBY2Nlc3Nvci5ub3JtYWxpemVkKSB7XG4gICAgICAgICAgY29uc3Qgc2NhbGUgPSBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUob3V0cHV0QXJyYXkuY29uc3RydWN0b3IpO1xuICAgICAgICAgIGNvbnN0IHNjYWxlZCA9IG5ldyBGbG9hdDMyQXJyYXkob3V0cHV0QXJyYXkubGVuZ3RoKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBvdXRwdXRBcnJheS5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgICBzY2FsZWRbal0gPSBvdXRwdXRBcnJheVtqXSAqIHNjYWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXRBcnJheSA9IHNjYWxlZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gMCwgamwgPSB0YXJnZXROYW1lcy5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2sgPSBuZXcgVHlwZWRLZXlmcmFtZVRyYWNrKFxuICAgICAgICAgICAgdGFyZ2V0TmFtZXNbal0gKyBcIi5cIiArIFBBVEhfUFJPUEVSVElFU1t0YXJnZXQucGF0aF0sXG4gICAgICAgICAgICBpbnB1dEFjY2Vzc29yLmFycmF5LFxuICAgICAgICAgICAgb3V0cHV0QXJyYXksXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoc2FtcGxlci5pbnRlcnBvbGF0aW9uID09PSBcIkNVQklDU1BMSU5FXCIpIHtcbiAgICAgICAgICAgIHRyYWNrLmNyZWF0ZUludGVycG9sYW50ID0gZnVuY3Rpb24gSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lKHJlc3VsdCkge1xuICAgICAgICAgICAgICBjb25zdCBpbnRlcnBvbGFudFR5cGUgPSB0aGlzIGluc3RhbmNlb2YgUXVhdGVybmlvbktleWZyYW1lVHJhY2sgPyBHTFRGQ3ViaWNTcGxpbmVRdWF0ZXJuaW9uSW50ZXJwb2xhbnQgOiBHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudDtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpbnRlcnBvbGFudFR5cGUodGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCkgLyAzLCByZXN1bHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYWNrLmNyZWF0ZUludGVycG9sYW50LmlzSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJhY2tzLnB1c2godHJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbkNsaXAoYW5pbWF0aW9uTmFtZSwgdm9pZCAwLCB0cmFja3MpO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZU5vZGVNZXNoKG5vZGVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGlmIChub2RlRGVmLm1lc2ggPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcIm1lc2hcIiwgbm9kZURlZi5tZXNoKS50aGVuKGZ1bmN0aW9uKG1lc2gpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBwYXJzZXIuX2dldE5vZGVSZWYocGFyc2VyLm1lc2hDYWNoZSwgbm9kZURlZi5tZXNoLCBtZXNoKTtcbiAgICAgIGlmIChub2RlRGVmLndlaWdodHMgIT09IHZvaWQgMCkge1xuICAgICAgICBub2RlLnRyYXZlcnNlKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICBpZiAoIW8uaXNNZXNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG5vZGVEZWYud2VpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgICBvLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1tpXSA9IG5vZGVEZWYud2VpZ2h0c1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNub2Rlcy1hbmQtaGllcmFyY2h5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBub2RlSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3QzRD59XG4gICAqL1xuICBsb2FkTm9kZShub2RlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBjb25zdCBub2RlUGVuZGluZyA9IHBhcnNlci5fbG9hZE5vZGVTaGFsbG93KG5vZGVJbmRleCk7XG4gICAgY29uc3QgY2hpbGRQZW5kaW5nID0gW107XG4gICAgY29uc3QgY2hpbGRyZW5EZWYgPSBub2RlRGVmLmNoaWxkcmVuIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGNoaWxkcmVuRGVmLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNoaWxkUGVuZGluZy5wdXNoKHBhcnNlci5nZXREZXBlbmRlbmN5KFwibm9kZVwiLCBjaGlsZHJlbkRlZltpXSkpO1xuICAgIH1cbiAgICBjb25zdCBza2VsZXRvblBlbmRpbmcgPSBub2RlRGVmLnNraW4gPT09IHZvaWQgMCA/IFByb21pc2UucmVzb2x2ZShudWxsKSA6IHBhcnNlci5nZXREZXBlbmRlbmN5KFwic2tpblwiLCBub2RlRGVmLnNraW4pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbbm9kZVBlbmRpbmcsIFByb21pc2UuYWxsKGNoaWxkUGVuZGluZyksIHNrZWxldG9uUGVuZGluZ10pLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgY29uc3Qgbm9kZSA9IHJlc3VsdHNbMF07XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHJlc3VsdHNbMV07XG4gICAgICBjb25zdCBza2VsZXRvbiA9IHJlc3VsdHNbMl07XG4gICAgICBpZiAoc2tlbGV0b24gIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS50cmF2ZXJzZShmdW5jdGlvbihtZXNoKSB7XG4gICAgICAgICAgaWYgKCFtZXNoLmlzU2tpbm5lZE1lc2gpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgbWVzaC5iaW5kKHNrZWxldG9uLCBfaWRlbnRpdHlNYXRyaXgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgbm9kZS5hZGQoY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gIH1cbiAgLy8gLl9sb2FkTm9kZVNoYWxsb3coKSBwYXJzZXMgYSBzaW5nbGUgbm9kZS5cbiAgLy8gc2tpbiBhbmQgY2hpbGQgbm9kZXMgYXJlIGNyZWF0ZWQgYW5kIGFkZGVkIGluIC5sb2FkTm9kZSgpIChubyAnXycgcHJlZml4KS5cbiAgX2xvYWROb2RlU2hhbGxvdyhub2RlSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBpZiAodGhpcy5ub2RlQ2FjaGVbbm9kZUluZGV4XSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlQ2FjaGVbbm9kZUluZGV4XTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBjb25zdCBub2RlTmFtZSA9IG5vZGVEZWYubmFtZSA/IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKG5vZGVEZWYubmFtZSkgOiBcIlwiO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBtZXNoUHJvbWlzZSA9IHBhcnNlci5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgcmV0dXJuIGV4dC5jcmVhdGVOb2RlTWVzaCAmJiBleHQuY3JlYXRlTm9kZU1lc2gobm9kZUluZGV4KTtcbiAgICB9KTtcbiAgICBpZiAobWVzaFByb21pc2UpIHtcbiAgICAgIHBlbmRpbmcucHVzaChtZXNoUHJvbWlzZSk7XG4gICAgfVxuICAgIGlmIChub2RlRGVmLmNhbWVyYSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIHBhcnNlci5nZXREZXBlbmRlbmN5KFwiY2FtZXJhXCIsIG5vZGVEZWYuY2FtZXJhKS50aGVuKGZ1bmN0aW9uKGNhbWVyYSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuX2dldE5vZGVSZWYocGFyc2VyLmNhbWVyYUNhY2hlLCBub2RlRGVmLmNhbWVyYSwgY2FtZXJhKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIHBhcnNlci5faW52b2tlQWxsKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgcmV0dXJuIGV4dC5jcmVhdGVOb2RlQXR0YWNobWVudCAmJiBleHQuY3JlYXRlTm9kZUF0dGFjaG1lbnQobm9kZUluZGV4KTtcbiAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgIHBlbmRpbmcucHVzaChwcm9taXNlKTtcbiAgICB9KTtcbiAgICB0aGlzLm5vZGVDYWNoZVtub2RlSW5kZXhdID0gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbihvYmplY3RzKSB7XG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGlmIChub2RlRGVmLmlzQm9uZSA9PT0gdHJ1ZSkge1xuICAgICAgICBub2RlID0gbmV3IEJvbmUoKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG5vZGUgPSBuZXcgR3JvdXAoKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbm9kZSA9IG9iamVjdHNbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gbmV3IE9iamVjdDNEKCk7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSAhPT0gb2JqZWN0c1swXSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICBub2RlLmFkZChvYmplY3RzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGVEZWYubmFtZSkge1xuICAgICAgICBub2RlLnVzZXJEYXRhLm5hbWUgPSBub2RlRGVmLm5hbWU7XG4gICAgICAgIG5vZGUubmFtZSA9IG5vZGVOYW1lO1xuICAgICAgfVxuICAgICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShub2RlLCBub2RlRGVmKTtcbiAgICAgIGlmIChub2RlRGVmLmV4dGVuc2lvbnMpXG4gICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBub2RlLCBub2RlRGVmKTtcbiAgICAgIGlmIChub2RlRGVmLm1hdHJpeCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICAgIG1hdHJpeC5mcm9tQXJyYXkobm9kZURlZi5tYXRyaXgpO1xuICAgICAgICBub2RlLmFwcGx5TWF0cml4NChtYXRyaXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5vZGVEZWYudHJhbnNsYXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICAgIG5vZGUucG9zaXRpb24uZnJvbUFycmF5KG5vZGVEZWYudHJhbnNsYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlRGVmLnJvdGF0aW9uICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBub2RlLnF1YXRlcm5pb24uZnJvbUFycmF5KG5vZGVEZWYucm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlRGVmLnNjYWxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBub2RlLnNjYWxlLmZyb21BcnJheShub2RlRGVmLnNjYWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFwYXJzZXIuYXNzb2NpYXRpb25zLmhhcyhub2RlKSkge1xuICAgICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldChub2RlLCB7fSk7XG4gICAgICB9XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLmdldChub2RlKS5ub2RlcyA9IG5vZGVJbmRleDtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLm5vZGVDYWNoZVtub2RlSW5kZXhdO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjc2NlbmVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY2VuZUluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8R3JvdXA+fVxuICAgKi9cbiAgbG9hZFNjZW5lKHNjZW5lSW5kZXgpIHtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIGNvbnN0IHNjZW5lRGVmID0gdGhpcy5qc29uLnNjZW5lc1tzY2VuZUluZGV4XTtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IHNjZW5lID0gbmV3IEdyb3VwKCk7XG4gICAgaWYgKHNjZW5lRGVmLm5hbWUpXG4gICAgICBzY2VuZS5uYW1lID0gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUoc2NlbmVEZWYubmFtZSk7XG4gICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShzY2VuZSwgc2NlbmVEZWYpO1xuICAgIGlmIChzY2VuZURlZi5leHRlbnNpb25zKVxuICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIHNjZW5lLCBzY2VuZURlZik7XG4gICAgY29uc3Qgbm9kZUlkcyA9IHNjZW5lRGVmLm5vZGVzIHx8IFtdO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBub2RlSWRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuZ2V0RGVwZW5kZW5jeShcIm5vZGVcIiwgbm9kZUlkc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbihmdW5jdGlvbihub2Rlcykge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBzY2VuZS5hZGQobm9kZXNbaV0pO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVkdWNlQXNzb2NpYXRpb25zID0gKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgcmVkdWNlZEFzc29jaWF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHBhcnNlci5hc3NvY2lhdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgTWF0ZXJpYWwgfHwga2V5IGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgICAgICAgcmVkdWNlZEFzc29jaWF0aW9ucy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUudHJhdmVyc2UoKG5vZGUyKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWFwcGluZ3MgPSBwYXJzZXIuYXNzb2NpYXRpb25zLmdldChub2RlMik7XG4gICAgICAgICAgaWYgKG1hcHBpbmdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlZHVjZWRBc3NvY2lhdGlvbnMuc2V0KG5vZGUyLCBtYXBwaW5ncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlZHVjZWRBc3NvY2lhdGlvbnM7XG4gICAgICB9O1xuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucyA9IHJlZHVjZUFzc29jaWF0aW9ucyhzY2VuZSk7XG4gICAgICByZXR1cm4gc2NlbmU7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZHMoZ2VvbWV0cnksIHByaW1pdGl2ZURlZiwgcGFyc2VyKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBwcmltaXRpdmVEZWYuYXR0cmlidXRlcztcbiAgY29uc3QgYm94ID0gbmV3IEJveDMoKTtcbiAgaWYgKGF0dHJpYnV0ZXMuUE9TSVRJT04gIT09IHZvaWQgMCkge1xuICAgIGNvbnN0IGFjY2Vzc29yID0gcGFyc2VyLmpzb24uYWNjZXNzb3JzW2F0dHJpYnV0ZXMuUE9TSVRJT05dO1xuICAgIGNvbnN0IG1pbiA9IGFjY2Vzc29yLm1pbjtcbiAgICBjb25zdCBtYXggPSBhY2Nlc3Nvci5tYXg7XG4gICAgaWYgKG1pbiAhPT0gdm9pZCAwICYmIG1heCAhPT0gdm9pZCAwKSB7XG4gICAgICBib3guc2V0KG5ldyBWZWN0b3IzKG1pblswXSwgbWluWzFdLCBtaW5bMl0pLCBuZXcgVmVjdG9yMyhtYXhbMF0sIG1heFsxXSwgbWF4WzJdKSk7XG4gICAgICBpZiAoYWNjZXNzb3Iubm9ybWFsaXplZCkge1xuICAgICAgICBjb25zdCBib3hTY2FsZSA9IGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZShXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3IuY29tcG9uZW50VHlwZV0pO1xuICAgICAgICBib3gubWluLm11bHRpcGx5U2NhbGFyKGJveFNjYWxlKTtcbiAgICAgICAgYm94Lm1heC5tdWx0aXBseVNjYWxhcihib3hTY2FsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkdMVEZMb2FkZXI6IE1pc3NpbmcgbWluL21heCBwcm9wZXJ0aWVzIGZvciBhY2Nlc3NvciBQT1NJVElPTi5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YXJnZXRzID0gcHJpbWl0aXZlRGVmLnRhcmdldHM7XG4gIGlmICh0YXJnZXRzICE9PSB2b2lkIDApIHtcbiAgICBjb25zdCBtYXhEaXNwbGFjZW1lbnQgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNvbnN0IHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgICAgaWYgKHRhcmdldC5QT1NJVElPTiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGFjY2Vzc29yID0gcGFyc2VyLmpzb24uYWNjZXNzb3JzW3RhcmdldC5QT1NJVElPTl07XG4gICAgICAgIGNvbnN0IG1pbiA9IGFjY2Vzc29yLm1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gYWNjZXNzb3IubWF4O1xuICAgICAgICBpZiAobWluICE9PSB2b2lkIDAgJiYgbWF4ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB2ZWN0b3Iuc2V0WChNYXRoLm1heChNYXRoLmFicyhtaW5bMF0pLCBNYXRoLmFicyhtYXhbMF0pKSk7XG4gICAgICAgICAgdmVjdG9yLnNldFkoTWF0aC5tYXgoTWF0aC5hYnMobWluWzFdKSwgTWF0aC5hYnMobWF4WzFdKSkpO1xuICAgICAgICAgIHZlY3Rvci5zZXRaKE1hdGgubWF4KE1hdGguYWJzKG1pblsyXSksIE1hdGguYWJzKG1heFsyXSkpKTtcbiAgICAgICAgICBpZiAoYWNjZXNzb3Iubm9ybWFsaXplZCkge1xuICAgICAgICAgICAgY29uc3QgYm94U2NhbGUgPSBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yLmNvbXBvbmVudFR5cGVdKTtcbiAgICAgICAgICAgIHZlY3Rvci5tdWx0aXBseVNjYWxhcihib3hTY2FsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1heERpc3BsYWNlbWVudC5tYXgodmVjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIG1pbi9tYXggcHJvcGVydGllcyBmb3IgYWNjZXNzb3IgUE9TSVRJT04uXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJveC5leHBhbmRCeVZlY3RvcihtYXhEaXNwbGFjZW1lbnQpO1xuICB9XG4gIGdlb21ldHJ5LmJvdW5kaW5nQm94ID0gYm94O1xuICBjb25zdCBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gIGJveC5nZXRDZW50ZXIoc3BoZXJlLmNlbnRlcik7XG4gIHNwaGVyZS5yYWRpdXMgPSBib3gubWluLmRpc3RhbmNlVG8oYm94Lm1heCkgLyAyO1xuICBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9IHNwaGVyZTtcbn1cbmZ1bmN0aW9uIGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMoZ2VvbWV0cnksIHByaW1pdGl2ZURlZiwgcGFyc2VyKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBwcmltaXRpdmVEZWYuYXR0cmlidXRlcztcbiAgY29uc3QgcGVuZGluZyA9IFtdO1xuICBmdW5jdGlvbiBhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvcihhY2Nlc3NvckluZGV4LCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgYWNjZXNzb3JJbmRleCkudGhlbihmdW5jdGlvbihhY2Nlc3Nvcikge1xuICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGFjY2Vzc29yKTtcbiAgICB9KTtcbiAgfVxuICBmb3IgKGNvbnN0IGdsdGZBdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCB0aHJlZUF0dHJpYnV0ZU5hbWUgPSBBVFRSSUJVVEVTW2dsdGZBdHRyaWJ1dGVOYW1lXSB8fCBnbHRmQXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh0aHJlZUF0dHJpYnV0ZU5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcylcbiAgICAgIGNvbnRpbnVlO1xuICAgIHBlbmRpbmcucHVzaChhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvcihhdHRyaWJ1dGVzW2dsdGZBdHRyaWJ1dGVOYW1lXSwgdGhyZWVBdHRyaWJ1dGVOYW1lKSk7XG4gIH1cbiAgaWYgKHByaW1pdGl2ZURlZi5pbmRpY2VzICE9PSB2b2lkIDAgJiYgIWdlb21ldHJ5LmluZGV4KSB7XG4gICAgY29uc3QgYWNjZXNzb3IgPSBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIHByaW1pdGl2ZURlZi5pbmRpY2VzKS50aGVuKGZ1bmN0aW9uKGFjY2Vzc29yMikge1xuICAgICAgZ2VvbWV0cnkuc2V0SW5kZXgoYWNjZXNzb3IyKTtcbiAgICB9KTtcbiAgICBwZW5kaW5nLnB1c2goYWNjZXNzb3IpO1xuICB9XG4gIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoZ2VvbWV0cnksIHByaW1pdGl2ZURlZik7XG4gIGNvbXB1dGVCb3VuZHMoZ2VvbWV0cnksIHByaW1pdGl2ZURlZiwgcGFyc2VyKTtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZURlZi50YXJnZXRzICE9PSB2b2lkIDAgPyBhZGRNb3JwaFRhcmdldHMoZ2VvbWV0cnksIHByaW1pdGl2ZURlZi50YXJnZXRzLCBwYXJzZXIpIDogZ2VvbWV0cnk7XG4gIH0pO1xufVxuZXhwb3J0IHtcbiAgR0xURkxvYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdMVEZMb2FkZXIuanMubWFwXG4iXSwibmFtZXMiOlsiTG9hZGVyIiwiTG9hZGVyVXRpbHMiLCJGaWxlTG9hZGVyIiwiQ29sb3IiLCJTcG90TGlnaHQiLCJQb2ludExpZ2h0IiwiRGlyZWN0aW9uYWxMaWdodCIsIk1lc2hCYXNpY01hdGVyaWFsIiwiTWVzaFBoeXNpY2FsTWF0ZXJpYWwiLCJWZWN0b3IyIiwiTWF0cml4NCIsIlZlY3RvcjMiLCJRdWF0ZXJuaW9uIiwiSW5zdGFuY2VkTWVzaCIsIk9iamVjdDNEIiwiVGV4dHVyZUxvYWRlciIsIkltYWdlQml0bWFwTG9hZGVyIiwiQnVmZmVyQXR0cmlidXRlIiwiSW50ZXJsZWF2ZWRCdWZmZXIiLCJJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSIsIkxpbmVhckZpbHRlciIsIkxpbmVhck1pcG1hcExpbmVhckZpbHRlciIsIlJlcGVhdFdyYXBwaW5nIiwiUG9pbnRzTWF0ZXJpYWwiLCJNYXRlcmlhbCIsIkxpbmVCYXNpY01hdGVyaWFsIiwiTWVzaFN0YW5kYXJkTWF0ZXJpYWwiLCJEb3VibGVTaWRlIiwiUHJvcGVydHlCaW5kaW5nIiwiQnVmZmVyR2VvbWV0cnkiLCJTa2lubmVkTWVzaCIsIk1lc2giLCJUcmlhbmdsZVN0cmlwRHJhd01vZGUiLCJUcmlhbmdsZUZhbkRyYXdNb2RlIiwiTGluZVNlZ21lbnRzIiwiTGluZSIsIkxpbmVMb29wIiwiUG9pbnRzIiwiR3JvdXAiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsIk1hdGhVdGlscyIsIk9ydGhvZ3JhcGhpY0NhbWVyYSIsIlNrZWxldG9uIiwiSW50ZXJwb2xhdGVMaW5lYXIiLCJBbmltYXRpb25DbGlwIiwiQm9uZSIsIk5lYXJlc3RGaWx0ZXIiLCJOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciIsIkxpbmVhck1pcG1hcE5lYXJlc3RGaWx0ZXIiLCJOZWFyZXN0TWlwbWFwTGluZWFyRmlsdGVyIiwiQ2xhbXBUb0VkZ2VXcmFwcGluZyIsIk1pcnJvcmVkUmVwZWF0V3JhcHBpbmciLCJJbnRlcnBvbGF0ZURpc2NyZXRlIiwiRnJvbnRTaWRlIiwiVGV4dHVyZSIsIlZlY3RvcktleWZyYW1lVHJhY2siLCJRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayIsIk51bWJlcktleWZyYW1lVHJhY2siLCJCb3gzIiwiU3BoZXJlIiwiSW50ZXJwb2xhbnQiLCJ0b1RyaWFuZ2xlc0RyYXdNb2RlIiwidmVyc2lvbiIsIkdMVEZMb2FkZXIiLCJjb25zdHJ1Y3RvciIsIm1hbmFnZXIiLCJkcmFjb0xvYWRlciIsImt0eDJMb2FkZXIiLCJtZXNob3B0RGVjb2RlciIsInBsdWdpbkNhbGxiYWNrcyIsInJlZ2lzdGVyIiwicGFyc2VyIiwiR0xURk1hdGVyaWFsc0NsZWFyY29hdEV4dGVuc2lvbiIsIkdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uIiwiR0xURlRleHR1cmVXZWJQRXh0ZW5zaW9uIiwiR0xURlRleHR1cmVBVklGRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc1NoZWVuRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc1RyYW5zbWlzc2lvbkV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNWb2x1bWVFeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzSW9yRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc0VtaXNzaXZlU3RyZW5ndGhFeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzU3BlY3VsYXJFeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzSXJpZGVzY2VuY2VFeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzQW5pc290cm9weUV4dGVuc2lvbiIsIkdMVEZMaWdodHNFeHRlbnNpb24iLCJHTFRGTWVzaG9wdENvbXByZXNzaW9uIiwiR0xURk1lc2hHcHVJbnN0YW5jaW5nIiwibG9hZCIsInVybCIsIm9uTG9hZCIsIm9uUHJvZ3Jlc3MiLCJvbkVycm9yIiwic2NvcGUiLCJyZXNvdXJjZVBhdGgiLCJwYXRoIiwiZXh0cmFjdFVybEJhc2UiLCJpdGVtU3RhcnQiLCJfb25FcnJvciIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJpdGVtRXJyb3IiLCJpdGVtRW5kIiwibG9hZGVyIiwic2V0UGF0aCIsInNldFJlc3BvbnNlVHlwZSIsInNldFJlcXVlc3RIZWFkZXIiLCJyZXF1ZXN0SGVhZGVyIiwic2V0V2l0aENyZWRlbnRpYWxzIiwid2l0aENyZWRlbnRpYWxzIiwiZGF0YSIsInBhcnNlIiwiZ2x0ZiIsInNldERSQUNPTG9hZGVyIiwic2V0RERTTG9hZGVyIiwiRXJyb3IiLCJzZXRLVFgyTG9hZGVyIiwic2V0TWVzaG9wdERlY29kZXIiLCJjYWxsYmFjayIsImluZGV4T2YiLCJwdXNoIiwidW5yZWdpc3RlciIsInNwbGljZSIsImpzb24iLCJleHRlbnNpb25zIiwicGx1Z2lucyIsIkpTT04iLCJBcnJheUJ1ZmZlciIsIm1hZ2ljIiwiZGVjb2RlVGV4dCIsIlVpbnQ4QXJyYXkiLCJzbGljZSIsIkJJTkFSWV9FWFRFTlNJT05fSEVBREVSX01BR0lDIiwiRVhURU5TSU9OUyIsIktIUl9CSU5BUllfR0xURiIsIkdMVEZCaW5hcnlFeHRlbnNpb24iLCJjb250ZW50IiwiYXNzZXQiLCJHTFRGUGFyc2VyIiwiY3Jvc3NPcmlnaW4iLCJmaWxlTG9hZGVyIiwiaSIsImxlbmd0aCIsInBsdWdpbiIsIm5hbWUiLCJleHRlbnNpb25zVXNlZCIsImV4dGVuc2lvbk5hbWUiLCJleHRlbnNpb25zUmVxdWlyZWQiLCJLSFJfTUFURVJJQUxTX1VOTElUIiwiR0xURk1hdGVyaWFsc1VubGl0RXh0ZW5zaW9uIiwiS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT04iLCJHTFRGRHJhY29NZXNoQ29tcHJlc3Npb25FeHRlbnNpb24iLCJLSFJfVEVYVFVSRV9UUkFOU0ZPUk0iLCJHTFRGVGV4dHVyZVRyYW5zZm9ybUV4dGVuc2lvbiIsIktIUl9NRVNIX1FVQU5USVpBVElPTiIsIkdMVEZNZXNoUXVhbnRpemF0aW9uRXh0ZW5zaW9uIiwid2FybiIsInNldEV4dGVuc2lvbnMiLCJzZXRQbHVnaW5zIiwicGFyc2VBc3luYyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiR0xURlJlZ2lzdHJ5Iiwib2JqZWN0cyIsImdldCIsImtleSIsImFkZCIsIm9iamVjdCIsInJlbW92ZSIsInJlbW92ZUFsbCIsIktIUl9MSUdIVFNfUFVOQ1RVQUwiLCJLSFJfTUFURVJJQUxTX0NMRUFSQ09BVCIsIktIUl9NQVRFUklBTFNfSU9SIiwiS0hSX01BVEVSSUFMU19TSEVFTiIsIktIUl9NQVRFUklBTFNfU1BFQ1VMQVIiLCJLSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTiIsIktIUl9NQVRFUklBTFNfSVJJREVTQ0VOQ0UiLCJLSFJfTUFURVJJQUxTX0FOSVNPVFJPUFkiLCJLSFJfTUFURVJJQUxTX1ZPTFVNRSIsIktIUl9URVhUVVJFX0JBU0lTVSIsIktIUl9NQVRFUklBTFNfRU1JU1NJVkVfU1RSRU5HVEgiLCJFWFRfVEVYVFVSRV9XRUJQIiwiRVhUX1RFWFRVUkVfQVZJRiIsIkVYVF9NRVNIT1BUX0NPTVBSRVNTSU9OIiwiRVhUX01FU0hfR1BVX0lOU1RBTkNJTkciLCJjYWNoZSIsInJlZnMiLCJ1c2VzIiwiX21hcmtEZWZzIiwibm9kZURlZnMiLCJub2RlcyIsIm5vZGVJbmRleCIsIm5vZGVMZW5ndGgiLCJub2RlRGVmIiwibGlnaHQiLCJfYWRkTm9kZVJlZiIsIl9sb2FkTGlnaHQiLCJsaWdodEluZGV4IiwiY2FjaGVLZXkiLCJkZXBlbmRlbmN5IiwibGlnaHREZWZzIiwibGlnaHRzIiwibGlnaHREZWYiLCJsaWdodE5vZGUiLCJjb2xvciIsImZyb21BcnJheSIsInJhbmdlIiwidHlwZSIsInRhcmdldCIsInBvc2l0aW9uIiwic2V0IiwiZGlzdGFuY2UiLCJzcG90IiwiaW5uZXJDb25lQW5nbGUiLCJvdXRlckNvbmVBbmdsZSIsIk1hdGgiLCJQSSIsImFuZ2xlIiwicGVudW1icmEiLCJkZWNheSIsImFzc2lnbkV4dHJhc1RvVXNlckRhdGEiLCJpbnRlbnNpdHkiLCJjcmVhdGVVbmlxdWVOYW1lIiwiZ2V0RGVwZW5kZW5jeSIsImluZGV4IiwiY3JlYXRlTm9kZUF0dGFjaG1lbnQiLCJzZWxmMiIsInRoZW4iLCJfZ2V0Tm9kZVJlZiIsImdldE1hdGVyaWFsVHlwZSIsImV4dGVuZFBhcmFtcyIsIm1hdGVyaWFsUGFyYW1zIiwibWF0ZXJpYWxEZWYiLCJwZW5kaW5nIiwib3BhY2l0eSIsIm1ldGFsbGljUm91Z2huZXNzIiwicGJyTWV0YWxsaWNSb3VnaG5lc3MiLCJBcnJheSIsImlzQXJyYXkiLCJiYXNlQ29sb3JGYWN0b3IiLCJhcnJheSIsImJhc2VDb2xvclRleHR1cmUiLCJhc3NpZ25UZXh0dXJlIiwiYWxsIiwiZXh0ZW5kTWF0ZXJpYWxQYXJhbXMiLCJtYXRlcmlhbEluZGV4IiwibWF0ZXJpYWxzIiwiZW1pc3NpdmVTdHJlbmd0aCIsImVtaXNzaXZlSW50ZW5zaXR5IiwiZXh0ZW5zaW9uIiwiY2xlYXJjb2F0RmFjdG9yIiwiY2xlYXJjb2F0IiwiY2xlYXJjb2F0VGV4dHVyZSIsImNsZWFyY29hdFJvdWdobmVzc0ZhY3RvciIsImNsZWFyY29hdFJvdWdobmVzcyIsImNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUiLCJjbGVhcmNvYXROb3JtYWxUZXh0dXJlIiwic2NhbGUiLCJjbGVhcmNvYXROb3JtYWxTY2FsZSIsImlyaWRlc2NlbmNlRmFjdG9yIiwiaXJpZGVzY2VuY2UiLCJpcmlkZXNjZW5jZVRleHR1cmUiLCJpcmlkZXNjZW5jZUlvciIsImlyaWRlc2NlbmNlSU9SIiwiaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSIsImlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bSIsImlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bSIsImlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSIsInNoZWVuQ29sb3IiLCJzaGVlblJvdWdobmVzcyIsInNoZWVuIiwic2hlZW5Db2xvckZhY3RvciIsInNoZWVuUm91Z2huZXNzRmFjdG9yIiwic2hlZW5Db2xvclRleHR1cmUiLCJzaGVlblJvdWdobmVzc1RleHR1cmUiLCJ0cmFuc21pc3Npb25GYWN0b3IiLCJ0cmFuc21pc3Npb24iLCJ0cmFuc21pc3Npb25UZXh0dXJlIiwidGhpY2tuZXNzIiwidGhpY2tuZXNzRmFjdG9yIiwidGhpY2tuZXNzVGV4dHVyZSIsImF0dGVudWF0aW9uRGlzdGFuY2UiLCJJbmZpbml0eSIsImNvbG9yQXJyYXkiLCJhdHRlbnVhdGlvbkNvbG9yIiwiaW9yIiwic3BlY3VsYXJJbnRlbnNpdHkiLCJzcGVjdWxhckZhY3RvciIsInNwZWN1bGFyVGV4dHVyZSIsInNwZWN1bGFyQ29sb3JGYWN0b3IiLCJzcGVjdWxhckNvbG9yIiwic3BlY3VsYXJDb2xvclRleHR1cmUiLCJhbmlzb3Ryb3B5U3RyZW5ndGgiLCJhbmlzb3Ryb3B5IiwiYW5pc290cm9weVJvdGF0aW9uIiwiYW5pc290cm9weVRleHR1cmUiLCJsb2FkVGV4dHVyZSIsInRleHR1cmVJbmRleCIsInRleHR1cmVEZWYiLCJ0ZXh0dXJlcyIsIm9wdGlvbnMiLCJsb2FkVGV4dHVyZUltYWdlIiwic291cmNlIiwiaXNTdXBwb3J0ZWQiLCJpbWFnZXMiLCJ0ZXh0dXJlTG9hZGVyIiwidXJpIiwiaGFuZGxlciIsImdldEhhbmRsZXIiLCJkZXRlY3RTdXBwb3J0IiwiaW1hZ2UiLCJJbWFnZSIsInNyYyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJoZWlnaHQiLCJsb2FkQnVmZmVyVmlldyIsImJ1ZmZlclZpZXciLCJidWZmZXJWaWV3cyIsImV4dGVuc2lvbkRlZiIsImJ1ZmZlciIsImRlY29kZXIiLCJzdXBwb3J0ZWQiLCJyZXMiLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsImNvdW50Iiwic3RyaWRlIiwiYnl0ZVN0cmlkZSIsImRlY29kZUdsdGZCdWZmZXJBc3luYyIsIm1vZGUiLCJmaWx0ZXIiLCJyZXMyIiwicmVhZHkiLCJyZXN1bHQiLCJkZWNvZGVHbHRmQnVmZmVyIiwiY3JlYXRlTm9kZU1lc2giLCJtZXNoIiwibWVzaERlZiIsIm1lc2hlcyIsInByaW1pdGl2ZSIsInByaW1pdGl2ZXMiLCJXRUJHTF9DT05TVEFOVFMiLCJUUklBTkdMRVMiLCJUUklBTkdMRV9TVFJJUCIsIlRSSUFOR0xFX0ZBTiIsImF0dHJpYnV0ZXNEZWYiLCJhdHRyaWJ1dGVzIiwiYWNjZXNzb3IiLCJyZXN1bHRzIiwibm9kZU9iamVjdCIsInBvcCIsImlzR3JvdXAiLCJjaGlsZHJlbiIsImluc3RhbmNlZE1lc2hlcyIsIm0iLCJwIiwicSIsInMiLCJpbnN0YW5jZWRNZXNoIiwiZ2VvbWV0cnkiLCJtYXRlcmlhbCIsIlRSQU5TTEFUSU9OIiwiZnJvbUJ1ZmZlckF0dHJpYnV0ZSIsIlJPVEFUSU9OIiwiU0NBTEUiLCJzZXRNYXRyaXhBdCIsImNvbXBvc2UiLCJhdHRyaWJ1dGVOYW1lIiwic2V0QXR0cmlidXRlIiwicHJvdG90eXBlIiwiY29weSIsImNhbGwiLCJhc3NpZ25GaW5hbE1hdGVyaWFsIiwiY2xlYXIiLCJCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEgiLCJCSU5BUllfRVhURU5TSU9OX0NIVU5LX1RZUEVTIiwiQklOIiwiYm9keSIsImhlYWRlclZpZXciLCJEYXRhVmlldyIsImhlYWRlciIsImdldFVpbnQzMiIsImNodW5rQ29udGVudHNMZW5ndGgiLCJjaHVua1ZpZXciLCJjaHVua0luZGV4IiwiY2h1bmtMZW5ndGgiLCJjaHVua1R5cGUiLCJjb250ZW50QXJyYXkiLCJwcmVsb2FkIiwiZGVjb2RlUHJpbWl0aXZlIiwiYnVmZmVyVmlld0luZGV4IiwiZ2x0ZkF0dHJpYnV0ZU1hcCIsInRocmVlQXR0cmlidXRlTWFwIiwiYXR0cmlidXRlTm9ybWFsaXplZE1hcCIsImF0dHJpYnV0ZVR5cGVNYXAiLCJ0aHJlZUF0dHJpYnV0ZU5hbWUiLCJBVFRSSUJVVEVTIiwidG9Mb3dlckNhc2UiLCJhY2Nlc3NvckRlZiIsImFjY2Vzc29ycyIsImNvbXBvbmVudFR5cGUiLCJXRUJHTF9DT01QT05FTlRfVFlQRVMiLCJub3JtYWxpemVkIiwiZGVjb2RlRHJhY29GaWxlIiwiYXR0cmlidXRlIiwiZXh0ZW5kVGV4dHVyZSIsInRleHR1cmUiLCJ0cmFuc2Zvcm0iLCJ0ZXhDb29yZCIsImNoYW5uZWwiLCJvZmZzZXQiLCJyb3RhdGlvbiIsImNsb25lIiwicmVwZWF0IiwibmVlZHNVcGRhdGUiLCJHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCIsInBhcmFtZXRlclBvc2l0aW9ucyIsInNhbXBsZVZhbHVlcyIsInNhbXBsZVNpemUiLCJyZXN1bHRCdWZmZXIiLCJjb3B5U2FtcGxlVmFsdWVfIiwidmFsdWVzIiwidmFsdWVTaXplIiwiaW50ZXJwb2xhdGVfIiwiaTEiLCJ0MCIsInQiLCJ0MSIsInN0cmlkZTIiLCJzdHJpZGUzIiwidGQiLCJwcCIsInBwcCIsIm9mZnNldDEiLCJvZmZzZXQwIiwiczIiLCJzMyIsInMwIiwiczEiLCJwMCIsIm0wIiwicDEiLCJtMSIsIl9xIiwiR0xURkN1YmljU3BsaW5lUXVhdGVybmlvbkludGVycG9sYW50Iiwibm9ybWFsaXplIiwidG9BcnJheSIsIkZMT0FUIiwiRkxPQVRfTUFUMyIsIkZMT0FUX01BVDQiLCJGTE9BVF9WRUMyIiwiRkxPQVRfVkVDMyIsIkZMT0FUX1ZFQzQiLCJMSU5FQVIiLCJSRVBFQVQiLCJTQU1QTEVSXzJEIiwiUE9JTlRTIiwiTElORVMiLCJMSU5FX0xPT1AiLCJMSU5FX1NUUklQIiwiVU5TSUdORURfQllURSIsIlVOU0lHTkVEX1NIT1JUIiwiSW50OEFycmF5IiwiSW50MTZBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJXRUJHTF9GSUxURVJTIiwiV0VCR0xfV1JBUFBJTkdTIiwiV0VCR0xfVFlQRV9TSVpFUyIsIlNDQUxBUiIsIlZFQzIiLCJWRUMzIiwiVkVDNCIsIk1BVDIiLCJNQVQzIiwiTUFUNCIsIlBPU0lUSU9OIiwiTk9STUFMIiwiVEFOR0VOVCIsIlRFWENPT1JEXzAiLCJURVhDT09SRF8xIiwiVEVYQ09PUkRfMiIsIlRFWENPT1JEXzMiLCJDT0xPUl8wIiwiV0VJR0hUU18wIiwiSk9JTlRTXzAiLCJQQVRIX1BST1BFUlRJRVMiLCJ0cmFuc2xhdGlvbiIsIndlaWdodHMiLCJJTlRFUlBPTEFUSU9OIiwiQ1VCSUNTUExJTkUiLCJTVEVQIiwiQUxQSEFfTU9ERVMiLCJPUEFRVUUiLCJNQVNLIiwiQkxFTkQiLCJjcmVhdGVEZWZhdWx0TWF0ZXJpYWwiLCJlbWlzc2l2ZSIsIm1ldGFsbmVzcyIsInJvdWdobmVzcyIsInRyYW5zcGFyZW50IiwiZGVwdGhUZXN0Iiwic2lkZSIsImFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSIsImtub3duRXh0ZW5zaW9ucyIsIm9iamVjdERlZiIsInVzZXJEYXRhIiwiZ2x0ZkV4dGVuc2lvbnMiLCJnbHRmRGVmIiwiZXh0cmFzIiwiT2JqZWN0IiwiYXNzaWduIiwiYWRkTW9ycGhUYXJnZXRzIiwidGFyZ2V0cyIsImhhc01vcnBoUG9zaXRpb24iLCJoYXNNb3JwaE5vcm1hbCIsImhhc01vcnBoQ29sb3IiLCJpbCIsInBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycyIsInBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMiLCJwZW5kaW5nQ29sb3JBY2Nlc3NvcnMiLCJwZW5kaW5nQWNjZXNzb3IiLCJub3JtYWwiLCJtb3JwaFBvc2l0aW9ucyIsIm1vcnBoTm9ybWFscyIsIm1vcnBoQ29sb3JzIiwibW9ycGhBdHRyaWJ1dGVzIiwibW9ycGhUYXJnZXRzUmVsYXRpdmUiLCJ1cGRhdGVNb3JwaFRhcmdldHMiLCJtb3JwaFRhcmdldEluZmx1ZW5jZXMiLCJ0YXJnZXROYW1lcyIsIm1vcnBoVGFyZ2V0RGljdGlvbmFyeSIsImNyZWF0ZVByaW1pdGl2ZUtleSIsInByaW1pdGl2ZURlZiIsImdlb21ldHJ5S2V5IiwiZHJhY29FeHRlbnNpb24iLCJpbmRpY2VzIiwiY3JlYXRlQXR0cmlidXRlc0tleSIsImF0dHJpYnV0ZXNLZXkiLCJrZXlzIiwic29ydCIsImdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZSIsImdldEltYWdlVVJJTWltZVR5cGUiLCJzZWFyY2giLCJfaWRlbnRpdHlNYXRyaXgiLCJhc3NvY2lhdGlvbnMiLCJNYXAiLCJwcmltaXRpdmVDYWNoZSIsIm5vZGVDYWNoZSIsIm1lc2hDYWNoZSIsImNhbWVyYUNhY2hlIiwibGlnaHRDYWNoZSIsInNvdXJjZUNhY2hlIiwidGV4dHVyZUNhY2hlIiwibm9kZU5hbWVzVXNlZCIsImlzU2FmYXJpIiwiaXNGaXJlZm94IiwiZmlyZWZveFZlcnNpb24iLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0ZXN0IiwibWF0Y2giLCJjcmVhdGVJbWFnZUJpdG1hcCIsInNldENyb3NzT3JpZ2luIiwiX2ludm9rZUFsbCIsImV4dCIsImJlZm9yZVJvb3QiLCJnZXREZXBlbmRlbmNpZXMiLCJkZXBlbmRlbmNpZXMiLCJzY2VuZSIsInNjZW5lcyIsImFuaW1hdGlvbnMiLCJjYW1lcmFzIiwiYWZ0ZXJSb290IiwiY2F0Y2giLCJza2luRGVmcyIsInNraW5zIiwibWVzaERlZnMiLCJza2luSW5kZXgiLCJza2luTGVuZ3RoIiwiam9pbnRzIiwiaXNCb25lIiwic2tpbiIsImlzU2tpbm5lZE1lc2giLCJjYW1lcmEiLCJyZWYiLCJ1cGRhdGVNYXBwaW5ncyIsIm9yaWdpbmFsIiwibWFwcGluZ3MiLCJjaGlsZCIsImVudHJpZXMiLCJfaW52b2tlT25lIiwiZnVuYyIsInVuc2hpZnQiLCJsb2FkU2NlbmUiLCJsb2FkTm9kZSIsImxvYWRNZXNoIiwibG9hZEFjY2Vzc29yIiwibG9hZEJ1ZmZlciIsImxvYWRNYXRlcmlhbCIsImxvYWRTa2luIiwibG9hZEFuaW1hdGlvbiIsImxvYWRDYW1lcmEiLCJkZWZzIiwibWFwIiwiZGVmIiwiYnVmZmVySW5kZXgiLCJidWZmZXJEZWYiLCJidWZmZXJzIiwicmVzb2x2ZVVSTCIsImJ1ZmZlclZpZXdEZWYiLCJhY2Nlc3NvckluZGV4Iiwic3BhcnNlIiwiaXRlbVNpemUiLCJUeXBlZEFycmF5IiwicGVuZGluZ0J1ZmZlclZpZXdzIiwiZWxlbWVudEJ5dGVzIiwiQllURVNfUEVSX0VMRU1FTlQiLCJpdGVtQnl0ZXMiLCJidWZmZXJBdHRyaWJ1dGUiLCJpYlNsaWNlIiwiZmxvb3IiLCJpYkNhY2hlS2V5IiwiaWIiLCJpdGVtU2l6ZUluZGljZXMiLCJUeXBlZEFycmF5SW5kaWNlcyIsImJ5dGVPZmZzZXRJbmRpY2VzIiwiYnl0ZU9mZnNldFZhbHVlcyIsInNwYXJzZUluZGljZXMiLCJzcGFyc2VWYWx1ZXMiLCJzZXRYIiwic2V0WSIsInNldFoiLCJzZXRXIiwic291cmNlSW5kZXgiLCJzb3VyY2VEZWYiLCJzYW1wbGVyIiwicHJvbWlzZSIsImxvYWRJbWFnZVNvdXJjZSIsImZsaXBZIiwic3RhcnRzV2l0aCIsInNhbXBsZXJzIiwibWFnRmlsdGVyIiwibWluRmlsdGVyIiwid3JhcFMiLCJ3cmFwVCIsIlVSTCIsInNlbGYiLCJ3ZWJraXRVUkwiLCJzb3VyY2VVUkkiLCJpc09iamVjdFVSTCIsImJsb2IiLCJCbG9iIiwibWltZVR5cGUiLCJjcmVhdGVPYmplY3RVUkwiLCJzb3VyY2VVUkkyIiwiaXNJbWFnZUJpdG1hcExvYWRlciIsImltYWdlQml0bWFwIiwicmV2b2tlT2JqZWN0VVJMIiwibWFwTmFtZSIsIm1hcERlZiIsImVuY29kaW5nIiwiZ2x0ZlJlZmVyZW5jZSIsImNvbG9yU3BhY2UiLCJ1c2VEZXJpdmF0aXZlVGFuZ2VudHMiLCJ0YW5nZW50IiwidXNlVmVydGV4Q29sb3JzIiwidXNlRmxhdFNoYWRpbmciLCJpc1BvaW50cyIsInV1aWQiLCJwb2ludHNNYXRlcmlhbCIsInNpemVBdHRlbnVhdGlvbiIsImlzTGluZSIsImxpbmVNYXRlcmlhbCIsImNhY2hlZE1hdGVyaWFsIiwidmVydGV4Q29sb3JzIiwiZmxhdFNoYWRpbmciLCJub3JtYWxTY2FsZSIsInkiLCJtYXRlcmlhbFR5cGUiLCJtYXRlcmlhbEV4dGVuc2lvbnMiLCJrbXVFeHRlbnNpb24iLCJtZXRhbGxpY0ZhY3RvciIsInJvdWdobmVzc0ZhY3RvciIsIm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSIsImRvdWJsZVNpZGVkIiwiYWxwaGFNb2RlIiwiZGVwdGhXcml0ZSIsImFscGhhVGVzdCIsImFscGhhQ3V0b2ZmIiwibm9ybWFsVGV4dHVyZSIsIm9jY2x1c2lvblRleHR1cmUiLCJzdHJlbmd0aCIsImFvTWFwSW50ZW5zaXR5IiwiZW1pc3NpdmVGYWN0b3IiLCJlbWlzc2l2ZVRleHR1cmUiLCJvcmlnaW5hbE5hbWUiLCJzYW5pdGl6ZWROYW1lIiwic2FuaXRpemVOb2RlTmFtZSIsImxvYWRHZW9tZXRyaWVzIiwiY3JlYXRlRHJhY29QcmltaXRpdmUiLCJhZGRQcmltaXRpdmVBdHRyaWJ1dGVzIiwiY2FjaGVkIiwiZ2VvbWV0cnlQcm9taXNlIiwibWVzaEluZGV4IiwiZ2VvbWV0cmllcyIsIm5vcm1hbGl6ZVNraW5XZWlnaHRzIiwiZ3JvdXAiLCJjYW1lcmFJbmRleCIsImNhbWVyYURlZiIsInBhcmFtcyIsInJhZFRvRGVnIiwieWZvdiIsImFzcGVjdFJhdGlvIiwiem5lYXIiLCJ6ZmFyIiwieG1hZyIsInltYWciLCJza2luRGVmIiwiX2xvYWROb2RlU2hhbGxvdyIsImludmVyc2VCaW5kTWF0cmljZXMiLCJqb2ludE5vZGVzIiwiYm9uZXMiLCJib25lSW52ZXJzZXMiLCJqb2ludE5vZGUiLCJtYXQiLCJhbmltYXRpb25JbmRleCIsImFuaW1hdGlvbkRlZiIsImFuaW1hdGlvbk5hbWUiLCJwZW5kaW5nTm9kZXMiLCJwZW5kaW5nSW5wdXRBY2Nlc3NvcnMiLCJwZW5kaW5nT3V0cHV0QWNjZXNzb3JzIiwicGVuZGluZ1NhbXBsZXJzIiwicGVuZGluZ1RhcmdldHMiLCJjaGFubmVscyIsIm5vZGUiLCJpbnB1dCIsInBhcmFtZXRlcnMiLCJvdXRwdXQiLCJpbnB1dEFjY2Vzc29ycyIsIm91dHB1dEFjY2Vzc29ycyIsInRyYWNrcyIsImlucHV0QWNjZXNzb3IiLCJvdXRwdXRBY2Nlc3NvciIsInVwZGF0ZU1hdHJpeCIsIlR5cGVkS2V5ZnJhbWVUcmFjayIsInRhcmdldE5hbWUiLCJpbnRlcnBvbGF0aW9uIiwidHJhdmVyc2UiLCJvdXRwdXRBcnJheSIsInNjYWxlZCIsImoiLCJqbCIsInRyYWNrIiwiY3JlYXRlSW50ZXJwb2xhbnQiLCJJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUiLCJpbnRlcnBvbGFudFR5cGUiLCJ0aW1lcyIsImdldFZhbHVlU2l6ZSIsImlzSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kR0xURkN1YmljU3BsaW5lIiwibyIsImlzTWVzaCIsIm5vZGVQZW5kaW5nIiwiY2hpbGRQZW5kaW5nIiwiY2hpbGRyZW5EZWYiLCJza2VsZXRvblBlbmRpbmciLCJza2VsZXRvbiIsImJpbmQiLCJub2RlTmFtZSIsIm1lc2hQcm9taXNlIiwiZm9yRWFjaCIsIm1hdHJpeCIsImFwcGx5TWF0cml4NCIsInF1YXRlcm5pb24iLCJoYXMiLCJzY2VuZUluZGV4Iiwic2NlbmVEZWYiLCJub2RlSWRzIiwicmVkdWNlQXNzb2NpYXRpb25zIiwicmVkdWNlZEFzc29jaWF0aW9ucyIsInZhbHVlIiwibm9kZTIiLCJjb21wdXRlQm91bmRzIiwiYm94IiwibWluIiwibWF4IiwiYm94U2NhbGUiLCJtdWx0aXBseVNjYWxhciIsIm1heERpc3BsYWNlbWVudCIsInZlY3RvciIsImFicyIsImV4cGFuZEJ5VmVjdG9yIiwiYm91bmRpbmdCb3giLCJzcGhlcmUiLCJnZXRDZW50ZXIiLCJjZW50ZXIiLCJyYWRpdXMiLCJkaXN0YW5jZVRvIiwiYm91bmRpbmdTcGhlcmUiLCJhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvciIsImdsdGZBdHRyaWJ1dGVOYW1lIiwiYWNjZXNzb3IyIiwic2V0SW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/RGBELoader.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/RGBELoader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RGBELoader: () => (/* binding */ RGBELoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nclass RGBELoader extends three__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader {\n    constructor(manager){\n        super(manager);\n        this.type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n    }\n    // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n    parse(buffer) {\n        const RGBE_RETURN_FAILURE = -1, rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {\n            switch(rgbe_error_code){\n                case rgbe_read_error:\n                    console.error(\"THREE.RGBELoader Read Error: \" + (msg || \"\"));\n                    break;\n                case rgbe_write_error:\n                    console.error(\"THREE.RGBELoader Write Error: \" + (msg || \"\"));\n                    break;\n                case rgbe_format_error:\n                    console.error(\"THREE.RGBELoader Bad File Format: \" + (msg || \"\"));\n                    break;\n                default:\n                case rgbe_memory_error:\n                    console.error(\"THREE.RGBELoader: Error: \" + (msg || \"\"));\n            }\n            return RGBE_RETURN_FAILURE;\n        }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = \"\\n\", fgets = function(buffer2, lineLimit, consume) {\n            const chunkSize = 128;\n            lineLimit = !lineLimit ? 1024 : lineLimit;\n            let p = buffer2.pos, i = -1, len = 0, s = \"\", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n            while(0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength){\n                s += chunk;\n                len += chunk.length;\n                p += chunkSize;\n                chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n            }\n            if (-1 < i) {\n                if (false !== consume) buffer2.pos += len + i + 1;\n                return s + chunk.slice(0, i);\n            }\n            return false;\n        }, RGBE_ReadHeader = function(buffer2) {\n            const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, header = {\n                valid: 0,\n                string: \"\",\n                comments: \"\",\n                programtype: \"RGBE\",\n                format: \"\",\n                gamma: 1,\n                exposure: 1,\n                width: 0,\n                height: 0\n            };\n            let line, match;\n            if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {\n                return rgbe_error(rgbe_read_error, \"no header found\");\n            }\n            if (!(match = line.match(magic_token_re))) {\n                return rgbe_error(rgbe_format_error, \"bad initial token\");\n            }\n            header.valid |= RGBE_VALID_PROGRAMTYPE;\n            header.programtype = match[1];\n            header.string += line + \"\\n\";\n            while(true){\n                line = fgets(buffer2);\n                if (false === line) break;\n                header.string += line + \"\\n\";\n                if (\"#\" === line.charAt(0)) {\n                    header.comments += line + \"\\n\";\n                    continue;\n                }\n                if (match = line.match(gamma_re)) {\n                    header.gamma = parseFloat(match[1]);\n                }\n                if (match = line.match(exposure_re)) {\n                    header.exposure = parseFloat(match[1]);\n                }\n                if (match = line.match(format_re)) {\n                    header.valid |= RGBE_VALID_FORMAT;\n                    header.format = match[1];\n                }\n                if (match = line.match(dimensions_re)) {\n                    header.valid |= RGBE_VALID_DIMENSIONS;\n                    header.height = parseInt(match[1], 10);\n                    header.width = parseInt(match[2], 10);\n                }\n                if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n            }\n            if (!(header.valid & RGBE_VALID_FORMAT)) {\n                return rgbe_error(rgbe_format_error, \"missing format specifier\");\n            }\n            if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n                return rgbe_error(rgbe_format_error, \"missing image size specifier\");\n            }\n            return header;\n        }, RGBE_ReadPixels_RLE = function(buffer2, w, h) {\n            const scanline_width = w;\n            if (// run length encoding is not allowed so read flat\n            scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded\n            2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128) {\n                return new Uint8Array(buffer2);\n            }\n            if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {\n                return rgbe_error(rgbe_format_error, \"wrong scanline width\");\n            }\n            const data_rgba = new Uint8Array(4 * w * h);\n            if (!data_rgba.length) {\n                return rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n            }\n            let offset = 0, pos = 0;\n            const ptr_end = 4 * scanline_width;\n            const rgbeStart = new Uint8Array(4);\n            const scanline_buffer = new Uint8Array(ptr_end);\n            let num_scanlines = h;\n            while(num_scanlines > 0 && pos < buffer2.byteLength){\n                if (pos + 4 > buffer2.byteLength) {\n                    return rgbe_error(rgbe_read_error);\n                }\n                rgbeStart[0] = buffer2[pos++];\n                rgbeStart[1] = buffer2[pos++];\n                rgbeStart[2] = buffer2[pos++];\n                rgbeStart[3] = buffer2[pos++];\n                if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n                    return rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n                }\n                let ptr = 0, count;\n                while(ptr < ptr_end && pos < buffer2.byteLength){\n                    count = buffer2[pos++];\n                    const isEncodedRun = count > 128;\n                    if (isEncodedRun) count -= 128;\n                    if (0 === count || ptr + count > ptr_end) {\n                        return rgbe_error(rgbe_format_error, \"bad scanline data\");\n                    }\n                    if (isEncodedRun) {\n                        const byteValue = buffer2[pos++];\n                        for(let i = 0; i < count; i++){\n                            scanline_buffer[ptr++] = byteValue;\n                        }\n                    } else {\n                        scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);\n                        ptr += count;\n                        pos += count;\n                    }\n                }\n                const l = scanline_width;\n                for(let i = 0; i < l; i++){\n                    let off = 0;\n                    data_rgba[offset] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 1] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 2] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 3] = scanline_buffer[i + off];\n                    offset += 4;\n                }\n                num_scanlines--;\n            }\n            return data_rgba;\n        };\n        const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2, e - 128) / 255;\n            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n            destArray[destOffset + 3] = 1;\n        };\n        const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2, e - 128) / 255;\n            destArray[destOffset + 0] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n            destArray[destOffset + 1] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n            destArray[destOffset + 2] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n            destArray[destOffset + 3] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(1);\n        };\n        const byteArray = new Uint8Array(buffer);\n        byteArray.pos = 0;\n        const rgbe_header_info = RGBE_ReadHeader(byteArray);\n        if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n            const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n            if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n                let data, type;\n                let numElements;\n                switch(this.type){\n                    case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                        numElements = image_rgba_data.length / 4;\n                        const floatArray = new Float32Array(numElements * 4);\n                        for(let j = 0; j < numElements; j++){\n                            RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n                        }\n                        data = floatArray;\n                        type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                        numElements = image_rgba_data.length / 4;\n                        const halfArray = new Uint16Array(numElements * 4);\n                        for(let j = 0; j < numElements; j++){\n                            RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n                        }\n                        data = halfArray;\n                        type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n                        break;\n                    default:\n                        console.error(\"THREE.RGBELoader: unsupported type: \", this.type);\n                        break;\n                }\n                return {\n                    width: w,\n                    height: h,\n                    data,\n                    header: rgbe_header_info.string,\n                    gamma: rgbe_header_info.gamma,\n                    exposure: rgbe_header_info.exposure,\n                    type\n                };\n            }\n        }\n        return null;\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            switch(texture.type){\n                case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    if (\"colorSpace\" in texture) texture.colorSpace = \"srgb-linear\";\n                    else texture.encoding = 3e3;\n                    texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n                    texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n                    texture.generateMipmaps = false;\n                    texture.flipY = true;\n                    break;\n            }\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n //# sourceMappingURL=RGBELoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvUkdCRUxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2RjtBQUM3RixNQUFNSyxtQkFBbUJMLG9EQUFpQkE7SUFDeENNLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUdQLGdEQUFhQTtJQUMzQjtJQUNBLDhEQUE4RDtJQUM5RFEsTUFBTUMsTUFBTSxFQUFFO1FBQ1osTUFBTUMsc0JBQXNCLENBQUMsR0FBR0Msa0JBQWtCLEdBQUdDLG1CQUFtQixHQUFHQyxvQkFBb0IsR0FBR0Msb0JBQW9CLEdBQUdDLGFBQWEsU0FBU0MsZUFBZSxFQUFFQyxHQUFHO1lBQ2pLLE9BQVFEO2dCQUNOLEtBQUtMO29CQUNITyxRQUFRQyxLQUFLLENBQUMsa0NBQW1DRixDQUFBQSxPQUFPLEVBQUM7b0JBQ3pEO2dCQUNGLEtBQUtMO29CQUNITSxRQUFRQyxLQUFLLENBQUMsbUNBQW9DRixDQUFBQSxPQUFPLEVBQUM7b0JBQzFEO2dCQUNGLEtBQUtKO29CQUNISyxRQUFRQyxLQUFLLENBQUMsdUNBQXdDRixDQUFBQSxPQUFPLEVBQUM7b0JBQzlEO2dCQUNGO2dCQUNBLEtBQUtIO29CQUNISSxRQUFRQyxLQUFLLENBQUMsOEJBQStCRixDQUFBQSxPQUFPLEVBQUM7WUFDekQ7WUFDQSxPQUFPUDtRQUNULEdBQUdVLHlCQUF5QixHQUFHQyxvQkFBb0IsR0FBR0Msd0JBQXdCLEdBQUdDLFVBQVUsTUFBTUMsUUFBUSxTQUFTQyxPQUFPLEVBQUVDLFNBQVMsRUFBRUMsT0FBTztZQUMzSSxNQUFNQyxZQUFZO1lBQ2xCRixZQUFZLENBQUNBLFlBQVksT0FBT0E7WUFDaEMsSUFBSUcsSUFBSUosUUFBUUssR0FBRyxFQUFFQyxJQUFJLENBQUMsR0FBR0MsTUFBTSxHQUFHQyxJQUFJLElBQUlDLFFBQVFDLE9BQU9DLFlBQVksQ0FBQ0MsS0FBSyxDQUFDLE1BQU0s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SS1FbmdsaXNoLy4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL1JHQkVMb2FkZXIuanM/N2FiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEYXRhVGV4dHVyZUxvYWRlciwgSGFsZkZsb2F0VHlwZSwgRmxvYXRUeXBlLCBEYXRhVXRpbHMsIExpbmVhckZpbHRlciB9IGZyb20gXCJ0aHJlZVwiO1xuY2xhc3MgUkdCRUxvYWRlciBleHRlbmRzIERhdGFUZXh0dXJlTG9hZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgIHRoaXMudHlwZSA9IEhhbGZGbG9hdFR5cGU7XG4gIH1cbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cuZ3JhcGhpY3MuY29ybmVsbC5lZHUvfmJqdy9yZ2JlLmh0bWxcbiAgcGFyc2UoYnVmZmVyKSB7XG4gICAgY29uc3QgUkdCRV9SRVRVUk5fRkFJTFVSRSA9IC0xLCByZ2JlX3JlYWRfZXJyb3IgPSAxLCByZ2JlX3dyaXRlX2Vycm9yID0gMiwgcmdiZV9mb3JtYXRfZXJyb3IgPSAzLCByZ2JlX21lbW9yeV9lcnJvciA9IDQsIHJnYmVfZXJyb3IgPSBmdW5jdGlvbihyZ2JlX2Vycm9yX2NvZGUsIG1zZykge1xuICAgICAgc3dpdGNoIChyZ2JlX2Vycm9yX2NvZGUpIHtcbiAgICAgICAgY2FzZSByZ2JlX3JlYWRfZXJyb3I6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLlJHQkVMb2FkZXIgUmVhZCBFcnJvcjogXCIgKyAobXNnIHx8IFwiXCIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSByZ2JlX3dyaXRlX2Vycm9yOlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5SR0JFTG9hZGVyIFdyaXRlIEVycm9yOiBcIiArIChtc2cgfHwgXCJcIikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHJnYmVfZm9ybWF0X2Vycm9yOlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5SR0JFTG9hZGVyIEJhZCBGaWxlIEZvcm1hdDogXCIgKyAobXNnIHx8IFwiXCIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2FzZSByZ2JlX21lbW9yeV9lcnJvcjpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuUkdCRUxvYWRlcjogRXJyb3I6IFwiICsgKG1zZyB8fCBcIlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUkdCRV9SRVRVUk5fRkFJTFVSRTtcbiAgICB9LCBSR0JFX1ZBTElEX1BST0dSQU1UWVBFID0gMSwgUkdCRV9WQUxJRF9GT1JNQVQgPSAyLCBSR0JFX1ZBTElEX0RJTUVOU0lPTlMgPSA0LCBORVdMSU5FID0gXCJcXG5cIiwgZmdldHMgPSBmdW5jdGlvbihidWZmZXIyLCBsaW5lTGltaXQsIGNvbnN1bWUpIHtcbiAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IDEyODtcbiAgICAgIGxpbmVMaW1pdCA9ICFsaW5lTGltaXQgPyAxMDI0IDogbGluZUxpbWl0O1xuICAgICAgbGV0IHAgPSBidWZmZXIyLnBvcywgaSA9IC0xLCBsZW4gPSAwLCBzID0gXCJcIiwgY2h1bmsgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShidWZmZXIyLnN1YmFycmF5KHAsIHAgKyBjaHVua1NpemUpKSk7XG4gICAgICB3aGlsZSAoMCA+IChpID0gY2h1bmsuaW5kZXhPZihORVdMSU5FKSkgJiYgbGVuIDwgbGluZUxpbWl0ICYmIHAgPCBidWZmZXIyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcyArPSBjaHVuaztcbiAgICAgICAgbGVuICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgcCArPSBjaHVua1NpemU7XG4gICAgICAgIGNodW5rICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcjIuc3ViYXJyYXkocCwgcCArIGNodW5rU2l6ZSkpKTtcbiAgICAgIH1cbiAgICAgIGlmICgtMSA8IGkpIHtcbiAgICAgICAgaWYgKGZhbHNlICE9PSBjb25zdW1lKVxuICAgICAgICAgIGJ1ZmZlcjIucG9zICs9IGxlbiArIGkgKyAxO1xuICAgICAgICByZXR1cm4gcyArIGNodW5rLnNsaWNlKDAsIGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIFJHQkVfUmVhZEhlYWRlciA9IGZ1bmN0aW9uKGJ1ZmZlcjIpIHtcbiAgICAgIGNvbnN0IG1hZ2ljX3Rva2VuX3JlID0gL14jXFw/KFxcUyspLywgZ2FtbWFfcmUgPSAvXlxccypHQU1NQVxccyo9XFxzKihcXGQrKFxcLlxcZCspPylcXHMqJC8sIGV4cG9zdXJlX3JlID0gL15cXHMqRVhQT1NVUkVcXHMqPVxccyooXFxkKyhcXC5cXGQrKT8pXFxzKiQvLCBmb3JtYXRfcmUgPSAvXlxccypGT1JNQVQ9KFxcUyspXFxzKiQvLCBkaW1lbnNpb25zX3JlID0gL15cXHMqXFwtWVxccysoXFxkKylcXHMrXFwrWFxccysoXFxkKylcXHMqJC8sIGhlYWRlciA9IHtcbiAgICAgICAgdmFsaWQ6IDAsXG4gICAgICAgIHN0cmluZzogXCJcIixcbiAgICAgICAgY29tbWVudHM6IFwiXCIsXG4gICAgICAgIHByb2dyYW10eXBlOiBcIlJHQkVcIixcbiAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICBnYW1tYTogMSxcbiAgICAgICAgZXhwb3N1cmU6IDEsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH07XG4gICAgICBsZXQgbGluZSwgbWF0Y2g7XG4gICAgICBpZiAoYnVmZmVyMi5wb3MgPj0gYnVmZmVyMi5ieXRlTGVuZ3RoIHx8ICEobGluZSA9IGZnZXRzKGJ1ZmZlcjIpKSkge1xuICAgICAgICByZXR1cm4gcmdiZV9lcnJvcihyZ2JlX3JlYWRfZXJyb3IsIFwibm8gaGVhZGVyIGZvdW5kXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCEobWF0Y2ggPSBsaW5lLm1hdGNoKG1hZ2ljX3Rva2VuX3JlKSkpIHtcbiAgICAgICAgcmV0dXJuIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwiYmFkIGluaXRpYWwgdG9rZW5cIik7XG4gICAgICB9XG4gICAgICBoZWFkZXIudmFsaWQgfD0gUkdCRV9WQUxJRF9QUk9HUkFNVFlQRTtcbiAgICAgIGhlYWRlci5wcm9ncmFtdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgaGVhZGVyLnN0cmluZyArPSBsaW5lICsgXCJcXG5cIjtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxpbmUgPSBmZ2V0cyhidWZmZXIyKTtcbiAgICAgICAgaWYgKGZhbHNlID09PSBsaW5lKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBoZWFkZXIuc3RyaW5nICs9IGxpbmUgKyBcIlxcblwiO1xuICAgICAgICBpZiAoXCIjXCIgPT09IGxpbmUuY2hhckF0KDApKSB7XG4gICAgICAgICAgaGVhZGVyLmNvbW1lbnRzICs9IGxpbmUgKyBcIlxcblwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goZ2FtbWFfcmUpKSB7XG4gICAgICAgICAgaGVhZGVyLmdhbW1hID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoID0gbGluZS5tYXRjaChleHBvc3VyZV9yZSkpIHtcbiAgICAgICAgICBoZWFkZXIuZXhwb3N1cmUgPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKGZvcm1hdF9yZSkpIHtcbiAgICAgICAgICBoZWFkZXIudmFsaWQgfD0gUkdCRV9WQUxJRF9GT1JNQVQ7XG4gICAgICAgICAgaGVhZGVyLmZvcm1hdCA9IG1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goZGltZW5zaW9uc19yZSkpIHtcbiAgICAgICAgICBoZWFkZXIudmFsaWQgfD0gUkdCRV9WQUxJRF9ESU1FTlNJT05TO1xuICAgICAgICAgIGhlYWRlci5oZWlnaHQgPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICAgIGhlYWRlci53aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlci52YWxpZCAmIFJHQkVfVkFMSURfRk9STUFUICYmIGhlYWRlci52YWxpZCAmIFJHQkVfVkFMSURfRElNRU5TSU9OUylcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICghKGhlYWRlci52YWxpZCAmIFJHQkVfVkFMSURfRk9STUFUKSkge1xuICAgICAgICByZXR1cm4gcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgXCJtaXNzaW5nIGZvcm1hdCBzcGVjaWZpZXJcIik7XG4gICAgICB9XG4gICAgICBpZiAoIShoZWFkZXIudmFsaWQgJiBSR0JFX1ZBTElEX0RJTUVOU0lPTlMpKSB7XG4gICAgICAgIHJldHVybiByZ2JlX2Vycm9yKHJnYmVfZm9ybWF0X2Vycm9yLCBcIm1pc3NpbmcgaW1hZ2Ugc2l6ZSBzcGVjaWZpZXJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGVhZGVyO1xuICAgIH0sIFJHQkVfUmVhZFBpeGVsc19STEUgPSBmdW5jdGlvbihidWZmZXIyLCB3LCBoKSB7XG4gICAgICBjb25zdCBzY2FubGluZV93aWR0aCA9IHc7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIHJ1biBsZW5ndGggZW5jb2RpbmcgaXMgbm90IGFsbG93ZWQgc28gcmVhZCBmbGF0XG4gICAgICAgIHNjYW5saW5lX3dpZHRoIDwgOCB8fCBzY2FubGluZV93aWR0aCA+IDMyNzY3IHx8IC8vIHRoaXMgZmlsZSBpcyBub3QgcnVuIGxlbmd0aCBlbmNvZGVkXG4gICAgICAgIDIgIT09IGJ1ZmZlcjJbMF0gfHwgMiAhPT0gYnVmZmVyMlsxXSB8fCBidWZmZXIyWzJdICYgMTI4XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcjIpO1xuICAgICAgfVxuICAgICAgaWYgKHNjYW5saW5lX3dpZHRoICE9PSAoYnVmZmVyMlsyXSA8PCA4IHwgYnVmZmVyMlszXSkpIHtcbiAgICAgICAgcmV0dXJuIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwid3Jvbmcgc2NhbmxpbmUgd2lkdGhcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhX3JnYmEgPSBuZXcgVWludDhBcnJheSg0ICogdyAqIGgpO1xuICAgICAgaWYgKCFkYXRhX3JnYmEubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZ2JlX2Vycm9yKHJnYmVfbWVtb3J5X2Vycm9yLCBcInVuYWJsZSB0byBhbGxvY2F0ZSBidWZmZXIgc3BhY2VcIik7XG4gICAgICB9XG4gICAgICBsZXQgb2Zmc2V0ID0gMCwgcG9zID0gMDtcbiAgICAgIGNvbnN0IHB0cl9lbmQgPSA0ICogc2NhbmxpbmVfd2lkdGg7XG4gICAgICBjb25zdCByZ2JlU3RhcnQgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgIGNvbnN0IHNjYW5saW5lX2J1ZmZlciA9IG5ldyBVaW50OEFycmF5KHB0cl9lbmQpO1xuICAgICAgbGV0IG51bV9zY2FubGluZXMgPSBoO1xuICAgICAgd2hpbGUgKG51bV9zY2FubGluZXMgPiAwICYmIHBvcyA8IGJ1ZmZlcjIuYnl0ZUxlbmd0aCkge1xuICAgICAgICBpZiAocG9zICsgNCA+IGJ1ZmZlcjIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiByZ2JlX2Vycm9yKHJnYmVfcmVhZF9lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmdiZVN0YXJ0WzBdID0gYnVmZmVyMltwb3MrK107XG4gICAgICAgIHJnYmVTdGFydFsxXSA9IGJ1ZmZlcjJbcG9zKytdO1xuICAgICAgICByZ2JlU3RhcnRbMl0gPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgcmdiZVN0YXJ0WzNdID0gYnVmZmVyMltwb3MrK107XG4gICAgICAgIGlmICgyICE9IHJnYmVTdGFydFswXSB8fCAyICE9IHJnYmVTdGFydFsxXSB8fCAocmdiZVN0YXJ0WzJdIDw8IDggfCByZ2JlU3RhcnRbM10pICE9IHNjYW5saW5lX3dpZHRoKSB7XG4gICAgICAgICAgcmV0dXJuIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwiYmFkIHJnYmUgc2NhbmxpbmUgZm9ybWF0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwdHIgPSAwLCBjb3VudDtcbiAgICAgICAgd2hpbGUgKHB0ciA8IHB0cl9lbmQgJiYgcG9zIDwgYnVmZmVyMi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgY291bnQgPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgICBjb25zdCBpc0VuY29kZWRSdW4gPSBjb3VudCA+IDEyODtcbiAgICAgICAgICBpZiAoaXNFbmNvZGVkUnVuKVxuICAgICAgICAgICAgY291bnQgLT0gMTI4O1xuICAgICAgICAgIGlmICgwID09PSBjb3VudCB8fCBwdHIgKyBjb3VudCA+IHB0cl9lbmQpIHtcbiAgICAgICAgICAgIHJldHVybiByZ2JlX2Vycm9yKHJnYmVfZm9ybWF0X2Vycm9yLCBcImJhZCBzY2FubGluZSBkYXRhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNFbmNvZGVkUnVuKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlVmFsdWUgPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICBzY2FubGluZV9idWZmZXJbcHRyKytdID0gYnl0ZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2FubGluZV9idWZmZXIuc2V0KGJ1ZmZlcjIuc3ViYXJyYXkocG9zLCBwb3MgKyBjb3VudCksIHB0cik7XG4gICAgICAgICAgICBwdHIgKz0gY291bnQ7XG4gICAgICAgICAgICBwb3MgKz0gY291bnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGwgPSBzY2FubGluZV93aWR0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBsZXQgb2ZmID0gMDtcbiAgICAgICAgICBkYXRhX3JnYmFbb2Zmc2V0XSA9IHNjYW5saW5lX2J1ZmZlcltpICsgb2ZmXTtcbiAgICAgICAgICBvZmYgKz0gc2NhbmxpbmVfd2lkdGg7XG4gICAgICAgICAgZGF0YV9yZ2JhW29mZnNldCArIDFdID0gc2NhbmxpbmVfYnVmZmVyW2kgKyBvZmZdO1xuICAgICAgICAgIG9mZiArPSBzY2FubGluZV93aWR0aDtcbiAgICAgICAgICBkYXRhX3JnYmFbb2Zmc2V0ICsgMl0gPSBzY2FubGluZV9idWZmZXJbaSArIG9mZl07XG4gICAgICAgICAgb2ZmICs9IHNjYW5saW5lX3dpZHRoO1xuICAgICAgICAgIGRhdGFfcmdiYVtvZmZzZXQgKyAzXSA9IHNjYW5saW5lX2J1ZmZlcltpICsgb2ZmXTtcbiAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBudW1fc2NhbmxpbmVzLS07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YV9yZ2JhO1xuICAgIH07XG4gICAgY29uc3QgUkdCRUJ5dGVUb1JHQkZsb2F0ID0gZnVuY3Rpb24oc291cmNlQXJyYXksIHNvdXJjZU9mZnNldCwgZGVzdEFycmF5LCBkZXN0T2Zmc2V0KSB7XG4gICAgICBjb25zdCBlID0gc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgM107XG4gICAgICBjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIGUgLSAxMjgpIC8gMjU1O1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAwXSA9IHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDBdICogc2NhbGU7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDFdID0gc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMV0gKiBzY2FsZTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMl0gPSBzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAyXSAqIHNjYWxlO1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAzXSA9IDE7XG4gICAgfTtcbiAgICBjb25zdCBSR0JFQnl0ZVRvUkdCSGFsZiA9IGZ1bmN0aW9uKHNvdXJjZUFycmF5LCBzb3VyY2VPZmZzZXQsIGRlc3RBcnJheSwgZGVzdE9mZnNldCkge1xuICAgICAgY29uc3QgZSA9IHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDNdO1xuICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCBlIC0gMTI4KSAvIDI1NTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMF0gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoTWF0aC5taW4oc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMF0gKiBzY2FsZSwgNjU1MDQpKTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMV0gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoTWF0aC5taW4oc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMV0gKiBzY2FsZSwgNjU1MDQpKTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMl0gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoTWF0aC5taW4oc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMl0gKiBzY2FsZSwgNjU1MDQpKTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgM10gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoMSk7XG4gICAgfTtcbiAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGJ5dGVBcnJheS5wb3MgPSAwO1xuICAgIGNvbnN0IHJnYmVfaGVhZGVyX2luZm8gPSBSR0JFX1JlYWRIZWFkZXIoYnl0ZUFycmF5KTtcbiAgICBpZiAoUkdCRV9SRVRVUk5fRkFJTFVSRSAhPT0gcmdiZV9oZWFkZXJfaW5mbykge1xuICAgICAgY29uc3QgdyA9IHJnYmVfaGVhZGVyX2luZm8ud2lkdGgsIGggPSByZ2JlX2hlYWRlcl9pbmZvLmhlaWdodCwgaW1hZ2VfcmdiYV9kYXRhID0gUkdCRV9SZWFkUGl4ZWxzX1JMRShieXRlQXJyYXkuc3ViYXJyYXkoYnl0ZUFycmF5LnBvcyksIHcsIGgpO1xuICAgICAgaWYgKFJHQkVfUkVUVVJOX0ZBSUxVUkUgIT09IGltYWdlX3JnYmFfZGF0YSkge1xuICAgICAgICBsZXQgZGF0YSwgdHlwZTtcbiAgICAgICAgbGV0IG51bUVsZW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICAgICAgbnVtRWxlbWVudHMgPSBpbWFnZV9yZ2JhX2RhdGEubGVuZ3RoIC8gNDtcbiAgICAgICAgICAgIGNvbnN0IGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KG51bUVsZW1lbnRzICogNCk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUVsZW1lbnRzOyBqKyspIHtcbiAgICAgICAgICAgICAgUkdCRUJ5dGVUb1JHQkZsb2F0KGltYWdlX3JnYmFfZGF0YSwgaiAqIDQsIGZsb2F0QXJyYXksIGogKiA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBmbG9hdEFycmF5O1xuICAgICAgICAgICAgdHlwZSA9IEZsb2F0VHlwZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgSGFsZkZsb2F0VHlwZTpcbiAgICAgICAgICAgIG51bUVsZW1lbnRzID0gaW1hZ2VfcmdiYV9kYXRhLmxlbmd0aCAvIDQ7XG4gICAgICAgICAgICBjb25zdCBoYWxmQXJyYXkgPSBuZXcgVWludDE2QXJyYXkobnVtRWxlbWVudHMgKiA0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtRWxlbWVudHM7IGorKykge1xuICAgICAgICAgICAgICBSR0JFQnl0ZVRvUkdCSGFsZihpbWFnZV9yZ2JhX2RhdGEsIGogKiA0LCBoYWxmQXJyYXksIGogKiA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBoYWxmQXJyYXk7XG4gICAgICAgICAgICB0eXBlID0gSGFsZkZsb2F0VHlwZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuUkdCRUxvYWRlcjogdW5zdXBwb3J0ZWQgdHlwZTogXCIsIHRoaXMudHlwZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIGhlYWRlcjogcmdiZV9oZWFkZXJfaW5mby5zdHJpbmcsXG4gICAgICAgICAgZ2FtbWE6IHJnYmVfaGVhZGVyX2luZm8uZ2FtbWEsXG4gICAgICAgICAgZXhwb3N1cmU6IHJnYmVfaGVhZGVyX2luZm8uZXhwb3N1cmUsXG4gICAgICAgICAgdHlwZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzZXREYXRhVHlwZSh2YWx1ZSkge1xuICAgIHRoaXMudHlwZSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICBmdW5jdGlvbiBvbkxvYWRDYWxsYmFjayh0ZXh0dXJlLCB0ZXhEYXRhKSB7XG4gICAgICBzd2l0Y2ggKHRleHR1cmUudHlwZSkge1xuICAgICAgICBjYXNlIEZsb2F0VHlwZTpcbiAgICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICAgIGlmIChcImNvbG9yU3BhY2VcIiBpbiB0ZXh0dXJlKVxuICAgICAgICAgICAgdGV4dHVyZS5jb2xvclNwYWNlID0gXCJzcmdiLWxpbmVhclwiO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRleHR1cmUuZW5jb2RpbmcgPSAzZTM7XG4gICAgICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG4gICAgICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG4gICAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICAgICAgICB0ZXh0dXJlLmZsaXBZID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChvbkxvYWQpXG4gICAgICAgIG9uTG9hZCh0ZXh0dXJlLCB0ZXhEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmxvYWQodXJsLCBvbkxvYWRDYWxsYmFjaywgb25Qcm9ncmVzcywgb25FcnJvcik7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIFJHQkVMb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SR0JFTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkRhdGFUZXh0dXJlTG9hZGVyIiwiSGFsZkZsb2F0VHlwZSIsIkZsb2F0VHlwZSIsIkRhdGFVdGlscyIsIkxpbmVhckZpbHRlciIsIlJHQkVMb2FkZXIiLCJjb25zdHJ1Y3RvciIsIm1hbmFnZXIiLCJ0eXBlIiwicGFyc2UiLCJidWZmZXIiLCJSR0JFX1JFVFVSTl9GQUlMVVJFIiwicmdiZV9yZWFkX2Vycm9yIiwicmdiZV93cml0ZV9lcnJvciIsInJnYmVfZm9ybWF0X2Vycm9yIiwicmdiZV9tZW1vcnlfZXJyb3IiLCJyZ2JlX2Vycm9yIiwicmdiZV9lcnJvcl9jb2RlIiwibXNnIiwiY29uc29sZSIsImVycm9yIiwiUkdCRV9WQUxJRF9QUk9HUkFNVFlQRSIsIlJHQkVfVkFMSURfRk9STUFUIiwiUkdCRV9WQUxJRF9ESU1FTlNJT05TIiwiTkVXTElORSIsImZnZXRzIiwiYnVmZmVyMiIsImxpbmVMaW1pdCIsImNvbnN1bWUiLCJjaHVua1NpemUiLCJwIiwicG9zIiwiaSIsImxlbiIsInMiLCJjaHVuayIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5IiwiVWludDE2QXJyYXkiLCJzdWJhcnJheSIsImluZGV4T2YiLCJieXRlTGVuZ3RoIiwibGVuZ3RoIiwic2xpY2UiLCJSR0JFX1JlYWRIZWFkZXIiLCJtYWdpY190b2tlbl9yZSIsImdhbW1hX3JlIiwiZXhwb3N1cmVfcmUiLCJmb3JtYXRfcmUiLCJkaW1lbnNpb25zX3JlIiwiaGVhZGVyIiwidmFsaWQiLCJzdHJpbmciLCJjb21tZW50cyIsInByb2dyYW10eXBlIiwiZm9ybWF0IiwiZ2FtbWEiLCJleHBvc3VyZSIsIndpZHRoIiwiaGVpZ2h0IiwibGluZSIsIm1hdGNoIiwiY2hhckF0IiwicGFyc2VGbG9hdCIsInBhcnNlSW50IiwiUkdCRV9SZWFkUGl4ZWxzX1JMRSIsInciLCJoIiwic2NhbmxpbmVfd2lkdGgiLCJVaW50OEFycmF5IiwiZGF0YV9yZ2JhIiwib2Zmc2V0IiwicHRyX2VuZCIsInJnYmVTdGFydCIsInNjYW5saW5lX2J1ZmZlciIsIm51bV9zY2FubGluZXMiLCJwdHIiLCJjb3VudCIsImlzRW5jb2RlZFJ1biIsImJ5dGVWYWx1ZSIsInNldCIsImwiLCJvZmYiLCJSR0JFQnl0ZVRvUkdCRmxvYXQiLCJzb3VyY2VBcnJheSIsInNvdXJjZU9mZnNldCIsImRlc3RBcnJheSIsImRlc3RPZmZzZXQiLCJlIiwic2NhbGUiLCJNYXRoIiwicG93IiwiUkdCRUJ5dGVUb1JHQkhhbGYiLCJ0b0hhbGZGbG9hdCIsIm1pbiIsImJ5dGVBcnJheSIsInJnYmVfaGVhZGVyX2luZm8iLCJpbWFnZV9yZ2JhX2RhdGEiLCJkYXRhIiwibnVtRWxlbWVudHMiLCJmbG9hdEFycmF5IiwiRmxvYXQzMkFycmF5IiwiaiIsImhhbGZBcnJheSIsInNldERhdGFUeXBlIiwidmFsdWUiLCJsb2FkIiwidXJsIiwib25Mb2FkIiwib25Qcm9ncmVzcyIsIm9uRXJyb3IiLCJvbkxvYWRDYWxsYmFjayIsInRleHR1cmUiLCJ0ZXhEYXRhIiwiY29sb3JTcGFjZSIsImVuY29kaW5nIiwibWluRmlsdGVyIiwibWFnRmlsdGVyIiwiZ2VuZXJhdGVNaXBtYXBzIiwiZmxpcFkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/RGBELoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/node_modules/fflate/esm/index.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/three-stdlib/node_modules/fflate/esm/index.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCompress: () => (/* binding */ AsyncGzip),\n/* harmony export */   AsyncDecompress: () => (/* binding */ AsyncDecompress),\n/* harmony export */   AsyncDeflate: () => (/* binding */ AsyncDeflate),\n/* harmony export */   AsyncGunzip: () => (/* binding */ AsyncGunzip),\n/* harmony export */   AsyncGzip: () => (/* binding */ AsyncGzip),\n/* harmony export */   AsyncInflate: () => (/* binding */ AsyncInflate),\n/* harmony export */   AsyncUnzipInflate: () => (/* binding */ AsyncUnzipInflate),\n/* harmony export */   AsyncUnzlib: () => (/* binding */ AsyncUnzlib),\n/* harmony export */   AsyncZipDeflate: () => (/* binding */ AsyncZipDeflate),\n/* harmony export */   AsyncZlib: () => (/* binding */ AsyncZlib),\n/* harmony export */   Compress: () => (/* binding */ Gzip),\n/* harmony export */   DecodeUTF8: () => (/* binding */ DecodeUTF8),\n/* harmony export */   Decompress: () => (/* binding */ Decompress),\n/* harmony export */   Deflate: () => (/* binding */ Deflate),\n/* harmony export */   EncodeUTF8: () => (/* binding */ EncodeUTF8),\n/* harmony export */   Gunzip: () => (/* binding */ Gunzip),\n/* harmony export */   Gzip: () => (/* binding */ Gzip),\n/* harmony export */   Inflate: () => (/* binding */ Inflate),\n/* harmony export */   Unzip: () => (/* binding */ Unzip),\n/* harmony export */   UnzipInflate: () => (/* binding */ UnzipInflate),\n/* harmony export */   UnzipPassThrough: () => (/* binding */ UnzipPassThrough),\n/* harmony export */   Unzlib: () => (/* binding */ Unzlib),\n/* harmony export */   Zip: () => (/* binding */ Zip),\n/* harmony export */   ZipDeflate: () => (/* binding */ ZipDeflate),\n/* harmony export */   ZipPassThrough: () => (/* binding */ ZipPassThrough),\n/* harmony export */   Zlib: () => (/* binding */ Zlib),\n/* harmony export */   compress: () => (/* binding */ gzip),\n/* harmony export */   compressSync: () => (/* binding */ gzipSync),\n/* harmony export */   decompress: () => (/* binding */ decompress),\n/* harmony export */   decompressSync: () => (/* binding */ decompressSync),\n/* harmony export */   deflate: () => (/* binding */ deflate),\n/* harmony export */   deflateSync: () => (/* binding */ deflateSync),\n/* harmony export */   gunzip: () => (/* binding */ gunzip),\n/* harmony export */   gunzipSync: () => (/* binding */ gunzipSync),\n/* harmony export */   gzip: () => (/* binding */ gzip),\n/* harmony export */   gzipSync: () => (/* binding */ gzipSync),\n/* harmony export */   inflate: () => (/* binding */ inflate),\n/* harmony export */   inflateSync: () => (/* binding */ inflateSync),\n/* harmony export */   strFromU8: () => (/* binding */ strFromU8),\n/* harmony export */   strToU8: () => (/* binding */ strToU8),\n/* harmony export */   unzip: () => (/* binding */ unzip),\n/* harmony export */   unzipSync: () => (/* binding */ unzipSync),\n/* harmony export */   unzlib: () => (/* binding */ unzlib),\n/* harmony export */   unzlibSync: () => (/* binding */ unzlibSync),\n/* harmony export */   zip: () => (/* binding */ zip),\n/* harmony export */   zipSync: () => (/* binding */ zipSync),\n/* harmony export */   zlib: () => (/* binding */ zlib),\n/* harmony export */   zlibSync: () => (/* binding */ zlibSync)\n/* harmony export */ });\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! module */ \"module\");\n\nvar require = (0,module__WEBPACK_IMPORTED_MODULE_0__.createRequire)(\"/\");\n// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\n// Mediocre shim\nvar Worker;\nvar workerAdd = \";var __w=require('worker_threads');__w.parentPort.on('message',function(m){onmessage({data:m})}),postMessage=function(m,t){__w.parentPort.postMessage(m,t)},close=process.exit;self=global\";\ntry {\n    Worker = require(\"worker_threads\").Worker;\n} catch (e) {}\nvar wk = Worker ? function(c, _, msg, transfer, cb) {\n    var done = false;\n    var w = new Worker(c + workerAdd, {\n        eval: true\n    }).on(\"error\", function(e) {\n        return cb(e, null);\n    }).on(\"message\", function(m) {\n        return cb(null, m);\n    }).on(\"exit\", function(c) {\n        if (c && !done) cb(new Error(\"exited with code \" + c), null);\n    });\n    w.postMessage(msg, transfer);\n    w.terminate = function() {\n        done = true;\n        return Worker.prototype.terminate.call(w);\n    };\n    return w;\n} : function(_, __, ___, ____, cb) {\n    setImmediate(function() {\n        return cb(new Error(\"async operations unsupported - update to Node 12+ (or Node 10-11 with the --experimental-worker CLI flag)\"), null);\n    });\n    var NOP = function() {};\n    return {\n        terminate: NOP,\n        postMessage: NOP\n    };\n};\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    /* unused */ 0,\n    0,\n    /* impossible */ 0\n]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13,\n    /* unused */ 0,\n    0\n]);\n// code length index map\nvar clim = new u8([\n    16,\n    17,\n    18,\n    0,\n    8,\n    7,\n    9,\n    6,\n    10,\n    5,\n    11,\n    4,\n    12,\n    3,\n    13,\n    2,\n    14,\n    1,\n    15\n]);\n// get base, reverse index map from extra bits\nvar freb = function(eb, start) {\n    var b = new u16(31);\n    for(var i = 0; i < 31; ++i){\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for(var i = 1; i < 30; ++i){\n        for(var j = b[i]; j < b[i + 1]; ++j){\n            r[j] = j - b[i] << 5 | i;\n        }\n    }\n    return [\n        b,\n        r\n    ];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor(var i = 0; i < 32768; ++i){\n    // reverse table algorithm from SO\n    var x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;\n    x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;\n    x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;\n    rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = function(cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for(; i < s; ++i)++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for(i = 0; i < mb; ++i){\n        le[i] = le[i - 1] + l[i - 1] << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for(i = 0; i < s; ++i){\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = i << 4 | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for(var m = v | (1 << r_1) - 1; v <= m; ++v){\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    } else {\n        co = new u16(s);\n        for(i = 0; i < s; ++i){\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];\n            }\n        }\n    }\n    return co;\n};\n// fixed length tree\nvar flt = new u8(288);\nfor(var i = 0; i < 144; ++i)flt[i] = 8;\nfor(var i = 144; i < 256; ++i)flt[i] = 9;\nfor(var i = 256; i < 280; ++i)flt[i] = 7;\nfor(var i = 280; i < 288; ++i)flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor(var i = 0; i < 32; ++i)fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function(a) {\n    var m = a[0];\n    for(var i = 1; i < a.length; ++i){\n        if (a[i] > m) m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n};\n// get end of byte\nvar shft = function(p) {\n    return (p / 8 | 0) + (p & 7 && 1);\n};\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function(v, s, e) {\n    if (s == null || s < 0) s = 0;\n    if (e == null || e > v.length) e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function(dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || st && !st.l && sl < 5) return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st) st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf) buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function(l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n                if (t > sl) {\n                    if (noSt) throw \"unexpected EOF\";\n                    break;\n                }\n                // ensure size\n                if (noBuf) cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for(var i = 0; i < hcLen; ++i){\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for(var i = 0; i < tl;){\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    } else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;\n                        while(n--)ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            } else throw \"invalid block type\";\n            if (pos > tbts) {\n                if (noSt) throw \"unexpected EOF\";\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf) cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for(;; lpos = pos){\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt) throw \"unexpected EOF\";\n                break;\n            }\n            if (!c) throw \"invalid length/literal\";\n            if (sym < 256) buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            } else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d) throw \"invalid distance\";\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt) throw \"unexpected EOF\";\n                    break;\n                }\n                if (noBuf) cbuf(bt + 131072);\n                var end = bt + add;\n                for(; bt < end; bt += 4){\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt;\n        if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    }while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function(d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for(var i = 0; i < d.length; ++i){\n        if (d[i]) t.push({\n            s: i,\n            f: d[i]\n        });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s) return [\n        et,\n        0\n    ];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [\n            v,\n            1\n        ];\n    }\n    t.sort(function(a, b) {\n        return a.f - b.f;\n    });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({\n        s: -1,\n        f: 25001\n    });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = {\n        s: -1,\n        f: l.f + r.f,\n        l: l,\n        r: r\n    };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while(i1 != s - 1){\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = {\n            s: -1,\n            f: l.f + r.f,\n            l: l,\n            r: r\n        };\n    }\n    var maxSym = t2[0].s;\n    for(var i = 1; i < s; ++i){\n        if (t2[i].s > maxSym) maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function(a, b) {\n            return tr[b.s] - tr[a.s] || a.f - b.f;\n        });\n        for(; i < s; ++i){\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << mbt - tr[i2_1]);\n                tr[i2_1] = mb;\n            } else break;\n        }\n        dt >>>= lft;\n        while(dt > 0){\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;\n            else ++i;\n        }\n        for(; i >= 0 && dt; --i){\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [\n        new u8(tr),\n        mbt\n    ];\n};\n// get the max length and assign length codes\nvar ln = function(n, l, d) {\n    return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;\n};\n// length codes generation\nvar lc = function(c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while(s && !c[--s]);\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function(v) {\n        cl[cli++] = v;\n    };\n    for(var i = 1; i <= s; ++i){\n        if (c[i] == cln && i != s) ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for(; cls > 138; cls -= 138)w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);\n                    cls = 0;\n                }\n            } else if (cls > 3) {\n                w(cln), --cls;\n                for(; cls > 6; cls -= 6)w(8304);\n                if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;\n            }\n            while(cls--)w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [\n        cl.subarray(0, cli),\n        s\n    ];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function(cf, cl) {\n    var l = 0;\n    for(var i = 0; i < cl.length; ++i)l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function(out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for(var i = 0; i < s; ++i)out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for(var i = 0; i < lclt.length; ++i)lcfreq[lclt[i] & 31]++;\n    for(var i = 0; i < lcdt.length; ++i)lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for(; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);\n    var flen = bl + 5 << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for(var i = 0; i < nlcc; ++i)wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [\n            lclt,\n            lcdt\n        ];\n        for(var it = 0; it < 2; ++it){\n            var clct = lcts[it];\n            for(var i = 0; i < clct.length; ++i){\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15) wbits(out, p, clct[i] >>> 5 & 127), p += clct[i] >>> 12;\n            }\n        }\n    } else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for(var i = 0; i < li; ++i){\n        if (syms[i] > 255) {\n            var len = syms[i] >>> 18 & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7) wbits(out, p, syms[i] >>> 23 & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3) wbits16(out, p, syms[i] >>> 5 & 8191), p += fdeb[dst];\n        } else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([\n    65540,\n    131080,\n    131088,\n    131104,\n    262176,\n    1048704,\n    1048832,\n    2114560,\n    2117632\n]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function(dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for(var i = 0; i <= s; i += 65535){\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            } else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    } else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function(i) {\n            return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;\n        };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for(; i < s; ++i){\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for(var j = 0; j < 286; ++j)lf[j] = 0;\n                    for(var j = 0; j < 30; ++j)df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while(dif <= maxd && --ch_1 && imod != pimod){\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for(; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn) break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for(var j = 0; j < mmd; ++j){\n                                    var ti = i - dif + j + 32768 & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti + 32768 & 32767;\n                                    if (cd > md) md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod + 32768 & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                } else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7) pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ function() {\n    var t = new Int32Array(256);\n    for(var i = 0; i < 256; ++i){\n        var c = i, k = 9;\n        while(--k)c = (c & 1 && -306674912) ^ c >>> 1;\n        t[i] = c;\n    }\n    return t;\n}();\n// CRC32\nvar crc = function() {\n    var c = -1;\n    return {\n        p: function(d) {\n            // closures have awful performance\n            var cr = c;\n            for(var i = 0; i < d.length; ++i)cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;\n            c = cr;\n        },\n        d: function() {\n            return ~c;\n        }\n    };\n};\n// Alder32\nvar adler = function() {\n    var a = 1, b = 0;\n    return {\n        p: function(d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for(var i = 0; i != l;){\n                var e = Math.min(i + 2655, l);\n                for(; i < e; ++i)m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function() {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | a >>> 8 << 16 | (b & 255) << 8 | b >>> 8;\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function(dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function(a, b) {\n    var o = {};\n    for(var k in a)o[k] = a[k];\n    for(var k in b)o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function(fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf(\"[\") + 1, st.lastIndexOf(\"]\")).replace(/ /g, \"\").split(\",\");\n    for(var i = 0; i < dt.length; ++i){\n        var v = dt[i], k = ks[i];\n        if (typeof v == \"function\") {\n            fnStr += \";\" + k + \"=\";\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf(\"[native code]\") != -1) {\n                    var spInd = st_1.indexOf(\" \", 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf(\"(\", spInd));\n                } else {\n                    fnStr += st_1;\n                    for(var t in v.prototype)fnStr += \";\" + k + \".prototype.\" + t + \"=\" + v.prototype[t].toString();\n                }\n            } else fnStr += st_1;\n        } else td[k] = v;\n    }\n    return [\n        fnStr,\n        td\n    ];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function(v) {\n    var tl = [];\n    for(var k in v){\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32) tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function(fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = \"\", td_1 = {}, m = fns.length - 1;\n        for(var i = 0; i < m; ++i)_a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + \";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=\" + init.toString() + \"}\", id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function() {\n    return [\n        u8,\n        u16,\n        u32,\n        fleb,\n        fdeb,\n        clim,\n        fl,\n        fd,\n        flrm,\n        fdrm,\n        rev,\n        hMap,\n        max,\n        bits,\n        bits16,\n        shft,\n        slc,\n        inflt,\n        inflateSync,\n        pbf,\n        gu8\n    ];\n};\nvar bDflt = function() {\n    return [\n        u8,\n        u16,\n        u32,\n        fleb,\n        fdeb,\n        clim,\n        revfl,\n        revfd,\n        flm,\n        flt,\n        fdm,\n        fdt,\n        rev,\n        deo,\n        et,\n        hMap,\n        wbits,\n        wbits16,\n        hTree,\n        ln,\n        lc,\n        clen,\n        wfblk,\n        wblk,\n        shft,\n        slc,\n        dflt,\n        dopt,\n        deflateSync,\n        pbf\n    ];\n};\n// gzip extra\nvar gze = function() {\n    return [\n        gzh,\n        gzhl,\n        wbytes,\n        crc,\n        crct\n    ];\n};\n// gunzip extra\nvar guze = function() {\n    return [\n        gzs,\n        gzl\n    ];\n};\n// zlib extra\nvar zle = function() {\n    return [\n        zlh,\n        wbytes,\n        adler\n    ];\n};\n// unzlib extra\nvar zule = function() {\n    return [\n        zlv\n    ];\n};\n// post buf\nvar pbf = function(msg) {\n    return postMessage(msg, [\n        msg.buffer\n    ]);\n};\n// get u8\nvar gu8 = function(o) {\n    return o && o.size && new u8(o.size);\n};\n// async helper\nvar cbify = function(dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function(err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([\n        dat,\n        opts\n    ], opts.consume ? [\n        dat.buffer\n    ] : []);\n    return function() {\n        w.terminate();\n    };\n};\n// auto stream\nvar astrm = function(strm) {\n    strm.ondata = function(dat, final) {\n        return postMessage([\n            dat,\n            final\n        ], [\n            dat.buffer\n        ]);\n    };\n    return function(ev) {\n        return strm.push(ev.data[0], ev.data[1]);\n    };\n};\n// async stream attach\nvar astrmify = function(fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function(err, dat) {\n        if (err) w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1]) w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function(d, f) {\n        if (t) throw \"stream finished\";\n        if (!strm.ondata) throw \"no stream handler\";\n        w.postMessage([\n            d,\n            t = f\n        ], [\n            d.buffer\n        ]);\n    };\n    strm.terminate = function() {\n        w.terminate();\n    };\n};\n// read 2 bytes\nvar b2 = function(d, b) {\n    return d[b] | d[b + 1] << 8;\n};\n// read 4 bytes\nvar b4 = function(d, b) {\n    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;\n};\nvar b8 = function(d, b) {\n    return b4(d, b) + b4(d, b + 4) * 4294967296;\n};\n// write bytes\nvar wbytes = function(d, b, v) {\n    for(; v; ++b)d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function(c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0) wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for(var i = 0; i <= fn.length; ++i)c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function(d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8) throw \"invalid gzip data\";\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4) st += d[10] | (d[11] << 8) + 2;\n    for(var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++]);\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function(d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function(o) {\n    return 10 + (o.filename && o.filename.length + 1 || 0);\n};\n// zlib header\nvar zlh = function(c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = fl << 6 | (fl ? 32 - 2 * fl : 1);\n};\n// zlib valid\nvar zlv = function(d) {\n    if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw \"invalid zlib data\";\n    if (d[1] & 32) throw \"invalid zlib data: preset dictionaries not supported\";\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == \"function\") cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */ var Deflate = /*#__PURE__*/ function() {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == \"function\") cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function(c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Deflate.prototype.push = function(chunk, final) {\n        if (this.d) throw \"stream finished\";\n        if (!this.ondata) throw \"no stream handler\";\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE compression\n */ var AsyncDeflate = /*#__PURE__*/ function() {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function() {\n                return [\n                    astrm,\n                    Deflate\n                ];\n            }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}();\n\nfunction deflate(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bDflt\n    ], function(ev) {\n        return pbf(deflateSync(ev.data[0], ev.data[1]));\n    }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */ function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */ var Inflate = /*#__PURE__*/ function() {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function(c) {\n        if (this.d) throw \"stream finished\";\n        if (!this.ondata) throw \"no stream handler\";\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function(final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */ Inflate.prototype.push = function(chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE decompression\n */ var AsyncInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function() {\n                return [\n                    astrm,\n                    Inflate\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}();\n\nfunction inflate(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bInflt\n    ], function(ev) {\n        return pbf(inflateSync(ev.data[0], gu8(ev.data[1])));\n    }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */ function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */ var Gzip = /*#__PURE__*/ function() {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Gzip.prototype.push = function(chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function(c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v) gzh(raw, this.o), this.v = 0;\n        if (f) wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}();\n\n/**\n * Asynchronous streaming GZIP compression\n */ var AsyncGzip = /*#__PURE__*/ function() {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function() {\n                return [\n                    astrm,\n                    Deflate,\n                    Gzip\n                ];\n            }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}();\n\nfunction gzip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function() {\n            return [\n                gzipSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(gzipSync(ev.data[0], ev.data[1]));\n    }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */ function gzipSync(data, opts) {\n    if (!opts) opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */ var Gunzip = /*#__PURE__*/ function() {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Gunzip.prototype.push = function(chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final) return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8) throw \"invalid gzip stream\";\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}();\n\n/**\n * Asynchronous streaming GZIP decompression\n */ var AsyncGunzip = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function() {\n                return [\n                    astrm,\n                    Inflate,\n                    Gunzip\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}();\n\nfunction gunzip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function() {\n            return [\n                gunzipSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(gunzipSync(ev.data[0]));\n    }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */ function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */ var Zlib = /*#__PURE__*/ function() {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Zlib.prototype.push = function(chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function(c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v) zlh(raw, this.o), this.v = 0;\n        if (f) wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}();\n\n/**\n * Asynchronous streaming Zlib compression\n */ var AsyncZlib = /*#__PURE__*/ function() {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function() {\n                return [\n                    astrm,\n                    Deflate,\n                    Zlib\n                ];\n            }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}();\n\nfunction zlib(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function() {\n            return [\n                zlibSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(zlibSync(ev.data[0], ev.data[1]));\n    }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */ function zlibSync(data, opts) {\n    if (!opts) opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */ var Unzlib = /*#__PURE__*/ function() {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Unzlib.prototype.push = function(chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final) return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4) throw \"invalid zlib stream\";\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}();\n\n/**\n * Asynchronous streaming Zlib decompression\n */ var AsyncUnzlib = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function() {\n                return [\n                    astrm,\n                    Inflate,\n                    Unzlib\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}();\n\nfunction unzlib(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function() {\n            return [\n                unzlibSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(unzlibSync(ev.data[0], gu8(ev.data[1])));\n    }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */ function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\n\n// Default algorithm for compression (used because having a known output size allows faster decompression)\n\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */ var Decompress = /*#__PURE__*/ function() {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */ function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Decompress.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no stream handler\";\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            } else this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function() {\n                    _this_1.ondata.apply(_this_1, arguments);\n                };\n                this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(cb) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(cb) : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        } else this.s.push(chunk, final);\n    };\n    return Decompress;\n}();\n\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */ var AsyncDecompress = /*#__PURE__*/ function() {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */ function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ AsyncDecompress.prototype.push = function(chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}();\n\nfunction decompress(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate(data, opts, cb) : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */ function decompressSync(data, out) {\n    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, out) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, out) : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function(d, p, t, o) {\n    for(var k in d){\n        var val = d[k], n = p + k;\n        if (val instanceof u8) t[n] = [\n            val,\n            o\n        ];\n        else if (Array.isArray(val)) t[n] = [\n            val[0],\n            mrg(o, val[1])\n        ];\n        else fltn(val, n + \"/\", t, o);\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != \"undefined\" && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != \"undefined\" && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, {\n        stream: true\n    });\n    tds = 1;\n} catch (e) {}\n// decode UTF8\nvar dutf8 = function(d) {\n    for(var r = \"\", i = 0;;){\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length) return [\n            r,\n            slc(d, i - 1)\n        ];\n        if (!eb) r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\n        } else if (eb & 1) r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);\n        else r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */ var DecodeUTF8 = /*#__PURE__*/ function() {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */ function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds) this.t = new TextDecoder();\n        else this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ DecodeUTF8.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback\";\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, {\n                stream: true\n            }), final);\n            if (final) {\n                if (this.t.decode().length) throw \"invalid utf-8 data\";\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p) throw \"stream finished\";\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length) throw \"invalid utf-8 data\";\n            this.p = null;\n        } else this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}();\n\n/**\n * Streaming UTF-8 encoding\n */ var EncodeUTF8 = /*#__PURE__*/ function() {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */ function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */ EncodeUTF8.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback\";\n        if (this.d) throw \"stream finished\";\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}();\n\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */ function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for(var i = 0; i < str.length; ++i)ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te) return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function(v) {\n        ar[ai++] = v;\n    };\n    for(var i = 0; i < l; ++i){\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + (l - i << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1) w(c);\n        else if (c < 2048) w(192 | c >> 6), w(128 | c & 63);\n        else if (c > 55295 && c < 57344) c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);\n        else w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */ function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = \"\";\n        for(var i = 0; i < dat.length; i += 16384)r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    } else if (td) return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length) throw \"invalid utf-8 data\";\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function(l) {\n    return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;\n};\n// skip local zip header\nvar slzh = function(d, b) {\n    return b + 30 + b2(d, b + 26) + b2(d, b + 28);\n};\n// read zip header\nvar zh = function(d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [\n        bs,\n        b4(d, b + 24),\n        b4(d, b + 42)\n    ], sc = _a[0], su = _a[1], off = _a[2];\n    return [\n        b2(d, b + 10),\n        sc,\n        su,\n        fn,\n        es + b2(d, b + 30) + b2(d, b + 32),\n        off\n    ];\n};\n// read zip64 extra field\nvar z64e = function(d, b) {\n    for(; b2(d, b) != 1; b += 4 + b2(d, b + 2));\n    return [\n        b8(d, b + 12),\n        b8(d, b + 4),\n        b8(d, b + 20)\n    ];\n};\n// extra field length\nvar exfl = function(ex) {\n    var le = 0;\n    if (ex) {\n        for(var k in ex){\n            var l = ex[k].length;\n            if (l > 65535) throw \"extra field too long\";\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function(d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null) d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = f.flag << 1 | (c == null && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119) throw \"date not in range 1980-2099\";\n    wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b += 4;\n    if (c != null) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for(var k in ex){\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col) d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function(o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */ var ZipPassThrough = /*#__PURE__*/ function() {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */ function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */ ZipPassThrough.prototype.process = function(chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ ZipPassThrough.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback - add to ZIP archive before pushing\";\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final) this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}();\n\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */ var ZipDeflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */ function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts) opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function(dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function(chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        } catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ ZipDeflate.prototype.push = function(chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */ var AsyncZipDeflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */ function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts) opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function(err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function(chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ AsyncZipDeflate.prototype.push = function(chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}();\n\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */ var Zip = /*#__PURE__*/ function() {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */ function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */ Zip.prototype.add = function(file) {\n        var _this_1 = this;\n        if (this.d & 2) throw \"stream finished\";\n        var f = strToU8(file.filename), fl = f.length;\n        var com = file.comment, o = com && strToU8(com);\n        var u = fl != file.filename.length || o && com.length != o.length;\n        var hl = fl + exfl(file.extra) + 30;\n        if (fl > 65535) throw \"filename too long\";\n        var header = new u8(hl);\n        wzh(header, 0, file, f, u);\n        var chks = [\n            header\n        ];\n        var pAll = function() {\n            for(var _i = 0, chks_1 = chks; _i < chks_1.length; _i++){\n                var chk = chks_1[_i];\n                _this_1.ondata(null, chk, false);\n            }\n            chks = [];\n        };\n        var tr = this.d;\n        this.d = 0;\n        var ind = this.u.length;\n        var uf = mrg(file, {\n            f: f,\n            u: u,\n            o: o,\n            t: function() {\n                if (file.terminate) file.terminate();\n            },\n            r: function() {\n                pAll();\n                if (tr) {\n                    var nxt = _this_1.u[ind + 1];\n                    if (nxt) nxt.r();\n                    else _this_1.d = 1;\n                }\n                tr = 1;\n            }\n        });\n        var cl = 0;\n        file.ondata = function(err, dat, final) {\n            if (err) {\n                _this_1.ondata(err, dat, final);\n                _this_1.terminate();\n            } else {\n                cl += dat.length;\n                chks.push(dat);\n                if (final) {\n                    var dd = new u8(16);\n                    wbytes(dd, 0, 0x8074B50);\n                    wbytes(dd, 4, file.crc);\n                    wbytes(dd, 8, cl);\n                    wbytes(dd, 12, file.size);\n                    chks.push(dd);\n                    uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n                    if (tr) uf.r();\n                    tr = 1;\n                } else if (tr) pAll();\n            }\n        };\n        this.u.push(uf);\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */ Zip.prototype.end = function() {\n        var _this_1 = this;\n        if (this.d & 2) {\n            if (this.d & 1) throw \"stream finishing\";\n            throw \"stream finished\";\n        }\n        if (this.d) this.e();\n        else this.u.push({\n            r: function() {\n                if (!(_this_1.d & 1)) return;\n                _this_1.u.splice(-1, 1);\n                _this_1.e();\n            },\n            t: function() {}\n        });\n        this.d = 3;\n    };\n    Zip.prototype.e = function() {\n        var bt = 0, l = 0, tl = 0;\n        for(var _i = 0, _a = this.u; _i < _a.length; _i++){\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for(var _b = 0, _c = this.u; _b < _c.length; _b++){\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */ Zip.prototype.terminate = function() {\n        for(var _i = 0, _a = this.u; _i < _a.length; _i++){\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}();\n\nfunction zip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    var r = {};\n    fltn(data, \"\", r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function() {\n        for(var i = 0; i < term.length; ++i)term[i]();\n    };\n    var cbf = function() {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for(var i = 0; i < slft; ++i){\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            } catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft) cbf();\n    var _loop_1 = function(i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function(e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            } else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || m && com.length != ms,\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft) cbf();\n            }\n        };\n        if (s > 65535) cbl(\"filename too long\", null);\n        if (!compression) cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            } catch (e) {\n                cbl(e, null);\n            }\n        } else term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for(var i = 0; i < slft; ++i){\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */ function zipSync(data, opts) {\n    if (!opts) opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, \"\", r, opts);\n    var o = 0;\n    var tot = 0;\n    for(var fn in r){\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535) throw \"filename too long\";\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || m && com.length != ms,\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for(var i = 0; i < files.length; ++i){\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */ var UnzipPassThrough = /*#__PURE__*/ function() {\n    function UnzipPassThrough() {}\n    UnzipPassThrough.prototype.push = function(data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}();\n\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */ var UnzipInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */ function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function(dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function(data, final) {\n        try {\n            this.i.push(data, final);\n        } catch (e) {\n            this.ondata(e, data, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */ var AsyncUnzipInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */ function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function(dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        } else {\n            this.i = new AsyncInflate(function(err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function(data, final) {\n        if (this.i.terminate) data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}();\n\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */ var Unzip = /*#__PURE__*/ function() {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */ function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Unzip.prototype.push = function(chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile) throw \"no callback\";\n        if (!this.p) throw \"stream finished\";\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d) this.d.push(toAdd, !this.c);\n            else this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length) return this.push(chunk, final);\n        } else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length) buf = chunk;\n            else if (!chunk.length) buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function() {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_2 = [];\n                        this_1.k.unshift(chks_2);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [\n                                -2\n                            ] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        } else if (dd) sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function() {\n                                if (!file_1.ondata) throw \"no callback\";\n                                if (!sc_1) file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr) throw \"unknown compression type \" + cmp_1;\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function(err, dat, final) {\n                                        file_1.ondata(err, dat, final);\n                                    };\n                                    for(var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++){\n                                        var dat = chks_3[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_2 && _this_1.c) _this_1.d = d_1;\n                                    else d_1.push(et, true);\n                                }\n                            },\n                            terminate: function() {\n                                if (d_1 && d_1.terminate) d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0) file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                } else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    } else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for(; i < l - 4; ++i){\n                var state_1 = _loop_2();\n                if (state_1 === \"break\") break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add) add.push(dat, !!f);\n                else this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2) return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c) throw \"invalid zip file\";\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */ Unzip.prototype.register = function(decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}();\n\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */ function unzip(data, cb) {\n    if (typeof cb != \"function\") throw \"no callback\";\n    var term = [];\n    var tAll = function() {\n        for(var i = 0; i < term.length; ++i)term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for(; b4(data, e) != 0x6054B50; --e){\n        if (!e || data.length - e > 65558) {\n            cb(\"invalid zip file\", null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft) cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) {\n            cb(\"invalid zip file\", null);\n            return;\n        }\n        c = lft = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    var _loop_3 = function(i) {\n        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function(e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            } else {\n                files[fn] = d;\n                if (!--lft) cb(null, files);\n            }\n        };\n        if (!c_1) cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                } catch (e) {\n                    cbl(e, null);\n                }\n            } else term.push(inflate(infl, {\n                size: su\n            }, cbl));\n        } else cbl(\"unknown compression type \" + c_1, null);\n    };\n    for(var i = 0; i < c; ++i){\n        _loop_3(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */ function unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for(; b4(data, e) != 0x6054B50; --e){\n        if (!e || data.length - e > 65558) throw \"invalid zip file\";\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c) return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) throw \"invalid zip file\";\n        c = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    for(var i = 0; i < c; ++i){\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2) files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8) files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else throw \"unknown compression type \" + c_2;\n    }\n    return files;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL25vZGVfbW9kdWxlcy9mZmxhdGUvZXNtL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVDO0FBQ3ZDLElBQUlDLFVBQVVELHFEQUFhQSxDQUFDO0FBQzVCLDJGQUEyRjtBQUMzRixzQ0FBc0M7QUFDdEMsMkVBQTJFO0FBQzNFLHFFQUFxRTtBQUNyRSw0REFBNEQ7QUFDNUQsc0NBQXNDO0FBQ3RDLHVIQUF1SDtBQUN2SCwyRkFBMkY7QUFDM0Ysb0RBQW9EO0FBQ3BELGdCQUFnQjtBQUNoQixJQUFJRTtBQUNKLElBQUlDLFlBQVk7QUFDaEIsSUFBSTtJQUNBRCxTQUFTRCxRQUFRLGtCQUFrQkMsTUFBTTtBQUM3QyxFQUNBLE9BQU9FLEdBQUcsQ0FDVjtBQUNBLElBQUlDLEtBQUtILFNBQVMsU0FBVUksQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEdBQUcsRUFBRUMsUUFBUSxFQUFFQyxFQUFFO0lBQy9DLElBQUlDLE9BQU87SUFDWCxJQUFJQyxJQUFJLElBQUlWLE9BQU9JLElBQUlILFdBQVc7UUFBRVUsTUFBTTtJQUFLLEdBQzFDQyxFQUFFLENBQUMsU0FBUyxTQUFVVixDQUFDO1FBQUksT0FBT00sR0FBR04sR0FBRztJQUFPLEdBQy9DVSxFQUFFLENBQUMsV0FBVyxTQUFVQyxDQUFDO1FBQUksT0FBT0wsR0FBRyxNQUFNSztJQUFJLEdBQ2pERCxFQUFFLENBQUMsUUFBUSxTQUFVUixDQUFDO1FBQ3ZCLElBQUlBLEtBQUssQ0FBQ0ssTUFDTkQsR0FBRyxJQUFJTSxNQUFNLHNCQUFzQlYsSUFBSTtJQUMvQztJQUNBTSxFQUFFSyxXQUFXLENBQUNULEtBQUtDO0lBQ25CRyxFQUFFTSxTQUFTLEdBQUc7UUFDVlAsT0FBTztRQUNQLE9BQU9ULE9BQU9pQixTQUFTLENBQUNELFNBQVMsQ0FBQ0UsSUFBSSxDQUFDUjtJQUMz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UUFDeEIsSUFBSUcsS0FBS3dULEdBQUdsRixNQUFNdk0sR0FBRzBSLElBQUltRyxNQUFNNVosRUFBRSxDQUFDLEVBQUUsRUFBRTZULEtBQUs3VCxFQUFFLENBQUMsRUFBRSxFQUFFOFQsS0FBSzlULEVBQUUsQ0FBQyxFQUFFLEVBQUV3TCxLQUFLeEwsRUFBRSxDQUFDLEVBQUUsRUFBRXlaLEtBQUt6WixFQUFFLENBQUMsRUFBRSxFQUFFK1QsTUFBTS9ULEVBQUUsQ0FBQyxFQUFFLEVBQUVKLElBQUkyVCxLQUFLakYsTUFBTXlGO1FBQ2xIaFMsSUFBSTBYO1FBQ0osSUFBSSxDQUFDRyxLQUNEOUMsS0FBSyxDQUFDdEwsR0FBRyxHQUFHdEosSUFBSW9NLE1BQU0xTyxHQUFHQSxJQUFJaVU7YUFDNUIsSUFBSStGLE9BQU8sR0FDWjlDLEtBQUssQ0FBQ3RMLEdBQUcsR0FBR3FCLFlBQVl5QixLQUFLak0sUUFBUSxDQUFDekMsR0FBR0EsSUFBSWlVLEtBQUssSUFBSTdVLEdBQUc4VTthQUV6RCxNQUFNLDhCQUE4QjhGO0lBQzVDO0lBQ0EsT0FBTzlDO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8zRC1BSS1FbmdsaXNoLy4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9ub2RlX21vZHVsZXMvZmZsYXRlL2VzbS9pbmRleC5tanM/Y2M2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVSZXF1aXJlIH0gZnJvbSAnbW9kdWxlJztcbnZhciByZXF1aXJlID0gY3JlYXRlUmVxdWlyZSgnLycpO1xuLy8gREVGTEFURSBpcyBhIGNvbXBsZXggZm9ybWF0OyB0byByZWFkIHRoaXMgY29kZSwgeW91IHNob3VsZCBwcm9iYWJseSBjaGVjayB0aGUgUkZDIGZpcnN0OlxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzE5NTFcbi8vIFlvdSBtYXkgYWxzbyB3aXNoIHRvIHRha2UgYSBsb29rIGF0IHRoZSBndWlkZSBJIG1hZGUgYWJvdXQgdGhpcyBwcm9ncmFtOlxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTAxYXJyb3d6LzI1M2YzMWViNWFiYzNkOTI3NWFiOTQzMDAzZmZlY2FkXG4vLyBTb21lIG9mIHRoZSBmb2xsb3dpbmcgY29kZSBpcyBzaW1pbGFyIHRvIHRoYXQgb2YgVVpJUC5qczpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b3BlYS9VWklQLmpzXG4vLyBIb3dldmVyLCB0aGUgdmFzdCBtYWpvcml0eSBvZiB0aGUgY29kZWJhc2UgaGFzIGRpdmVyZ2VkIGZyb20gVVpJUC5qcyB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZSBhbmQgcmVkdWNlIGJ1bmRsZSBzaXplLlxuLy8gU29tZXRpbWVzIDAgd2lsbCBhcHBlYXIgd2hlcmUgLTEgd291bGQgYmUgbW9yZSBhcHByb3ByaWF0ZS4gVGhpcyBpcyBiZWNhdXNlIHVzaW5nIGEgdWludFxuLy8gaXMgYmV0dGVyIGZvciBtZW1vcnkgaW4gbW9zdCBlbmdpbmVzIChJICp0aGluayopLlxuLy8gTWVkaW9jcmUgc2hpbVxudmFyIFdvcmtlcjtcbnZhciB3b3JrZXJBZGQgPSBcIjt2YXIgX193PXJlcXVpcmUoJ3dvcmtlcl90aHJlYWRzJyk7X193LnBhcmVudFBvcnQub24oJ21lc3NhZ2UnLGZ1bmN0aW9uKG0pe29ubWVzc2FnZSh7ZGF0YTptfSl9KSxwb3N0TWVzc2FnZT1mdW5jdGlvbihtLHQpe19fdy5wYXJlbnRQb3J0LnBvc3RNZXNzYWdlKG0sdCl9LGNsb3NlPXByb2Nlc3MuZXhpdDtzZWxmPWdsb2JhbFwiO1xudHJ5IHtcbiAgICBXb3JrZXIgPSByZXF1aXJlKCd3b3JrZXJfdGhyZWFkcycpLldvcmtlcjtcbn1cbmNhdGNoIChlKSB7XG59XG52YXIgd2sgPSBXb3JrZXIgPyBmdW5jdGlvbiAoYywgXywgbXNnLCB0cmFuc2ZlciwgY2IpIHtcbiAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgIHZhciB3ID0gbmV3IFdvcmtlcihjICsgd29ya2VyQWRkLCB7IGV2YWw6IHRydWUgfSlcbiAgICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBjYihlLCBudWxsKTsgfSlcbiAgICAgICAgLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIGNiKG51bGwsIG0pOyB9KVxuICAgICAgICAub24oJ2V4aXQnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyAmJiAhZG9uZSlcbiAgICAgICAgICAgIGNiKG5ldyBFcnJvcignZXhpdGVkIHdpdGggY29kZSAnICsgYyksIG51bGwpO1xuICAgIH0pO1xuICAgIHcucG9zdE1lc3NhZ2UobXNnLCB0cmFuc2Zlcik7XG4gICAgdy50ZXJtaW5hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gV29ya2VyLnByb3RvdHlwZS50ZXJtaW5hdGUuY2FsbCh3KTtcbiAgICB9O1xuICAgIHJldHVybiB3O1xufSA6IGZ1bmN0aW9uIChfLCBfXywgX19fLCBfX19fLCBjYikge1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBjYihuZXcgRXJyb3IoJ2FzeW5jIG9wZXJhdGlvbnMgdW5zdXBwb3J0ZWQgLSB1cGRhdGUgdG8gTm9kZSAxMisgKG9yIE5vZGUgMTAtMTEgd2l0aCB0aGUgLS1leHBlcmltZW50YWwtd29ya2VyIENMSSBmbGFnKScpLCBudWxsKTsgfSk7XG4gICAgdmFyIE5PUCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0ZXJtaW5hdGU6IE5PUCxcbiAgICAgICAgcG9zdE1lc3NhZ2U6IE5PUFxuICAgIH07XG59O1xuXG4vLyBhbGlhc2VzIGZvciBzaG9ydGVyIGNvbXByZXNzZWQgY29kZSAobW9zdCBtaW5pZmVycyBkb24ndCBkbyB0aGlzKVxudmFyIHU4ID0gVWludDhBcnJheSwgdTE2ID0gVWludDE2QXJyYXksIHUzMiA9IFVpbnQzMkFycmF5O1xuLy8gZml4ZWQgbGVuZ3RoIGV4dHJhIGJpdHNcbnZhciBmbGViID0gbmV3IHU4KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCAwLCAvKiB1bnVzZWQgKi8gMCwgMCwgLyogaW1wb3NzaWJsZSAqLyAwXSk7XG4vLyBmaXhlZCBkaXN0YW5jZSBleHRyYSBiaXRzXG4vLyBzZWUgZmxlYiBub3RlXG52YXIgZmRlYiA9IG5ldyB1OChbMCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNiwgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzLCAvKiB1bnVzZWQgKi8gMCwgMF0pO1xuLy8gY29kZSBsZW5ndGggaW5kZXggbWFwXG52YXIgY2xpbSA9IG5ldyB1OChbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV0pO1xuLy8gZ2V0IGJhc2UsIHJldmVyc2UgaW5kZXggbWFwIGZyb20gZXh0cmEgYml0c1xudmFyIGZyZWIgPSBmdW5jdGlvbiAoZWIsIHN0YXJ0KSB7XG4gICAgdmFyIGIgPSBuZXcgdTE2KDMxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMxOyArK2kpIHtcbiAgICAgICAgYltpXSA9IHN0YXJ0ICs9IDEgPDwgZWJbaSAtIDFdO1xuICAgIH1cbiAgICAvLyBudW1iZXJzIGhlcmUgYXJlIGF0IG1heCAxOCBiaXRzXG4gICAgdmFyIHIgPSBuZXcgdTMyKGJbMzBdKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDMwOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGJbaV07IGogPCBiW2kgKyAxXTsgKytqKSB7XG4gICAgICAgICAgICByW2pdID0gKChqIC0gYltpXSkgPDwgNSkgfCBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbYiwgcl07XG59O1xudmFyIF9hID0gZnJlYihmbGViLCAyKSwgZmwgPSBfYVswXSwgcmV2ZmwgPSBfYVsxXTtcbi8vIHdlIGNhbiBpZ25vcmUgdGhlIGZhY3QgdGhhdCB0aGUgb3RoZXIgbnVtYmVycyBhcmUgd3Jvbmc7IHRoZXkgbmV2ZXIgaGFwcGVuIGFueXdheVxuZmxbMjhdID0gMjU4LCByZXZmbFsyNThdID0gMjg7XG52YXIgX2IgPSBmcmViKGZkZWIsIDApLCBmZCA9IF9iWzBdLCByZXZmZCA9IF9iWzFdO1xuLy8gbWFwIG9mIHZhbHVlIHRvIHJldmVyc2UgKGFzc3VtaW5nIDE2IGJpdHMpXG52YXIgcmV2ID0gbmV3IHUxNigzMjc2OCk7XG5mb3IgKHZhciBpID0gMDsgaSA8IDMyNzY4OyArK2kpIHtcbiAgICAvLyByZXZlcnNlIHRhYmxlIGFsZ29yaXRobSBmcm9tIFNPXG4gICAgdmFyIHggPSAoKGkgJiAweEFBQUEpID4+PiAxKSB8ICgoaSAmIDB4NTU1NSkgPDwgMSk7XG4gICAgeCA9ICgoeCAmIDB4Q0NDQykgPj4+IDIpIHwgKCh4ICYgMHgzMzMzKSA8PCAyKTtcbiAgICB4ID0gKCh4ICYgMHhGMEYwKSA+Pj4gNCkgfCAoKHggJiAweDBGMEYpIDw8IDQpO1xuICAgIHJldltpXSA9ICgoKHggJiAweEZGMDApID4+PiA4KSB8ICgoeCAmIDB4MDBGRikgPDwgOCkpID4+PiAxO1xufVxuLy8gY3JlYXRlIGh1ZmZtYW4gdHJlZSBmcm9tIHU4IFwibWFwXCI6IGluZGV4IC0+IGNvZGUgbGVuZ3RoIGZvciBjb2RlIGluZGV4XG4vLyBtYiAobWF4IGJpdHMpIG11c3QgYmUgYXQgbW9zdCAxNVxuLy8gVE9ETzogb3B0aW1pemUvc3BsaXQgdXA/XG52YXIgaE1hcCA9IChmdW5jdGlvbiAoY2QsIG1iLCByKSB7XG4gICAgdmFyIHMgPSBjZC5sZW5ndGg7XG4gICAgLy8gaW5kZXhcbiAgICB2YXIgaSA9IDA7XG4gICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+ICMgb2YgY29kZXMgd2l0aCBiaXQgbGVuZ3RoID0gaW5kZXhcbiAgICB2YXIgbCA9IG5ldyB1MTYobWIpO1xuICAgIC8vIGxlbmd0aCBvZiBjZCBtdXN0IGJlIDI4OCAodG90YWwgIyBvZiBjb2RlcylcbiAgICBmb3IgKDsgaSA8IHM7ICsraSlcbiAgICAgICAgKytsW2NkW2ldIC0gMV07XG4gICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+IG1pbmltdW0gY29kZSBmb3IgYml0IGxlbmd0aCA9IGluZGV4XG4gICAgdmFyIGxlID0gbmV3IHUxNihtYik7XG4gICAgZm9yIChpID0gMDsgaSA8IG1iOyArK2kpIHtcbiAgICAgICAgbGVbaV0gPSAobGVbaSAtIDFdICsgbFtpIC0gMV0pIDw8IDE7XG4gICAgfVxuICAgIHZhciBjbztcbiAgICBpZiAocikge1xuICAgICAgICAvLyB1MTYgXCJtYXBcIjogaW5kZXggLT4gbnVtYmVyIG9mIGFjdHVhbCBiaXRzLCBzeW1ib2wgZm9yIGNvZGVcbiAgICAgICAgY28gPSBuZXcgdTE2KDEgPDwgbWIpO1xuICAgICAgICAvLyBiaXRzIHRvIHJlbW92ZSBmb3IgcmV2ZXJzZXJcbiAgICAgICAgdmFyIHJ2YiA9IDE1IC0gbWI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSAwIGxlbmd0aHNcbiAgICAgICAgICAgIGlmIChjZFtpXSkge1xuICAgICAgICAgICAgICAgIC8vIG51bSBlbmNvZGluZyBib3RoIHN5bWJvbCBhbmQgYml0cyByZWFkXG4gICAgICAgICAgICAgICAgdmFyIHN2ID0gKGkgPDwgNCkgfCBjZFtpXTtcbiAgICAgICAgICAgICAgICAvLyBmcmVlIGJpdHNcbiAgICAgICAgICAgICAgICB2YXIgcl8xID0gbWIgLSBjZFtpXTtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCB2YWx1ZVxuICAgICAgICAgICAgICAgIHZhciB2ID0gbGVbY2RbaV0gLSAxXSsrIDw8IHJfMTtcbiAgICAgICAgICAgICAgICAvLyBtIGlzIGVuZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSB2IHwgKCgxIDw8IHJfMSkgLSAxKTsgdiA8PSBtOyArK3YpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlcnkgMTYgYml0IHZhbHVlIHN0YXJ0aW5nIHdpdGggdGhlIGNvZGUgeWllbGRzIHRoZSBzYW1lIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICBjb1tyZXZbdl0gPj4+IHJ2Yl0gPSBzdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvID0gbmV3IHUxNihzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgaWYgKGNkW2ldKSB7XG4gICAgICAgICAgICAgICAgY29baV0gPSByZXZbbGVbY2RbaV0gLSAxXSsrXSA+Pj4gKDE1IC0gY2RbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbztcbn0pO1xuLy8gZml4ZWQgbGVuZ3RoIHRyZWVcbnZhciBmbHQgPSBuZXcgdTgoMjg4KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMTQ0OyArK2kpXG4gICAgZmx0W2ldID0gODtcbmZvciAodmFyIGkgPSAxNDQ7IGkgPCAyNTY7ICsraSlcbiAgICBmbHRbaV0gPSA5O1xuZm9yICh2YXIgaSA9IDI1NjsgaSA8IDI4MDsgKytpKVxuICAgIGZsdFtpXSA9IDc7XG5mb3IgKHZhciBpID0gMjgwOyBpIDwgMjg4OyArK2kpXG4gICAgZmx0W2ldID0gODtcbi8vIGZpeGVkIGRpc3RhbmNlIHRyZWVcbnZhciBmZHQgPSBuZXcgdTgoMzIpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgKytpKVxuICAgIGZkdFtpXSA9IDU7XG4vLyBmaXhlZCBsZW5ndGggbWFwXG52YXIgZmxtID0gLyojX19QVVJFX18qLyBoTWFwKGZsdCwgOSwgMCksIGZscm0gPSAvKiNfX1BVUkVfXyovIGhNYXAoZmx0LCA5LCAxKTtcbi8vIGZpeGVkIGRpc3RhbmNlIG1hcFxudmFyIGZkbSA9IC8qI19fUFVSRV9fKi8gaE1hcChmZHQsIDUsIDApLCBmZHJtID0gLyojX19QVVJFX18qLyBoTWFwKGZkdCwgNSwgMSk7XG4vLyBmaW5kIG1heCBvZiBhcnJheVxudmFyIG1heCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIG0gPSBhWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYVtpXSA+IG0pXG4gICAgICAgICAgICBtID0gYVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIG07XG59O1xuLy8gcmVhZCBkLCBzdGFydGluZyBhdCBiaXQgcCBhbmQgbWFzayB3aXRoIG1cbnZhciBiaXRzID0gZnVuY3Rpb24gKGQsIHAsIG0pIHtcbiAgICB2YXIgbyA9IChwIC8gOCkgfCAwO1xuICAgIHJldHVybiAoKGRbb10gfCAoZFtvICsgMV0gPDwgOCkpID4+IChwICYgNykpICYgbTtcbn07XG4vLyByZWFkIGQsIHN0YXJ0aW5nIGF0IGJpdCBwIGNvbnRpbnVpbmcgZm9yIGF0IGxlYXN0IDE2IGJpdHNcbnZhciBiaXRzMTYgPSBmdW5jdGlvbiAoZCwgcCkge1xuICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgcmV0dXJuICgoZFtvXSB8IChkW28gKyAxXSA8PCA4KSB8IChkW28gKyAyXSA8PCAxNikpID4+IChwICYgNykpO1xufTtcbi8vIGdldCBlbmQgb2YgYnl0ZVxudmFyIHNoZnQgPSBmdW5jdGlvbiAocCkgeyByZXR1cm4gKChwIC8gOCkgfCAwKSArIChwICYgNyAmJiAxKTsgfTtcbi8vIHR5cGVkIGFycmF5IHNsaWNlIC0gYWxsb3dzIGdhcmJhZ2UgY29sbGVjdG9yIHRvIGZyZWUgb3JpZ2luYWwgcmVmZXJlbmNlLFxuLy8gd2hpbGUgYmVpbmcgbW9yZSBjb21wYXRpYmxlIHRoYW4gLnNsaWNlXG52YXIgc2xjID0gZnVuY3Rpb24gKHYsIHMsIGUpIHtcbiAgICBpZiAocyA9PSBudWxsIHx8IHMgPCAwKVxuICAgICAgICBzID0gMDtcbiAgICBpZiAoZSA9PSBudWxsIHx8IGUgPiB2Lmxlbmd0aClcbiAgICAgICAgZSA9IHYubGVuZ3RoO1xuICAgIC8vIGNhbid0IHVzZSAuY29uc3RydWN0b3IgaW4gY2FzZSB1c2VyLXN1cHBsaWVkXG4gICAgdmFyIG4gPSBuZXcgKHYgaW5zdGFuY2VvZiB1MTYgPyB1MTYgOiB2IGluc3RhbmNlb2YgdTMyID8gdTMyIDogdTgpKGUgLSBzKTtcbiAgICBuLnNldCh2LnN1YmFycmF5KHMsIGUpKTtcbiAgICByZXR1cm4gbjtcbn07XG4vLyBleHBhbmRzIHJhdyBERUZMQVRFIGRhdGFcbnZhciBpbmZsdCA9IGZ1bmN0aW9uIChkYXQsIGJ1Ziwgc3QpIHtcbiAgICAvLyBzb3VyY2UgbGVuZ3RoXG4gICAgdmFyIHNsID0gZGF0Lmxlbmd0aDtcbiAgICBpZiAoIXNsIHx8IChzdCAmJiAhc3QubCAmJiBzbCA8IDUpKVxuICAgICAgICByZXR1cm4gYnVmIHx8IG5ldyB1OCgwKTtcbiAgICAvLyBoYXZlIHRvIGVzdGltYXRlIHNpemVcbiAgICB2YXIgbm9CdWYgPSAhYnVmIHx8IHN0O1xuICAgIC8vIG5vIHN0YXRlXG4gICAgdmFyIG5vU3QgPSAhc3QgfHwgc3QuaTtcbiAgICBpZiAoIXN0KVxuICAgICAgICBzdCA9IHt9O1xuICAgIC8vIEFzc3VtZXMgcm91Z2hseSAzMyUgY29tcHJlc3Npb24gcmF0aW8gYXZlcmFnZVxuICAgIGlmICghYnVmKVxuICAgICAgICBidWYgPSBuZXcgdTgoc2wgKiAzKTtcbiAgICAvLyBlbnN1cmUgYnVmZmVyIGNhbiBmaXQgYXQgbGVhc3QgbCBlbGVtZW50c1xuICAgIHZhciBjYnVmID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgdmFyIGJsID0gYnVmLmxlbmd0aDtcbiAgICAgICAgLy8gbmVlZCB0byBpbmNyZWFzZSBzaXplIHRvIGZpdFxuICAgICAgICBpZiAobCA+IGJsKSB7XG4gICAgICAgICAgICAvLyBEb3VibGUgb3Igc2V0IHRvIG5lY2Vzc2FyeSwgd2hpY2hldmVyIGlzIGdyZWF0ZXJcbiAgICAgICAgICAgIHZhciBuYnVmID0gbmV3IHU4KE1hdGgubWF4KGJsICogMiwgbCkpO1xuICAgICAgICAgICAgbmJ1Zi5zZXQoYnVmKTtcbiAgICAgICAgICAgIGJ1ZiA9IG5idWY7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vICBsYXN0IGNodW5rICAgICAgICAgYml0cG9zICAgICAgICAgICBieXRlc1xuICAgIHZhciBmaW5hbCA9IHN0LmYgfHwgMCwgcG9zID0gc3QucCB8fCAwLCBidCA9IHN0LmIgfHwgMCwgbG0gPSBzdC5sLCBkbSA9IHN0LmQsIGxidCA9IHN0Lm0sIGRidCA9IHN0Lm47XG4gICAgLy8gdG90YWwgYml0c1xuICAgIHZhciB0YnRzID0gc2wgKiA4O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKCFsbSkge1xuICAgICAgICAgICAgLy8gQkZJTkFMIC0gdGhpcyBpcyBvbmx5IDEgd2hlbiBsYXN0IGNodW5rIGlzIG5leHRcbiAgICAgICAgICAgIHN0LmYgPSBmaW5hbCA9IGJpdHMoZGF0LCBwb3MsIDEpO1xuICAgICAgICAgICAgLy8gdHlwZTogMCA9IG5vIGNvbXByZXNzaW9uLCAxID0gZml4ZWQgaHVmZm1hbiwgMiA9IGR5bmFtaWMgaHVmZm1hblxuICAgICAgICAgICAgdmFyIHR5cGUgPSBiaXRzKGRhdCwgcG9zICsgMSwgMyk7XG4gICAgICAgICAgICBwb3MgKz0gMztcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIGdvIHRvIGVuZCBvZiBieXRlIGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBzaGZ0KHBvcykgKyA0LCBsID0gZGF0W3MgLSA0XSB8IChkYXRbcyAtIDNdIDw8IDgpLCB0ID0gcyArIGw7XG4gICAgICAgICAgICAgICAgaWYgKHQgPiBzbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICd1bmV4cGVjdGVkIEVPRic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc2l6ZVxuICAgICAgICAgICAgICAgIGlmIChub0J1ZilcbiAgICAgICAgICAgICAgICAgICAgY2J1ZihidCArIGwpO1xuICAgICAgICAgICAgICAgIC8vIENvcHkgb3ZlciB1bmNvbXByZXNzZWQgZGF0YVxuICAgICAgICAgICAgICAgIGJ1Zi5zZXQoZGF0LnN1YmFycmF5KHMsIHQpLCBidCk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IG5ldyBiaXRwb3MsIHVwZGF0ZSBieXRlIGNvdW50XG4gICAgICAgICAgICAgICAgc3QuYiA9IGJ0ICs9IGwsIHN0LnAgPSBwb3MgPSB0ICogODtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBsbSA9IGZscm0sIGRtID0gZmRybSwgbGJ0ID0gOSwgZGJ0ID0gNTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gMikge1xuICAgICAgICAgICAgICAgIC8vICBsaXRlcmFsICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aHNcbiAgICAgICAgICAgICAgICB2YXIgaExpdCA9IGJpdHMoZGF0LCBwb3MsIDMxKSArIDI1NywgaGNMZW4gPSBiaXRzKGRhdCwgcG9zICsgMTAsIDE1KSArIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHRsID0gaExpdCArIGJpdHMoZGF0LCBwb3MgKyA1LCAzMSkgKyAxO1xuICAgICAgICAgICAgICAgIHBvcyArPSAxNDtcbiAgICAgICAgICAgICAgICAvLyBsZW5ndGgrZGlzdGFuY2UgdHJlZVxuICAgICAgICAgICAgICAgIHZhciBsZHQgPSBuZXcgdTgodGwpO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RoIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgY2x0ID0gbmV3IHU4KDE5KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhjTGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGluZGV4IG1hcCB0byBnZXQgcmVhbCBjb2RlXG4gICAgICAgICAgICAgICAgICAgIGNsdFtjbGltW2ldXSA9IGJpdHMoZGF0LCBwb3MgKyBpICogMywgNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBoY0xlbiAqIDM7XG4gICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGhzIGJpdHNcbiAgICAgICAgICAgICAgICB2YXIgY2xiID0gbWF4KGNsdCksIGNsYm1zayA9ICgxIDw8IGNsYikgLSAxO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RocyBtYXBcbiAgICAgICAgICAgICAgICB2YXIgY2xtID0gaE1hcChjbHQsIGNsYiwgMSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBjbG1bYml0cyhkYXQsIHBvcywgY2xibXNrKV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgcmVhZFxuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gciAmIDE1O1xuICAgICAgICAgICAgICAgICAgICAvLyBzeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSByID4+PiA0O1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aCB0byBjb3B5XG4gICAgICAgICAgICAgICAgICAgIGlmIChzIDwgMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxkdFtpKytdID0gcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBjb3B5ICAgY291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gMCwgbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PSAxNilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMyArIGJpdHMoZGF0LCBwb3MsIDMpLCBwb3MgKz0gMiwgYyA9IGxkdFtpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzID09IDE3KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAzICsgYml0cyhkYXQsIHBvcywgNyksIHBvcyArPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAxOClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMTEgKyBiaXRzKGRhdCwgcG9zLCAxMjcpLCBwb3MgKz0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChuLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGR0W2krK10gPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgIGxlbmd0aCB0cmVlICAgICAgICAgICAgICAgICBkaXN0YW5jZSB0cmVlXG4gICAgICAgICAgICAgICAgdmFyIGx0ID0gbGR0LnN1YmFycmF5KDAsIGhMaXQpLCBkdCA9IGxkdC5zdWJhcnJheShoTGl0KTtcbiAgICAgICAgICAgICAgICAvLyBtYXggbGVuZ3RoIGJpdHNcbiAgICAgICAgICAgICAgICBsYnQgPSBtYXgobHQpO1xuICAgICAgICAgICAgICAgIC8vIG1heCBkaXN0IGJpdHNcbiAgICAgICAgICAgICAgICBkYnQgPSBtYXgoZHQpO1xuICAgICAgICAgICAgICAgIGxtID0gaE1hcChsdCwgbGJ0LCAxKTtcbiAgICAgICAgICAgICAgICBkbSA9IGhNYXAoZHQsIGRidCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAndW5leHBlY3RlZCBFT0YnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgYnVmZmVyIGNhbiBob2xkIHRoaXMgKyB0aGUgbGFyZ2VzdCBwb3NzaWJsZSBhZGRpdGlvblxuICAgICAgICAvLyBNYXhpbXVtIGNodW5rIHNpemUgKHByYWN0aWNhbGx5LCB0aGVvcmV0aWNhbGx5IGluZmluaXRlKSBpcyAyXjE3O1xuICAgICAgICBpZiAobm9CdWYpXG4gICAgICAgICAgICBjYnVmKGJ0ICsgMTMxMDcyKTtcbiAgICAgICAgdmFyIGxtcyA9ICgxIDw8IGxidCkgLSAxLCBkbXMgPSAoMSA8PCBkYnQpIC0gMTtcbiAgICAgICAgdmFyIGxwb3MgPSBwb3M7XG4gICAgICAgIGZvciAoOzsgbHBvcyA9IHBvcykge1xuICAgICAgICAgICAgLy8gYml0cyByZWFkLCBjb2RlXG4gICAgICAgICAgICB2YXIgYyA9IGxtW2JpdHMxNihkYXQsIHBvcykgJiBsbXNdLCBzeW0gPSBjID4+PiA0O1xuICAgICAgICAgICAgcG9zICs9IGMgJiAxNTtcbiAgICAgICAgICAgIGlmIChwb3MgPiB0YnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vU3QpXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICd1bmV4cGVjdGVkIEVPRic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWMpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgbGVuZ3RoL2xpdGVyYWwnO1xuICAgICAgICAgICAgaWYgKHN5bSA8IDI1NilcbiAgICAgICAgICAgICAgICBidWZbYnQrK10gPSBzeW07XG4gICAgICAgICAgICBlbHNlIGlmIChzeW0gPT0gMjU2KSB7XG4gICAgICAgICAgICAgICAgbHBvcyA9IHBvcywgbG0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkZCA9IHN5bSAtIDI1NDtcbiAgICAgICAgICAgICAgICAvLyBubyBleHRyYSBiaXRzIG5lZWRlZCBpZiBsZXNzXG4gICAgICAgICAgICAgICAgaWYgKHN5bSA+IDI2NCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmRleFxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHN5bSAtIDI1NywgYiA9IGZsZWJbaV07XG4gICAgICAgICAgICAgICAgICAgIGFkZCA9IGJpdHMoZGF0LCBwb3MsICgxIDw8IGIpIC0gMSkgKyBmbFtpXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRpc3RcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGRtW2JpdHMxNihkYXQsIHBvcykgJiBkbXNdLCBkc3ltID0gZCA+Pj4gNDtcbiAgICAgICAgICAgICAgICBpZiAoIWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIGRpc3RhbmNlJztcbiAgICAgICAgICAgICAgICBwb3MgKz0gZCAmIDE1O1xuICAgICAgICAgICAgICAgIHZhciBkdCA9IGZkW2RzeW1dO1xuICAgICAgICAgICAgICAgIGlmIChkc3ltID4gMykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGZkZWJbZHN5bV07XG4gICAgICAgICAgICAgICAgICAgIGR0ICs9IGJpdHMxNihkYXQsIHBvcykgJiAoKDEgPDwgYikgLSAxKSwgcG9zICs9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3MgPiB0YnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ3VuZXhwZWN0ZWQgRU9GJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub0J1ZilcbiAgICAgICAgICAgICAgICAgICAgY2J1ZihidCArIDEzMTA3Mik7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGJ0ICsgYWRkO1xuICAgICAgICAgICAgICAgIGZvciAoOyBidCA8IGVuZDsgYnQgKz0gNCkge1xuICAgICAgICAgICAgICAgICAgICBidWZbYnRdID0gYnVmW2J0IC0gZHRdO1xuICAgICAgICAgICAgICAgICAgICBidWZbYnQgKyAxXSA9IGJ1ZltidCArIDEgLSBkdF07XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltidCArIDJdID0gYnVmW2J0ICsgMiAtIGR0XTtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J0ICsgM10gPSBidWZbYnQgKyAzIC0gZHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidCA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdC5sID0gbG0sIHN0LnAgPSBscG9zLCBzdC5iID0gYnQ7XG4gICAgICAgIGlmIChsbSlcbiAgICAgICAgICAgIGZpbmFsID0gMSwgc3QubSA9IGxidCwgc3QuZCA9IGRtLCBzdC5uID0gZGJ0O1xuICAgIH0gd2hpbGUgKCFmaW5hbCk7XG4gICAgcmV0dXJuIGJ0ID09IGJ1Zi5sZW5ndGggPyBidWYgOiBzbGMoYnVmLCAwLCBidCk7XG59O1xuLy8gc3RhcnRpbmcgYXQgcCwgd3JpdGUgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGJpdHMgdGhhdCBjYW4gaG9sZCB2IHRvIGRcbnZhciB3Yml0cyA9IGZ1bmN0aW9uIChkLCBwLCB2KSB7XG4gICAgdiA8PD0gcCAmIDc7XG4gICAgdmFyIG8gPSAocCAvIDgpIHwgMDtcbiAgICBkW29dIHw9IHY7XG4gICAgZFtvICsgMV0gfD0gdiA+Pj4gODtcbn07XG4vLyBzdGFydGluZyBhdCBwLCB3cml0ZSB0aGUgbWluaW11bSBudW1iZXIgb2YgYml0cyAoPjgpIHRoYXQgY2FuIGhvbGQgdiB0byBkXG52YXIgd2JpdHMxNiA9IGZ1bmN0aW9uIChkLCBwLCB2KSB7XG4gICAgdiA8PD0gcCAmIDc7XG4gICAgdmFyIG8gPSAocCAvIDgpIHwgMDtcbiAgICBkW29dIHw9IHY7XG4gICAgZFtvICsgMV0gfD0gdiA+Pj4gODtcbiAgICBkW28gKyAyXSB8PSB2ID4+PiAxNjtcbn07XG4vLyBjcmVhdGVzIGNvZGUgbGVuZ3RocyBmcm9tIGEgZnJlcXVlbmN5IHRhYmxlXG52YXIgaFRyZWUgPSBmdW5jdGlvbiAoZCwgbWIpIHtcbiAgICAvLyBOZWVkIGV4dHJhIGluZm8gdG8gbWFrZSBhIHRyZWVcbiAgICB2YXIgdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoZFtpXSlcbiAgICAgICAgICAgIHQucHVzaCh7IHM6IGksIGY6IGRbaV0gfSk7XG4gICAgfVxuICAgIHZhciBzID0gdC5sZW5ndGg7XG4gICAgdmFyIHQyID0gdC5zbGljZSgpO1xuICAgIGlmICghcylcbiAgICAgICAgcmV0dXJuIFtldCwgMF07XG4gICAgaWYgKHMgPT0gMSkge1xuICAgICAgICB2YXIgdiA9IG5ldyB1OCh0WzBdLnMgKyAxKTtcbiAgICAgICAgdlt0WzBdLnNdID0gMTtcbiAgICAgICAgcmV0dXJuIFt2LCAxXTtcbiAgICB9XG4gICAgdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmYgLSBiLmY7IH0pO1xuICAgIC8vIGFmdGVyIGkyIHJlYWNoZXMgbGFzdCBpbmQsIHdpbGwgYmUgc3RvcHBlZFxuICAgIC8vIGZyZXEgbXVzdCBiZSBncmVhdGVyIHRoYW4gbGFyZ2VzdCBwb3NzaWJsZSBudW1iZXIgb2Ygc3ltYm9sc1xuICAgIHQucHVzaCh7IHM6IC0xLCBmOiAyNTAwMSB9KTtcbiAgICB2YXIgbCA9IHRbMF0sIHIgPSB0WzFdLCBpMCA9IDAsIGkxID0gMSwgaTIgPSAyO1xuICAgIHRbMF0gPSB7IHM6IC0xLCBmOiBsLmYgKyByLmYsIGw6IGwsIHI6IHIgfTtcbiAgICAvLyBlZmZpY2llbnQgYWxnb3JpdGhtIGZyb20gVVpJUC5qc1xuICAgIC8vIGkwIGlzIGxvb2tiZWhpbmQsIGkyIGlzIGxvb2thaGVhZCAtIGFmdGVyIHByb2Nlc3NpbmcgdHdvIGxvdy1mcmVxXG4gICAgLy8gc3ltYm9scyB0aGF0IGNvbWJpbmVkIGhhdmUgaGlnaCBmcmVxLCB3aWxsIHN0YXJ0IHByb2Nlc3NpbmcgaTIgKGhpZ2gtZnJlcSxcbiAgICAvLyBub24tY29tcG9zaXRlKSBzeW1ib2xzIGluc3RlYWRcbiAgICAvLyBzZWUgaHR0cHM6Ly9yZWRkaXQuY29tL3IvcGhvdG9wZWEvY29tbWVudHMvaWtla2h0L3V6aXBqc19xdWVzdGlvbnMvXG4gICAgd2hpbGUgKGkxICE9IHMgLSAxKSB7XG4gICAgICAgIGwgPSB0W3RbaTBdLmYgPCB0W2kyXS5mID8gaTArKyA6IGkyKytdO1xuICAgICAgICByID0gdFtpMCAhPSBpMSAmJiB0W2kwXS5mIDwgdFtpMl0uZiA/IGkwKysgOiBpMisrXTtcbiAgICAgICAgdFtpMSsrXSA9IHsgczogLTEsIGY6IGwuZiArIHIuZiwgbDogbCwgcjogciB9O1xuICAgIH1cbiAgICB2YXIgbWF4U3ltID0gdDJbMF0ucztcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHM7ICsraSkge1xuICAgICAgICBpZiAodDJbaV0ucyA+IG1heFN5bSlcbiAgICAgICAgICAgIG1heFN5bSA9IHQyW2ldLnM7XG4gICAgfVxuICAgIC8vIGNvZGUgbGVuZ3Roc1xuICAgIHZhciB0ciA9IG5ldyB1MTYobWF4U3ltICsgMSk7XG4gICAgLy8gbWF4IGJpdHMgaW4gdHJlZVxuICAgIHZhciBtYnQgPSBsbih0W2kxIC0gMV0sIHRyLCAwKTtcbiAgICBpZiAobWJ0ID4gbWIpIHtcbiAgICAgICAgLy8gbW9yZSBhbGdvcml0aG1zIGZyb20gVVpJUC5qc1xuICAgICAgICAvLyBUT0RPOiBmaW5kIG91dCBob3cgdGhpcyBjb2RlIHdvcmtzIChkZWJ0KVxuICAgICAgICAvLyAgaW5kICAgIGRlYnRcbiAgICAgICAgdmFyIGkgPSAwLCBkdCA9IDA7XG4gICAgICAgIC8vICAgIGxlZnQgICAgICAgICAgICBjb3N0XG4gICAgICAgIHZhciBsZnQgPSBtYnQgLSBtYiwgY3N0ID0gMSA8PCBsZnQ7XG4gICAgICAgIHQyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHRyW2Iuc10gLSB0clthLnNdIHx8IGEuZiAtIGIuZjsgfSk7XG4gICAgICAgIGZvciAoOyBpIDwgczsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaTJfMSA9IHQyW2ldLnM7XG4gICAgICAgICAgICBpZiAodHJbaTJfMV0gPiBtYikge1xuICAgICAgICAgICAgICAgIGR0ICs9IGNzdCAtICgxIDw8IChtYnQgLSB0cltpMl8xXSkpO1xuICAgICAgICAgICAgICAgIHRyW2kyXzFdID0gbWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZHQgPj4+PSBsZnQ7XG4gICAgICAgIHdoaWxlIChkdCA+IDApIHtcbiAgICAgICAgICAgIHZhciBpMl8yID0gdDJbaV0ucztcbiAgICAgICAgICAgIGlmICh0cltpMl8yXSA8IG1iKVxuICAgICAgICAgICAgICAgIGR0IC09IDEgPDwgKG1iIC0gdHJbaTJfMl0rKyAtIDEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA+PSAwICYmIGR0OyAtLWkpIHtcbiAgICAgICAgICAgIHZhciBpMl8zID0gdDJbaV0ucztcbiAgICAgICAgICAgIGlmICh0cltpMl8zXSA9PSBtYikge1xuICAgICAgICAgICAgICAgIC0tdHJbaTJfM107XG4gICAgICAgICAgICAgICAgKytkdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYnQgPSBtYjtcbiAgICB9XG4gICAgcmV0dXJuIFtuZXcgdTgodHIpLCBtYnRdO1xufTtcbi8vIGdldCB0aGUgbWF4IGxlbmd0aCBhbmQgYXNzaWduIGxlbmd0aCBjb2Rlc1xudmFyIGxuID0gZnVuY3Rpb24gKG4sIGwsIGQpIHtcbiAgICByZXR1cm4gbi5zID09IC0xXG4gICAgICAgID8gTWF0aC5tYXgobG4obi5sLCBsLCBkICsgMSksIGxuKG4uciwgbCwgZCArIDEpKVxuICAgICAgICA6IChsW24uc10gPSBkKTtcbn07XG4vLyBsZW5ndGggY29kZXMgZ2VuZXJhdGlvblxudmFyIGxjID0gZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgcyA9IGMubGVuZ3RoO1xuICAgIC8vIE5vdGUgdGhhdCB0aGUgc2VtaWNvbG9uIHdhcyBpbnRlbnRpb25hbFxuICAgIHdoaWxlIChzICYmICFjWy0tc10pXG4gICAgICAgIDtcbiAgICB2YXIgY2wgPSBuZXcgdTE2KCsrcyk7XG4gICAgLy8gIGluZCAgICAgIG51bSAgICAgICAgIHN0cmVha1xuICAgIHZhciBjbGkgPSAwLCBjbG4gPSBjWzBdLCBjbHMgPSAxO1xuICAgIHZhciB3ID0gZnVuY3Rpb24gKHYpIHsgY2xbY2xpKytdID0gdjsgfTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBzOyArK2kpIHtcbiAgICAgICAgaWYgKGNbaV0gPT0gY2xuICYmIGkgIT0gcylcbiAgICAgICAgICAgICsrY2xzO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghY2xuICYmIGNscyA+IDIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgY2xzID4gMTM4OyBjbHMgLT0gMTM4KVxuICAgICAgICAgICAgICAgICAgICB3KDMyNzU0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzID4gMikge1xuICAgICAgICAgICAgICAgICAgICB3KGNscyA+IDEwID8gKChjbHMgLSAxMSkgPDwgNSkgfCAyODY5MCA6ICgoY2xzIC0gMykgPDwgNSkgfCAxMjMwNSk7XG4gICAgICAgICAgICAgICAgICAgIGNscyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2xzID4gMykge1xuICAgICAgICAgICAgICAgIHcoY2xuKSwgLS1jbHM7XG4gICAgICAgICAgICAgICAgZm9yICg7IGNscyA+IDY7IGNscyAtPSA2KVxuICAgICAgICAgICAgICAgICAgICB3KDgzMDQpO1xuICAgICAgICAgICAgICAgIGlmIChjbHMgPiAyKVxuICAgICAgICAgICAgICAgICAgICB3KCgoY2xzIC0gMykgPDwgNSkgfCA4MjA4KSwgY2xzID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjbHMtLSlcbiAgICAgICAgICAgICAgICB3KGNsbik7XG4gICAgICAgICAgICBjbHMgPSAxO1xuICAgICAgICAgICAgY2xuID0gY1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2NsLnN1YmFycmF5KDAsIGNsaSksIHNdO1xufTtcbi8vIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIG91dHB1dCBmcm9tIHRyZWUsIGNvZGUgbGVuZ3Roc1xudmFyIGNsZW4gPSBmdW5jdGlvbiAoY2YsIGNsKSB7XG4gICAgdmFyIGwgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2wubGVuZ3RoOyArK2kpXG4gICAgICAgIGwgKz0gY2ZbaV0gKiBjbFtpXTtcbiAgICByZXR1cm4gbDtcbn07XG4vLyB3cml0ZXMgYSBmaXhlZCBibG9ja1xuLy8gcmV0dXJucyB0aGUgbmV3IGJpdCBwb3NcbnZhciB3ZmJsayA9IGZ1bmN0aW9uIChvdXQsIHBvcywgZGF0KSB7XG4gICAgLy8gbm8gbmVlZCB0byB3cml0ZSAwMCBhcyB0eXBlOiBUeXBlZEFycmF5IGRlZmF1bHRzIHRvIDBcbiAgICB2YXIgcyA9IGRhdC5sZW5ndGg7XG4gICAgdmFyIG8gPSBzaGZ0KHBvcyArIDIpO1xuICAgIG91dFtvXSA9IHMgJiAyNTU7XG4gICAgb3V0W28gKyAxXSA9IHMgPj4+IDg7XG4gICAgb3V0W28gKyAyXSA9IG91dFtvXSBeIDI1NTtcbiAgICBvdXRbbyArIDNdID0gb3V0W28gKyAxXSBeIDI1NTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7ICsraSlcbiAgICAgICAgb3V0W28gKyBpICsgNF0gPSBkYXRbaV07XG4gICAgcmV0dXJuIChvICsgNCArIHMpICogODtcbn07XG4vLyB3cml0ZXMgYSBibG9ja1xudmFyIHdibGsgPSBmdW5jdGlvbiAoZGF0LCBvdXQsIGZpbmFsLCBzeW1zLCBsZiwgZGYsIGViLCBsaSwgYnMsIGJsLCBwKSB7XG4gICAgd2JpdHMob3V0LCBwKyssIGZpbmFsKTtcbiAgICArK2xmWzI1Nl07XG4gICAgdmFyIF9hID0gaFRyZWUobGYsIDE1KSwgZGx0ID0gX2FbMF0sIG1sYiA9IF9hWzFdO1xuICAgIHZhciBfYiA9IGhUcmVlKGRmLCAxNSksIGRkdCA9IF9iWzBdLCBtZGIgPSBfYlsxXTtcbiAgICB2YXIgX2MgPSBsYyhkbHQpLCBsY2x0ID0gX2NbMF0sIG5sYyA9IF9jWzFdO1xuICAgIHZhciBfZCA9IGxjKGRkdCksIGxjZHQgPSBfZFswXSwgbmRjID0gX2RbMV07XG4gICAgdmFyIGxjZnJlcSA9IG5ldyB1MTYoMTkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGNsdC5sZW5ndGg7ICsraSlcbiAgICAgICAgbGNmcmVxW2xjbHRbaV0gJiAzMV0rKztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxjZHQubGVuZ3RoOyArK2kpXG4gICAgICAgIGxjZnJlcVtsY2R0W2ldICYgMzFdKys7XG4gICAgdmFyIF9lID0gaFRyZWUobGNmcmVxLCA3KSwgbGN0ID0gX2VbMF0sIG1sY2IgPSBfZVsxXTtcbiAgICB2YXIgbmxjYyA9IDE5O1xuICAgIGZvciAoOyBubGNjID4gNCAmJiAhbGN0W2NsaW1bbmxjYyAtIDFdXTsgLS1ubGNjKVxuICAgICAgICA7XG4gICAgdmFyIGZsZW4gPSAoYmwgKyA1KSA8PCAzO1xuICAgIHZhciBmdGxlbiA9IGNsZW4obGYsIGZsdCkgKyBjbGVuKGRmLCBmZHQpICsgZWI7XG4gICAgdmFyIGR0bGVuID0gY2xlbihsZiwgZGx0KSArIGNsZW4oZGYsIGRkdCkgKyBlYiArIDE0ICsgMyAqIG5sY2MgKyBjbGVuKGxjZnJlcSwgbGN0KSArICgyICogbGNmcmVxWzE2XSArIDMgKiBsY2ZyZXFbMTddICsgNyAqIGxjZnJlcVsxOF0pO1xuICAgIGlmIChmbGVuIDw9IGZ0bGVuICYmIGZsZW4gPD0gZHRsZW4pXG4gICAgICAgIHJldHVybiB3ZmJsayhvdXQsIHAsIGRhdC5zdWJhcnJheShicywgYnMgKyBibCkpO1xuICAgIHZhciBsbSwgbGwsIGRtLCBkbDtcbiAgICB3Yml0cyhvdXQsIHAsIDEgKyAoZHRsZW4gPCBmdGxlbikpLCBwICs9IDI7XG4gICAgaWYgKGR0bGVuIDwgZnRsZW4pIHtcbiAgICAgICAgbG0gPSBoTWFwKGRsdCwgbWxiLCAwKSwgbGwgPSBkbHQsIGRtID0gaE1hcChkZHQsIG1kYiwgMCksIGRsID0gZGR0O1xuICAgICAgICB2YXIgbGxtID0gaE1hcChsY3QsIG1sY2IsIDApO1xuICAgICAgICB3Yml0cyhvdXQsIHAsIG5sYyAtIDI1Nyk7XG4gICAgICAgIHdiaXRzKG91dCwgcCArIDUsIG5kYyAtIDEpO1xuICAgICAgICB3Yml0cyhvdXQsIHAgKyAxMCwgbmxjYyAtIDQpO1xuICAgICAgICBwICs9IDE0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5sY2M7ICsraSlcbiAgICAgICAgICAgIHdiaXRzKG91dCwgcCArIDMgKiBpLCBsY3RbY2xpbVtpXV0pO1xuICAgICAgICBwICs9IDMgKiBubGNjO1xuICAgICAgICB2YXIgbGN0cyA9IFtsY2x0LCBsY2R0XTtcbiAgICAgICAgZm9yICh2YXIgaXQgPSAwOyBpdCA8IDI7ICsraXQpIHtcbiAgICAgICAgICAgIHZhciBjbGN0ID0gbGN0c1tpdF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsY3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gY2xjdFtpXSAmIDMxO1xuICAgICAgICAgICAgICAgIHdiaXRzKG91dCwgcCwgbGxtW2xlbl0pLCBwICs9IGxjdFtsZW5dO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxNSlcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMob3V0LCBwLCAoY2xjdFtpXSA+Pj4gNSkgJiAxMjcpLCBwICs9IGNsY3RbaV0gPj4+IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsbSA9IGZsbSwgbGwgPSBmbHQsIGRtID0gZmRtLCBkbCA9IGZkdDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaTsgKytpKSB7XG4gICAgICAgIGlmIChzeW1zW2ldID4gMjU1KSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gKHN5bXNbaV0gPj4+IDE4KSAmIDMxO1xuICAgICAgICAgICAgd2JpdHMxNihvdXQsIHAsIGxtW2xlbiArIDI1N10pLCBwICs9IGxsW2xlbiArIDI1N107XG4gICAgICAgICAgICBpZiAobGVuID4gNylcbiAgICAgICAgICAgICAgICB3Yml0cyhvdXQsIHAsIChzeW1zW2ldID4+PiAyMykgJiAzMSksIHAgKz0gZmxlYltsZW5dO1xuICAgICAgICAgICAgdmFyIGRzdCA9IHN5bXNbaV0gJiAzMTtcbiAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCBkbVtkc3RdKSwgcCArPSBkbFtkc3RdO1xuICAgICAgICAgICAgaWYgKGRzdCA+IDMpXG4gICAgICAgICAgICAgICAgd2JpdHMxNihvdXQsIHAsIChzeW1zW2ldID4+PiA1KSAmIDgxOTEpLCBwICs9IGZkZWJbZHN0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCBsbVtzeW1zW2ldXSksIHAgKz0gbGxbc3ltc1tpXV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2JpdHMxNihvdXQsIHAsIGxtWzI1Nl0pO1xuICAgIHJldHVybiBwICsgbGxbMjU2XTtcbn07XG4vLyBkZWZsYXRlIG9wdGlvbnMgKG5pY2UgPDwgMTMpIHwgY2hhaW5cbnZhciBkZW8gPSAvKiNfX1BVUkVfXyovIG5ldyB1MzIoWzY1NTQwLCAxMzEwODAsIDEzMTA4OCwgMTMxMTA0LCAyNjIxNzYsIDEwNDg3MDQsIDEwNDg4MzIsIDIxMTQ1NjAsIDIxMTc2MzJdKTtcbi8vIGVtcHR5XG52YXIgZXQgPSAvKiNfX1BVUkVfXyovIG5ldyB1OCgwKTtcbi8vIGNvbXByZXNzZXMgZGF0YSBpbnRvIGEgcmF3IERFRkxBVEUgYnVmZmVyXG52YXIgZGZsdCA9IGZ1bmN0aW9uIChkYXQsIGx2bCwgcGx2bCwgcHJlLCBwb3N0LCBsc3QpIHtcbiAgICB2YXIgcyA9IGRhdC5sZW5ndGg7XG4gICAgdmFyIG8gPSBuZXcgdTgocHJlICsgcyArIDUgKiAoMSArIE1hdGguY2VpbChzIC8gNzAwMCkpICsgcG9zdCk7XG4gICAgLy8gd3JpdGluZyB0byB0aGlzIHdyaXRlcyB0byB0aGUgb3V0cHV0IGJ1ZmZlclxuICAgIHZhciB3ID0gby5zdWJhcnJheShwcmUsIG8ubGVuZ3RoIC0gcG9zdCk7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgaWYgKCFsdmwgfHwgcyA8IDgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gczsgaSArPSA2NTUzNSkge1xuICAgICAgICAgICAgLy8gZW5kXG4gICAgICAgICAgICB2YXIgZSA9IGkgKyA2NTUzNTtcbiAgICAgICAgICAgIGlmIChlIDwgcykge1xuICAgICAgICAgICAgICAgIC8vIHdyaXRlIGZ1bGwgYmxvY2tcbiAgICAgICAgICAgICAgICBwb3MgPSB3ZmJsayh3LCBwb3MsIGRhdC5zdWJhcnJheShpLCBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3cml0ZSBmaW5hbCBibG9ja1xuICAgICAgICAgICAgICAgIHdbaV0gPSBsc3Q7XG4gICAgICAgICAgICAgICAgcG9zID0gd2ZibGsodywgcG9zLCBkYXQuc3ViYXJyYXkoaSwgcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgb3B0ID0gZGVvW2x2bCAtIDFdO1xuICAgICAgICB2YXIgbiA9IG9wdCA+Pj4gMTMsIGMgPSBvcHQgJiA4MTkxO1xuICAgICAgICB2YXIgbXNrXzEgPSAoMSA8PCBwbHZsKSAtIDE7XG4gICAgICAgIC8vICAgIHByZXYgMi1ieXRlIHZhbCBtYXAgICAgY3VyciAyLWJ5dGUgdmFsIG1hcFxuICAgICAgICB2YXIgcHJldiA9IG5ldyB1MTYoMzI3NjgpLCBoZWFkID0gbmV3IHUxNihtc2tfMSArIDEpO1xuICAgICAgICB2YXIgYnMxXzEgPSBNYXRoLmNlaWwocGx2bCAvIDMpLCBiczJfMSA9IDIgKiBiczFfMTtcbiAgICAgICAgdmFyIGhzaCA9IGZ1bmN0aW9uIChpKSB7IHJldHVybiAoZGF0W2ldIF4gKGRhdFtpICsgMV0gPDwgYnMxXzEpIF4gKGRhdFtpICsgMl0gPDwgYnMyXzEpKSAmIG1za18xOyB9O1xuICAgICAgICAvLyAyNDU3NiBpcyBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIG1heGltdW0gc3ltYm9scyBwZXIgYmxvY2tcbiAgICAgICAgLy8gNDI0IGJ1ZmZlciBmb3IgbGFzdCBibG9ja1xuICAgICAgICB2YXIgc3ltcyA9IG5ldyB1MzIoMjUwMDApO1xuICAgICAgICAvLyBsZW5ndGgvbGl0ZXJhbCBmcmVxICAgZGlzdGFuY2UgZnJlcVxuICAgICAgICB2YXIgbGYgPSBuZXcgdTE2KDI4OCksIGRmID0gbmV3IHUxNigzMik7XG4gICAgICAgIC8vICBsL2xjbnQgIGV4Yml0cyAgaW5kZXggIGwvbGluZCAgd2FpdGR4ICBiaXRwb3NcbiAgICAgICAgdmFyIGxjXzEgPSAwLCBlYiA9IDAsIGkgPSAwLCBsaSA9IDAsIHdpID0gMCwgYnMgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgLy8gaGFzaCB2YWx1ZVxuICAgICAgICAgICAgLy8gZGVvcHQgd2hlbiBpID4gcyAtIDMgLSBhdCBlbmQsIGRlb3B0IGFjY2VwdGFibGVcbiAgICAgICAgICAgIHZhciBodiA9IGhzaChpKTtcbiAgICAgICAgICAgIC8vIGluZGV4IG1vZCAzMjc2OCAgICBwcmV2aW91cyBpbmRleCBtb2RcbiAgICAgICAgICAgIHZhciBpbW9kID0gaSAmIDMyNzY3LCBwaW1vZCA9IGhlYWRbaHZdO1xuICAgICAgICAgICAgcHJldltpbW9kXSA9IHBpbW9kO1xuICAgICAgICAgICAgaGVhZFtodl0gPSBpbW9kO1xuICAgICAgICAgICAgLy8gV2UgYWx3YXlzIHNob3VsZCBtb2RpZnkgaGVhZCBhbmQgcHJldiwgYnV0IG9ubHkgYWRkIHN5bWJvbHMgaWZcbiAgICAgICAgICAgIC8vIHRoaXMgZGF0YSBpcyBub3QgeWV0IHByb2Nlc3NlZCAoXCJ3YWl0XCIgZm9yIHdhaXQgaW5kZXgpXG4gICAgICAgICAgICBpZiAod2kgPD0gaSkge1xuICAgICAgICAgICAgICAgIC8vIGJ5dGVzIHJlbWFpbmluZ1xuICAgICAgICAgICAgICAgIHZhciByZW0gPSBzIC0gaTtcbiAgICAgICAgICAgICAgICBpZiAoKGxjXzEgPiA3MDAwIHx8IGxpID4gMjQ1NzYpICYmIHJlbSA+IDQyMykge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB3YmxrKGRhdCwgdywgMCwgc3ltcywgbGYsIGRmLCBlYiwgbGksIGJzLCBpIC0gYnMsIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxpID0gbGNfMSA9IGViID0gMCwgYnMgPSBpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDI4NjsgKytqKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGZbal0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDMwOyArK2opXG4gICAgICAgICAgICAgICAgICAgICAgICBkZltqXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICBsZW4gICAgZGlzdCAgIGNoYWluXG4gICAgICAgICAgICAgICAgdmFyIGwgPSAyLCBkID0gMCwgY2hfMSA9IGMsIGRpZiA9IChpbW9kIC0gcGltb2QpICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgaWYgKHJlbSA+IDIgJiYgaHYgPT0gaHNoKGkgLSBkaWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhuID0gTWF0aC5taW4obiwgcmVtKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhkID0gTWF0aC5taW4oMzI3NjcsIGkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXggcG9zc2libGUgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBjYXBwZWQgYXQgZGlmIGJlY2F1c2UgZGVjb21wcmVzc29ycyBpbXBsZW1lbnQgXCJyb2xsaW5nXCIgaW5kZXggcG9wdWxhdGlvblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWwgPSBNYXRoLm1pbigyNTgsIHJlbSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChkaWYgPD0gbWF4ZCAmJiAtLWNoXzEgJiYgaW1vZCAhPSBwaW1vZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdFtpICsgbF0gPT0gZGF0W2kgKyBsIC0gZGlmXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBubCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IG5sIDwgbWwgJiYgZGF0W2kgKyBubF0gPT0gZGF0W2kgKyBubCAtIGRpZl07ICsrbmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmwgPiBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBubCwgZCA9IGRpZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWsgb3V0IGVhcmx5IHdoZW4gd2UgcmVhY2ggXCJuaWNlXCIgKHdlIGFyZSBzYXRpc2ZpZWQgZW5vdWdoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmwgPiBtYXhuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdywgZmluZCB0aGUgcmFyZXN0IDItYnl0ZSBzZXF1ZW5jZSB3aXRoaW4gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZW5ndGggb2YgbGl0ZXJhbHMgYW5kIHNlYXJjaCBmb3IgdGhhdCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdWNoIGZhc3RlciB0aGFuIGp1c3QgdXNpbmcgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtbWQgPSBNYXRoLm1pbihkaWYsIG5sIC0gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbW1kOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aSA9IChpIC0gZGlmICsgaiArIDMyNzY4KSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB0aSA9IHByZXZbdGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNkID0gKHRpIC0gcHRpICsgMzI3NjgpICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2QgPiBtZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZCA9IGNkLCBwaW1vZCA9IHRpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIHByZXZpb3VzIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbW9kID0gcGltb2QsIHBpbW9kID0gcHJldltpbW9kXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZiArPSAoaW1vZCAtIHBpbW9kICsgMzI3NjgpICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZCB3aWxsIGJlIG5vbnplcm8gb25seSB3aGVuIGEgbWF0Y2ggd2FzIGZvdW5kXG4gICAgICAgICAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgYm90aCBkaXN0IGFuZCBsZW4gZGF0YSBpbiBvbmUgVWludDMyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIGlzIHJlY29nbml6ZWQgYXMgYSBsZW4vZGlzdCB3aXRoIDI4dGggYml0ICgyXjI4KVxuICAgICAgICAgICAgICAgICAgICBzeW1zW2xpKytdID0gMjY4NDM1NDU2IHwgKHJldmZsW2xdIDw8IDE4KSB8IHJldmZkW2RdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluID0gcmV2ZmxbbF0gJiAzMSwgZGluID0gcmV2ZmRbZF0gJiAzMTtcbiAgICAgICAgICAgICAgICAgICAgZWIgKz0gZmxlYltsaW5dICsgZmRlYltkaW5dO1xuICAgICAgICAgICAgICAgICAgICArK2xmWzI1NyArIGxpbl07XG4gICAgICAgICAgICAgICAgICAgICsrZGZbZGluXTtcbiAgICAgICAgICAgICAgICAgICAgd2kgPSBpICsgbDtcbiAgICAgICAgICAgICAgICAgICAgKytsY18xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltc1tsaSsrXSA9IGRhdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgKytsZltkYXRbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3MgPSB3YmxrKGRhdCwgdywgbHN0LCBzeW1zLCBsZiwgZGYsIGViLCBsaSwgYnMsIGkgLSBicywgcG9zKTtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZWFzaWVzdCB3YXkgdG8gYXZvaWQgbmVlZGluZyB0byBtYWludGFpbiBzdGF0ZVxuICAgICAgICBpZiAoIWxzdCAmJiBwb3MgJiA3KVxuICAgICAgICAgICAgcG9zID0gd2ZibGsodywgcG9zICsgMSwgZXQpO1xuICAgIH1cbiAgICByZXR1cm4gc2xjKG8sIDAsIHByZSArIHNoZnQocG9zKSArIHBvc3QpO1xufTtcbi8vIENSQzMyIHRhYmxlXG52YXIgY3JjdCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdCA9IG5ldyBJbnQzMkFycmF5KDI1Nik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgICB2YXIgYyA9IGksIGsgPSA5O1xuICAgICAgICB3aGlsZSAoLS1rKVxuICAgICAgICAgICAgYyA9ICgoYyAmIDEpICYmIC0zMDY2NzQ5MTIpIF4gKGMgPj4+IDEpO1xuICAgICAgICB0W2ldID0gYztcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59KSgpO1xuLy8gQ1JDMzJcbnZhciBjcmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGMgPSAtMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgLy8gY2xvc3VyZXMgaGF2ZSBhd2Z1bCBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgdmFyIGNyID0gYztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBjciA9IGNyY3RbKGNyICYgMjU1KSBeIGRbaV1dIF4gKGNyID4+PiA4KTtcbiAgICAgICAgICAgIGMgPSBjcjtcbiAgICAgICAgfSxcbiAgICAgICAgZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gfmM7IH1cbiAgICB9O1xufTtcbi8vIEFsZGVyMzJcbnZhciBhZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYSA9IDEsIGIgPSAwO1xuICAgIHJldHVybiB7XG4gICAgICAgIHA6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAvLyBjbG9zdXJlcyBoYXZlIGF3ZnVsIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICB2YXIgbiA9IGEsIG0gPSBiO1xuICAgICAgICAgICAgdmFyIGwgPSBkLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9IGw7KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBNYXRoLm1pbihpICsgMjY1NSwgbCk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBlOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG0gKz0gbiArPSBkW2ldO1xuICAgICAgICAgICAgICAgIG4gPSAobiAmIDY1NTM1KSArIDE1ICogKG4gPj4gMTYpLCBtID0gKG0gJiA2NTUzNSkgKyAxNSAqIChtID4+IDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEgPSBuLCBiID0gbTtcbiAgICAgICAgfSxcbiAgICAgICAgZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYSAlPSA2NTUyMSwgYiAlPSA2NTUyMTtcbiAgICAgICAgICAgIHJldHVybiAoYSAmIDI1NSkgPDwgMjQgfCAoYSA+Pj4gOCkgPDwgMTYgfCAoYiAmIDI1NSkgPDwgOCB8IChiID4+PiA4KTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuO1xuLy8gZGVmbGF0ZSB3aXRoIG9wdHNcbnZhciBkb3B0ID0gZnVuY3Rpb24gKGRhdCwgb3B0LCBwcmUsIHBvc3QsIHN0KSB7XG4gICAgcmV0dXJuIGRmbHQoZGF0LCBvcHQubGV2ZWwgPT0gbnVsbCA/IDYgOiBvcHQubGV2ZWwsIG9wdC5tZW0gPT0gbnVsbCA/IE1hdGguY2VpbChNYXRoLm1heCg4LCBNYXRoLm1pbigxMywgTWF0aC5sb2coZGF0Lmxlbmd0aCkpKSAqIDEuNSkgOiAoMTIgKyBvcHQubWVtKSwgcHJlLCBwb3N0LCAhc3QpO1xufTtcbi8vIFdhbG1hcnQgb2JqZWN0IHNwcmVhZFxudmFyIG1yZyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIG8gPSB7fTtcbiAgICBmb3IgKHZhciBrIGluIGEpXG4gICAgICAgIG9ba10gPSBhW2tdO1xuICAgIGZvciAodmFyIGsgaW4gYilcbiAgICAgICAgb1trXSA9IGJba107XG4gICAgcmV0dXJuIG87XG59O1xuLy8gd29ya2VyIGNsb25lXG4vLyBUaGlzIGlzIHBvc3NpYmx5IHRoZSBjcmF6aWVzdCBwYXJ0IG9mIHRoZSBlbnRpcmUgY29kZWJhc2UsIGRlc3BpdGUgaG93IHNpbXBsZSBpdCBtYXkgc2VlbS5cbi8vIFRoZSBvbmx5IHBhcmFtZXRlciB0byB0aGlzIGZ1bmN0aW9uIGlzIGEgY2xvc3VyZSB0aGF0IHJldHVybnMgYW4gYXJyYXkgb2YgdmFyaWFibGVzIG91dHNpZGUgb2YgdGhlIGZ1bmN0aW9uIHNjb3BlLlxuLy8gV2UncmUgZ29pbmcgdG8gdHJ5IHRvIGZpZ3VyZSBvdXQgdGhlIHZhcmlhYmxlIG5hbWVzIHVzZWQgaW4gdGhlIGNsb3N1cmUgYXMgc3RyaW5ncyBiZWNhdXNlIHRoYXQgaXMgY3J1Y2lhbCBmb3Igd29ya2VyaXphdGlvbi5cbi8vIFdlIHdpbGwgcmV0dXJuIGFuIG9iamVjdCBtYXBwaW5nIG9mIHRydWUgdmFyaWFibGUgbmFtZSB0byB2YWx1ZSAoYmFzaWNhbGx5LCB0aGUgY3VycmVudCBzY29wZSBhcyBhIEpTIG9iamVjdCkuXG4vLyBUaGUgcmVhc29uIHdlIGNhbid0IGp1c3QgdXNlIHRoZSBvcmlnaW5hbCB2YXJpYWJsZSBuYW1lcyBpcyBtaW5pZmllcnMgbWFuZ2xpbmcgdGhlIHRvcGxldmVsIHNjb3BlLlxuLy8gVGhpcyB0b29rIG1lIHRocmVlIHdlZWtzIHRvIGZpZ3VyZSBvdXQgaG93IHRvIGRvLlxudmFyIHdjbG4gPSBmdW5jdGlvbiAoZm4sIGZuU3RyLCB0ZCkge1xuICAgIHZhciBkdCA9IGZuKCk7XG4gICAgdmFyIHN0ID0gZm4udG9TdHJpbmcoKTtcbiAgICB2YXIga3MgPSBzdC5zbGljZShzdC5pbmRleE9mKCdbJykgKyAxLCBzdC5sYXN0SW5kZXhPZignXScpKS5yZXBsYWNlKC8gL2csICcnKS5zcGxpdCgnLCcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHYgPSBkdFtpXSwgayA9IGtzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZm5TdHIgKz0gJzsnICsgayArICc9JztcbiAgICAgICAgICAgIHZhciBzdF8xID0gdi50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHYucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGdsb2JhbCBvYmplY3RzXG4gICAgICAgICAgICAgICAgaWYgKHN0XzEuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcEluZCA9IHN0XzEuaW5kZXhPZignICcsIDgpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZm5TdHIgKz0gc3RfMS5zbGljZShzcEluZCwgc3RfMS5pbmRleE9mKCcoJywgc3BJbmQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZuU3RyICs9IHN0XzE7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgaW4gdi5wcm90b3R5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmblN0ciArPSAnOycgKyBrICsgJy5wcm90b3R5cGUuJyArIHQgKyAnPScgKyB2LnByb3RvdHlwZVt0XS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmblN0ciArPSBzdF8xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRkW2tdID0gdjtcbiAgICB9XG4gICAgcmV0dXJuIFtmblN0ciwgdGRdO1xufTtcbnZhciBjaCA9IFtdO1xuLy8gY2xvbmUgYnVmc1xudmFyIGNiZnMgPSBmdW5jdGlvbiAodikge1xuICAgIHZhciB0bCA9IFtdO1xuICAgIGZvciAodmFyIGsgaW4gdikge1xuICAgICAgICBpZiAodltrXSBpbnN0YW5jZW9mIHU4IHx8IHZba10gaW5zdGFuY2VvZiB1MTYgfHwgdltrXSBpbnN0YW5jZW9mIHUzMilcbiAgICAgICAgICAgIHRsLnB1c2goKHZba10gPSBuZXcgdltrXS5jb25zdHJ1Y3Rvcih2W2tdKSkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRsO1xufTtcbi8vIHVzZSBhIHdvcmtlciB0byBleGVjdXRlIGNvZGVcbnZhciB3cmtyID0gZnVuY3Rpb24gKGZucywgaW5pdCwgaWQsIGNiKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghY2hbaWRdKSB7XG4gICAgICAgIHZhciBmblN0ciA9ICcnLCB0ZF8xID0ge30sIG0gPSBmbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtOyArK2kpXG4gICAgICAgICAgICBfYSA9IHdjbG4oZm5zW2ldLCBmblN0ciwgdGRfMSksIGZuU3RyID0gX2FbMF0sIHRkXzEgPSBfYVsxXTtcbiAgICAgICAgY2hbaWRdID0gd2NsbihmbnNbbV0sIGZuU3RyLCB0ZF8xKTtcbiAgICB9XG4gICAgdmFyIHRkID0gbXJnKHt9LCBjaFtpZF1bMV0pO1xuICAgIHJldHVybiB3ayhjaFtpZF1bMF0gKyAnO29ubWVzc2FnZT1mdW5jdGlvbihlKXtmb3IodmFyIGsgaW4gZS5kYXRhKXNlbGZba109ZS5kYXRhW2tdO29ubWVzc2FnZT0nICsgaW5pdC50b1N0cmluZygpICsgJ30nLCBpZCwgdGQsIGNiZnModGQpLCBjYik7XG59O1xuLy8gYmFzZSBhc3luYyBpbmZsYXRlIGZuXG52YXIgYkluZmx0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW3U4LCB1MTYsIHUzMiwgZmxlYiwgZmRlYiwgY2xpbSwgZmwsIGZkLCBmbHJtLCBmZHJtLCByZXYsIGhNYXAsIG1heCwgYml0cywgYml0czE2LCBzaGZ0LCBzbGMsIGluZmx0LCBpbmZsYXRlU3luYywgcGJmLCBndThdOyB9O1xudmFyIGJEZmx0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW3U4LCB1MTYsIHUzMiwgZmxlYiwgZmRlYiwgY2xpbSwgcmV2ZmwsIHJldmZkLCBmbG0sIGZsdCwgZmRtLCBmZHQsIHJldiwgZGVvLCBldCwgaE1hcCwgd2JpdHMsIHdiaXRzMTYsIGhUcmVlLCBsbiwgbGMsIGNsZW4sIHdmYmxrLCB3YmxrLCBzaGZ0LCBzbGMsIGRmbHQsIGRvcHQsIGRlZmxhdGVTeW5jLCBwYmZdOyB9O1xuLy8gZ3ppcCBleHRyYVxudmFyIGd6ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtnemgsIGd6aGwsIHdieXRlcywgY3JjLCBjcmN0XTsgfTtcbi8vIGd1bnppcCBleHRyYVxudmFyIGd1emUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbZ3pzLCBnemxdOyB9O1xuLy8gemxpYiBleHRyYVxudmFyIHpsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt6bGgsIHdieXRlcywgYWRsZXJdOyB9O1xuLy8gdW56bGliIGV4dHJhXG52YXIgenVsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt6bHZdOyB9O1xuLy8gcG9zdCBidWZcbnZhciBwYmYgPSBmdW5jdGlvbiAobXNnKSB7IHJldHVybiBwb3N0TWVzc2FnZShtc2csIFttc2cuYnVmZmVyXSk7IH07XG4vLyBnZXQgdThcbnZhciBndTggPSBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBvLnNpemUgJiYgbmV3IHU4KG8uc2l6ZSk7IH07XG4vLyBhc3luYyBoZWxwZXJcbnZhciBjYmlmeSA9IGZ1bmN0aW9uIChkYXQsIG9wdHMsIGZucywgaW5pdCwgaWQsIGNiKSB7XG4gICAgdmFyIHcgPSB3cmtyKGZucywgaW5pdCwgaWQsIGZ1bmN0aW9uIChlcnIsIGRhdCkge1xuICAgICAgICB3LnRlcm1pbmF0ZSgpO1xuICAgICAgICBjYihlcnIsIGRhdCk7XG4gICAgfSk7XG4gICAgdy5wb3N0TWVzc2FnZShbZGF0LCBvcHRzXSwgb3B0cy5jb25zdW1lID8gW2RhdC5idWZmZXJdIDogW10pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHcudGVybWluYXRlKCk7IH07XG59O1xuLy8gYXV0byBzdHJlYW1cbnZhciBhc3RybSA9IGZ1bmN0aW9uIChzdHJtKSB7XG4gICAgc3RybS5vbmRhdGEgPSBmdW5jdGlvbiAoZGF0LCBmaW5hbCkgeyByZXR1cm4gcG9zdE1lc3NhZ2UoW2RhdCwgZmluYWxdLCBbZGF0LmJ1ZmZlcl0pOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHN0cm0ucHVzaChldi5kYXRhWzBdLCBldi5kYXRhWzFdKTsgfTtcbn07XG4vLyBhc3luYyBzdHJlYW0gYXR0YWNoXG52YXIgYXN0cm1pZnkgPSBmdW5jdGlvbiAoZm5zLCBzdHJtLCBvcHRzLCBpbml0LCBpZCkge1xuICAgIHZhciB0O1xuICAgIHZhciB3ID0gd3JrcihmbnMsIGluaXQsIGlkLCBmdW5jdGlvbiAoZXJyLCBkYXQpIHtcbiAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgIHcudGVybWluYXRlKCksIHN0cm0ub25kYXRhLmNhbGwoc3RybSwgZXJyKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGF0WzFdKVxuICAgICAgICAgICAgICAgIHcudGVybWluYXRlKCk7XG4gICAgICAgICAgICBzdHJtLm9uZGF0YS5jYWxsKHN0cm0sIGVyciwgZGF0WzBdLCBkYXRbMV0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdy5wb3N0TWVzc2FnZShvcHRzKTtcbiAgICBzdHJtLnB1c2ggPSBmdW5jdGlvbiAoZCwgZikge1xuICAgICAgICBpZiAodClcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICBpZiAoIXN0cm0ub25kYXRhKVxuICAgICAgICAgICAgdGhyb3cgJ25vIHN0cmVhbSBoYW5kbGVyJztcbiAgICAgICAgdy5wb3N0TWVzc2FnZShbZCwgdCA9IGZdLCBbZC5idWZmZXJdKTtcbiAgICB9O1xuICAgIHN0cm0udGVybWluYXRlID0gZnVuY3Rpb24gKCkgeyB3LnRlcm1pbmF0ZSgpOyB9O1xufTtcbi8vIHJlYWQgMiBieXRlc1xudmFyIGIyID0gZnVuY3Rpb24gKGQsIGIpIHsgcmV0dXJuIGRbYl0gfCAoZFtiICsgMV0gPDwgOCk7IH07XG4vLyByZWFkIDQgYnl0ZXNcbnZhciBiNCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiAoZFtiXSB8IChkW2IgKyAxXSA8PCA4KSB8IChkW2IgKyAyXSA8PCAxNikgfCAoZFtiICsgM10gPDwgMjQpKSA+Pj4gMDsgfTtcbnZhciBiOCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiBiNChkLCBiKSArIChiNChkLCBiICsgNCkgKiA0Mjk0OTY3Mjk2KTsgfTtcbi8vIHdyaXRlIGJ5dGVzXG52YXIgd2J5dGVzID0gZnVuY3Rpb24gKGQsIGIsIHYpIHtcbiAgICBmb3IgKDsgdjsgKytiKVxuICAgICAgICBkW2JdID0gdiwgdiA+Pj49IDg7XG59O1xuLy8gZ3ppcCBoZWFkZXJcbnZhciBnemggPSBmdW5jdGlvbiAoYywgbykge1xuICAgIHZhciBmbiA9IG8uZmlsZW5hbWU7XG4gICAgY1swXSA9IDMxLCBjWzFdID0gMTM5LCBjWzJdID0gOCwgY1s4XSA9IG8ubGV2ZWwgPCAyID8gNCA6IG8ubGV2ZWwgPT0gOSA/IDIgOiAwLCBjWzldID0gMzsgLy8gYXNzdW1lIFVuaXhcbiAgICBpZiAoby5tdGltZSAhPSAwKVxuICAgICAgICB3Ynl0ZXMoYywgNCwgTWF0aC5mbG9vcihuZXcgRGF0ZShvLm10aW1lIHx8IERhdGUubm93KCkpIC8gMTAwMCkpO1xuICAgIGlmIChmbikge1xuICAgICAgICBjWzNdID0gODtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZm4ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBjW2kgKyAxMF0gPSBmbi5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbn07XG4vLyBnemlwIGZvb3RlcjogLTggdG8gLTQgPSBDUkMsIC00IHRvIC0wIGlzIGxlbmd0aFxuLy8gZ3ppcCBzdGFydFxudmFyIGd6cyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKGRbMF0gIT0gMzEgfHwgZFsxXSAhPSAxMzkgfHwgZFsyXSAhPSA4KVxuICAgICAgICB0aHJvdyAnaW52YWxpZCBnemlwIGRhdGEnO1xuICAgIHZhciBmbGcgPSBkWzNdO1xuICAgIHZhciBzdCA9IDEwO1xuICAgIGlmIChmbGcgJiA0KVxuICAgICAgICBzdCArPSBkWzEwXSB8IChkWzExXSA8PCA4KSArIDI7XG4gICAgZm9yICh2YXIgenMgPSAoZmxnID4+IDMgJiAxKSArIChmbGcgPj4gNCAmIDEpOyB6cyA+IDA7IHpzIC09ICFkW3N0KytdKVxuICAgICAgICA7XG4gICAgcmV0dXJuIHN0ICsgKGZsZyAmIDIpO1xufTtcbi8vIGd6aXAgbGVuZ3RoXG52YXIgZ3psID0gZnVuY3Rpb24gKGQpIHtcbiAgICB2YXIgbCA9IGQubGVuZ3RoO1xuICAgIHJldHVybiAoKGRbbCAtIDRdIHwgZFtsIC0gM10gPDwgOCB8IGRbbCAtIDJdIDw8IDE2KSB8IChkW2wgLSAxXSA8PCAyNCkpID4+PiAwO1xufTtcbi8vIGd6aXAgaGVhZGVyIGxlbmd0aFxudmFyIGd6aGwgPSBmdW5jdGlvbiAobykgeyByZXR1cm4gMTAgKyAoKG8uZmlsZW5hbWUgJiYgKG8uZmlsZW5hbWUubGVuZ3RoICsgMSkpIHx8IDApOyB9O1xuLy8gemxpYiBoZWFkZXJcbnZhciB6bGggPSBmdW5jdGlvbiAoYywgbykge1xuICAgIHZhciBsdiA9IG8ubGV2ZWwsIGZsID0gbHYgPT0gMCA/IDAgOiBsdiA8IDYgPyAxIDogbHYgPT0gOSA/IDMgOiAyO1xuICAgIGNbMF0gPSAxMjAsIGNbMV0gPSAoZmwgPDwgNikgfCAoZmwgPyAoMzIgLSAyICogZmwpIDogMSk7XG59O1xuLy8gemxpYiB2YWxpZFxudmFyIHpsdiA9IGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKChkWzBdICYgMTUpICE9IDggfHwgKGRbMF0gPj4+IDQpID4gNyB8fCAoKGRbMF0gPDwgOCB8IGRbMV0pICUgMzEpKVxuICAgICAgICB0aHJvdyAnaW52YWxpZCB6bGliIGRhdGEnO1xuICAgIGlmIChkWzFdICYgMzIpXG4gICAgICAgIHRocm93ICdpbnZhbGlkIHpsaWIgZGF0YTogcHJlc2V0IGRpY3Rpb25hcmllcyBub3Qgc3VwcG9ydGVkJztcbn07XG5mdW5jdGlvbiBBc3luY0NtcFN0cm0ob3B0cywgY2IpIHtcbiAgICBpZiAoIWNiICYmIHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgcmV0dXJuIG9wdHM7XG59XG4vLyB6bGliIGZvb3RlcjogLTQgdG8gLTAgaXMgQWRsZXIzMlxuLyoqXG4gKiBTdHJlYW1pbmcgREVGTEFURSBjb21wcmVzc2lvblxuICovXG52YXIgRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZsYXRlKG9wdHMsIGNiKSB7XG4gICAgICAgIGlmICghY2IgJiYgdHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICB0aGlzLm8gPSBvcHRzIHx8IHt9O1xuICAgIH1cbiAgICBEZWZsYXRlLnByb3RvdHlwZS5wID0gZnVuY3Rpb24gKGMsIGYpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEoZG9wdChjLCB0aGlzLm8sIDAsIDAsICFmKSwgZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWZsYXRlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hlZCc7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gc3RyZWFtIGhhbmRsZXInO1xuICAgICAgICB0aGlzLmQgPSBmaW5hbDtcbiAgICAgICAgdGhpcy5wKGNodW5rLCBmaW5hbCB8fCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmbGF0ZTtcbn0oKSk7XG5leHBvcnQgeyBEZWZsYXRlIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgREVGTEFURSBjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNEZWZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzeW5jRGVmbGF0ZShvcHRzLCBjYikge1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiRGZsdCxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgRGVmbGF0ZV07IH1cbiAgICAgICAgXSwgdGhpcywgQXN5bmNDbXBTdHJtLmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IERlZmxhdGUoZXYuZGF0YSk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgNik7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0RlZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNEZWZsYXRlIH07XG5leHBvcnQgZnVuY3Rpb24gZGVmbGF0ZShkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiRGZsdCxcbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZihkZWZsYXRlU3luYyhldi5kYXRhWzBdLCBldi5kYXRhWzFdKSk7IH0sIDAsIGNiKTtcbn1cbi8qKlxuICogQ29tcHJlc3NlcyBkYXRhIHdpdGggREVGTEFURSB3aXRob3V0IGFueSB3cmFwcGVyXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBjb21wcmVzc1xuICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBkZWZsYXRlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlU3luYyhkYXRhLCBvcHRzKSB7XG4gICAgcmV0dXJuIGRvcHQoZGF0YSwgb3B0cyB8fCB7fSwgMCwgMCk7XG59XG4vKipcbiAqIFN0cmVhbWluZyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEluZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbmZsYXRpb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgaW5mbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbmZsYXRlKGNiKSB7XG4gICAgICAgIHRoaXMucyA9IHt9O1xuICAgICAgICB0aGlzLnAgPSBuZXcgdTgoMCk7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgfVxuICAgIEluZmxhdGUucHJvdG90eXBlLmUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hlZCc7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gc3RyZWFtIGhhbmRsZXInO1xuICAgICAgICB2YXIgbCA9IHRoaXMucC5sZW5ndGg7XG4gICAgICAgIHZhciBuID0gbmV3IHU4KGwgKyBjLmxlbmd0aCk7XG4gICAgICAgIG4uc2V0KHRoaXMucCksIG4uc2V0KGMsIGwpLCB0aGlzLnAgPSBuO1xuICAgIH07XG4gICAgSW5mbGF0ZS5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uIChmaW5hbCkge1xuICAgICAgICB0aGlzLmQgPSB0aGlzLnMuaSA9IGZpbmFsIHx8IGZhbHNlO1xuICAgICAgICB2YXIgYnRzID0gdGhpcy5zLmI7XG4gICAgICAgIHZhciBkdCA9IGluZmx0KHRoaXMucCwgdGhpcy5vLCB0aGlzLnMpO1xuICAgICAgICB0aGlzLm9uZGF0YShzbGMoZHQsIGJ0cywgdGhpcy5zLmIpLCB0aGlzLmQpO1xuICAgICAgICB0aGlzLm8gPSBzbGMoZHQsIHRoaXMucy5iIC0gMzI3NjgpLCB0aGlzLnMuYiA9IHRoaXMuby5sZW5ndGg7XG4gICAgICAgIHRoaXMucCA9IHNsYyh0aGlzLnAsICh0aGlzLnMucCAvIDgpIHwgMCksIHRoaXMucy5wICY9IDc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBpbmZsYXRlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGZpbmFsIGNodW5rXG4gICAgICovXG4gICAgSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdGhpcy5lKGNodW5rKSwgdGhpcy5jKGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBJbmZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IEluZmxhdGUgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jSW5mbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFzeW5jaHJvbm91cyBpbmZsYXRpb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVmbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY0luZmxhdGUoY2IpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkluZmx0LFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBJbmZsYXRlXTsgfVxuICAgICAgICBdLCB0aGlzLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBJbmZsYXRlKCk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgNyk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0luZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNJbmZsYXRlIH07XG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZShkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiSW5mbHRcbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZihpbmZsYXRlU3luYyhldi5kYXRhWzBdLCBndTgoZXYuZGF0YVsxXSkpKTsgfSwgMSwgY2IpO1xufVxuLyoqXG4gKiBFeHBhbmRzIERFRkxBVEUgZGF0YSB3aXRoIG5vIHdyYXBwZXJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29tcHJlc3NcbiAqIEBwYXJhbSBvdXQgV2hlcmUgdG8gd3JpdGUgdGhlIGRhdGEuIFNhdmVzIG1lbW9yeSBpZiB5b3Uga25vdyB0aGUgZGVjb21wcmVzc2VkIHNpemUgYW5kIHByb3ZpZGUgYW4gb3V0cHV0IGJ1ZmZlciBvZiB0aGF0IGxlbmd0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZVN5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIGluZmx0KGRhdGEsIG91dCk7XG59XG4vLyBiZWZvcmUgeW91IHllbGwgYXQgbWUgZm9yIG5vdCBqdXN0IHVzaW5nIGV4dGVuZHMsIG15IHJlYXNvbiBpcyB0aGF0IFRTIGluaGVyaXRhbmNlIGlzIGhhcmQgdG8gd29ya2VyaXplLlxuLyoqXG4gKiBTdHJlYW1pbmcgR1pJUCBjb21wcmVzc2lvblxuICovXG52YXIgR3ppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHemlwKG9wdHMsIGNiKSB7XG4gICAgICAgIHRoaXMuYyA9IGNyYygpO1xuICAgICAgICB0aGlzLmwgPSAwO1xuICAgICAgICB0aGlzLnYgPSAxO1xuICAgICAgICBEZWZsYXRlLmNhbGwodGhpcywgb3B0cywgY2IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBHWklQcGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIEd6aXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIERlZmxhdGUucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgR3ppcC5wcm90b3R5cGUucCA9IGZ1bmN0aW9uIChjLCBmKSB7XG4gICAgICAgIHRoaXMuYy5wKGMpO1xuICAgICAgICB0aGlzLmwgKz0gYy5sZW5ndGg7XG4gICAgICAgIHZhciByYXcgPSBkb3B0KGMsIHRoaXMubywgdGhpcy52ICYmIGd6aGwodGhpcy5vKSwgZiAmJiA4LCAhZik7XG4gICAgICAgIGlmICh0aGlzLnYpXG4gICAgICAgICAgICBnemgocmF3LCB0aGlzLm8pLCB0aGlzLnYgPSAwO1xuICAgICAgICBpZiAoZilcbiAgICAgICAgICAgIHdieXRlcyhyYXcsIHJhdy5sZW5ndGggLSA4LCB0aGlzLmMuZCgpKSwgd2J5dGVzKHJhdywgcmF3Lmxlbmd0aCAtIDQsIHRoaXMubCk7XG4gICAgICAgIHRoaXMub25kYXRhKHJhdywgZik7XG4gICAgfTtcbiAgICByZXR1cm4gR3ppcDtcbn0oKSk7XG5leHBvcnQgeyBHemlwIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgR1pJUCBjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNHemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzeW5jR3ppcChvcHRzLCBjYikge1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiRGZsdCxcbiAgICAgICAgICAgIGd6ZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgRGVmbGF0ZSwgR3ppcF07IH1cbiAgICAgICAgXSwgdGhpcywgQXN5bmNDbXBTdHJtLmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IEd6aXAoZXYuZGF0YSk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgOCk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0d6aXA7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNHemlwIH07XG5leHBvcnQgZnVuY3Rpb24gZ3ppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiRGZsdCxcbiAgICAgICAgZ3plLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbZ3ppcFN5bmNdOyB9XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoZ3ppcFN5bmMoZXYuZGF0YVswXSwgZXYuZGF0YVsxXSkpOyB9LCAyLCBjYik7XG59XG4vKipcbiAqIENvbXByZXNzZXMgZGF0YSB3aXRoIEdaSVBcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGNvbXByZXNzXG4gKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGd6aXBwZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ3ppcFN5bmMoZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cylcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIHZhciBjID0gY3JjKCksIGwgPSBkYXRhLmxlbmd0aDtcbiAgICBjLnAoZGF0YSk7XG4gICAgdmFyIGQgPSBkb3B0KGRhdGEsIG9wdHMsIGd6aGwob3B0cyksIDgpLCBzID0gZC5sZW5ndGg7XG4gICAgcmV0dXJuIGd6aChkLCBvcHRzKSwgd2J5dGVzKGQsIHMgLSA4LCBjLmQoKSksIHdieXRlcyhkLCBzIC0gNCwgbCksIGQ7XG59XG4vKipcbiAqIFN0cmVhbWluZyBHWklQIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEd1bnppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgR1VOWklQIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGluZmxhdGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gR3VuemlwKGNiKSB7XG4gICAgICAgIHRoaXMudiA9IDE7XG4gICAgICAgIEluZmxhdGUuY2FsbCh0aGlzLCBjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIEdVTlpJUHBlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBHdW56aXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIEluZmxhdGUucHJvdG90eXBlLmUuY2FsbCh0aGlzLCBjaHVuayk7XG4gICAgICAgIGlmICh0aGlzLnYpIHtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5wLmxlbmd0aCA+IDMgPyBnenModGhpcy5wKSA6IDQ7XG4gICAgICAgICAgICBpZiAocyA+PSB0aGlzLnAubGVuZ3RoICYmICFmaW5hbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnAgPSB0aGlzLnAuc3ViYXJyYXkocyksIHRoaXMudiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wLmxlbmd0aCA8IDgpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgZ3ppcCBzdHJlYW0nO1xuICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5wLnN1YmFycmF5KDAsIC04KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWNlc3NhcnkgdG8gcHJldmVudCBUUyBmcm9tIHVzaW5nIHRoZSBjbG9zdXJlIHZhbHVlXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIGZvciB3b3JrZXJpemF0aW9uIHRvIGZ1bmN0aW9uIGNvcnJlY3RseVxuICAgICAgICBJbmZsYXRlLnByb3RvdHlwZS5jLmNhbGwodGhpcywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIEd1bnppcDtcbn0oKSk7XG5leHBvcnQgeyBHdW56aXAgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBHWklQIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jR3VuemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXN5bmNocm9ub3VzIEdVTlpJUCBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWZsYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jR3VuemlwKGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJJbmZsdCxcbiAgICAgICAgICAgIGd1emUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIEluZmxhdGUsIEd1bnppcF07IH1cbiAgICAgICAgXSwgdGhpcywgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgR3VuemlwKCk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgOSk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0d1bnppcDtcbn0oKSk7XG5leHBvcnQgeyBBc3luY0d1bnppcCB9O1xuZXhwb3J0IGZ1bmN0aW9uIGd1bnppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiSW5mbHQsXG4gICAgICAgIGd1emUsXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtndW56aXBTeW5jXTsgfVxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKGd1bnppcFN5bmMoZXYuZGF0YVswXSkpOyB9LCAzLCBjYik7XG59XG4vKipcbiAqIEV4cGFuZHMgR1pJUCBkYXRhXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3V0IFdoZXJlIHRvIHdyaXRlIHRoZSBkYXRhLiBHWklQIGFscmVhZHkgZW5jb2RlcyB0aGUgb3V0cHV0IHNpemUsIHNvIHByb3ZpZGluZyB0aGlzIGRvZXNuJ3Qgc2F2ZSBtZW1vcnkuXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGd1bnppcFN5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIGluZmx0KGRhdGEuc3ViYXJyYXkoZ3pzKGRhdGEpLCAtOCksIG91dCB8fCBuZXcgdTgoZ3psKGRhdGEpKSk7XG59XG4vKipcbiAqIFN0cmVhbWluZyBabGliIGNvbXByZXNzaW9uXG4gKi9cbnZhciBabGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFpsaWIob3B0cywgY2IpIHtcbiAgICAgICAgdGhpcy5jID0gYWRsZXIoKTtcbiAgICAgICAgdGhpcy52ID0gMTtcbiAgICAgICAgRGVmbGF0ZS5jYWxsKHRoaXMsIG9wdHMsIGNiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgemxpYmJlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBabGliLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIFpsaWIucHJvdG90eXBlLnAgPSBmdW5jdGlvbiAoYywgZikge1xuICAgICAgICB0aGlzLmMucChjKTtcbiAgICAgICAgdmFyIHJhdyA9IGRvcHQoYywgdGhpcy5vLCB0aGlzLnYgJiYgMiwgZiAmJiA0LCAhZik7XG4gICAgICAgIGlmICh0aGlzLnYpXG4gICAgICAgICAgICB6bGgocmF3LCB0aGlzLm8pLCB0aGlzLnYgPSAwO1xuICAgICAgICBpZiAoZilcbiAgICAgICAgICAgIHdieXRlcyhyYXcsIHJhdy5sZW5ndGggLSA0LCB0aGlzLmMuZCgpKTtcbiAgICAgICAgdGhpcy5vbmRhdGEocmF3LCBmKTtcbiAgICB9O1xuICAgIHJldHVybiBabGliO1xufSgpKTtcbmV4cG9ydCB7IFpsaWIgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBabGliIGNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY1psaWIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNabGliKG9wdHMsIGNiKSB7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJEZmx0LFxuICAgICAgICAgICAgemxlLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBEZWZsYXRlLCBabGliXTsgfVxuICAgICAgICBdLCB0aGlzLCBBc3luY0NtcFN0cm0uY2FsbCh0aGlzLCBvcHRzLCBjYiksIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgWmxpYihldi5kYXRhKTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCAxMCk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY1psaWI7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNabGliIH07XG5leHBvcnQgZnVuY3Rpb24gemxpYihkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiRGZsdCxcbiAgICAgICAgemxlLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbemxpYlN5bmNdOyB9XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoemxpYlN5bmMoZXYuZGF0YVswXSwgZXYuZGF0YVsxXSkpOyB9LCA0LCBjYik7XG59XG4vKipcbiAqIENvbXByZXNzIGRhdGEgd2l0aCBabGliXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBjb21wcmVzc1xuICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSB6bGliLWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gemxpYlN5bmMoZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cylcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIHZhciBhID0gYWRsZXIoKTtcbiAgICBhLnAoZGF0YSk7XG4gICAgdmFyIGQgPSBkb3B0KGRhdGEsIG9wdHMsIDIsIDQpO1xuICAgIHJldHVybiB6bGgoZCwgb3B0cyksIHdieXRlcyhkLCBkLmxlbmd0aCAtIDQsIGEuZCgpKSwgZDtcbn1cbi8qKlxuICogU3RyZWFtaW5nIFpsaWIgZGVjb21wcmVzc2lvblxuICovXG52YXIgVW56bGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBabGliIGRlY29tcHJlc3Npb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgaW5mbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVbnpsaWIoY2IpIHtcbiAgICAgICAgdGhpcy52ID0gMTtcbiAgICAgICAgSW5mbGF0ZS5jYWxsKHRoaXMsIGNiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgdW56bGliYmVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFVuemxpYi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgSW5mbGF0ZS5wcm90b3R5cGUuZS5jYWxsKHRoaXMsIGNodW5rKTtcbiAgICAgICAgaWYgKHRoaXMudikge1xuICAgICAgICAgICAgaWYgKHRoaXMucC5sZW5ndGggPCAyICYmICFmaW5hbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnAgPSB0aGlzLnAuc3ViYXJyYXkoMiksIHRoaXMudiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wLmxlbmd0aCA8IDQpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgemxpYiBzdHJlYW0nO1xuICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5wLnN1YmFycmF5KDAsIC00KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWNlc3NhcnkgdG8gcHJldmVudCBUUyBmcm9tIHVzaW5nIHRoZSBjbG9zdXJlIHZhbHVlXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIGZvciB3b3JrZXJpemF0aW9uIHRvIGZ1bmN0aW9uIGNvcnJlY3RseVxuICAgICAgICBJbmZsYXRlLnByb3RvdHlwZS5jLmNhbGwodGhpcywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFVuemxpYjtcbn0oKSk7XG5leHBvcnQgeyBVbnpsaWIgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBabGliIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jVW56bGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXN5bmNocm9ub3VzIFpsaWIgZGVjb21wcmVzc2lvbiBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWZsYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jVW56bGliKGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJJbmZsdCxcbiAgICAgICAgICAgIHp1bGUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIEluZmxhdGUsIFVuemxpYl07IH1cbiAgICAgICAgXSwgdGhpcywgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgVW56bGliKCk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgMTEpO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNVbnpsaWI7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNVbnpsaWIgfTtcbmV4cG9ydCBmdW5jdGlvbiB1bnpsaWIoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkluZmx0LFxuICAgICAgICB6dWxlLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbdW56bGliU3luY107IH1cbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZih1bnpsaWJTeW5jKGV2LmRhdGFbMF0sIGd1OChldi5kYXRhWzFdKSkpOyB9LCA1LCBjYik7XG59XG4vKipcbiAqIEV4cGFuZHMgWmxpYiBkYXRhXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3V0IFdoZXJlIHRvIHdyaXRlIHRoZSBkYXRhLiBTYXZlcyBtZW1vcnkgaWYgeW91IGtub3cgdGhlIGRlY29tcHJlc3NlZCBzaXplIGFuZCBwcm92aWRlIGFuIG91dHB1dCBidWZmZXIgb2YgdGhhdCBsZW5ndGguXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuemxpYlN5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIGluZmx0KCh6bHYoZGF0YSksIGRhdGEuc3ViYXJyYXkoMiwgLTQpKSwgb3V0KTtcbn1cbi8vIERlZmF1bHQgYWxnb3JpdGhtIGZvciBjb21wcmVzc2lvbiAodXNlZCBiZWNhdXNlIGhhdmluZyBhIGtub3duIG91dHB1dCBzaXplIGFsbG93cyBmYXN0ZXIgZGVjb21wcmVzc2lvbilcbmV4cG9ydCB7IGd6aXAgYXMgY29tcHJlc3MsIEFzeW5jR3ppcCBhcyBBc3luY0NvbXByZXNzIH07XG4vLyBEZWZhdWx0IGFsZ29yaXRobSBmb3IgY29tcHJlc3Npb24gKHVzZWQgYmVjYXVzZSBoYXZpbmcgYSBrbm93biBvdXRwdXQgc2l6ZSBhbGxvd3MgZmFzdGVyIGRlY29tcHJlc3Npb24pXG5leHBvcnQgeyBnemlwU3luYyBhcyBjb21wcmVzc1N5bmMsIEd6aXAgYXMgQ29tcHJlc3MgfTtcbi8qKlxuICogU3RyZWFtaW5nIEdaSVAsIFpsaWIsIG9yIHJhdyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIERlY29tcHJlc3MgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlY29tcHJlc3Npb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVjb21wcmVzc2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVjb21wcmVzcyhjYikge1xuICAgICAgICB0aGlzLkcgPSBHdW56aXA7XG4gICAgICAgIHRoaXMuSSA9IEluZmxhdGU7XG4gICAgICAgIHRoaXMuWiA9IFVuemxpYjtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVjb21wcmVzc2VkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIERlY29tcHJlc3MucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gc3RyZWFtIGhhbmRsZXInO1xuICAgICAgICBpZiAoIXRoaXMucykge1xuICAgICAgICAgICAgaWYgKHRoaXMucCAmJiB0aGlzLnAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBuZXcgdTgodGhpcy5wLmxlbmd0aCArIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbi5zZXQodGhpcy5wKSwgbi5zZXQoY2h1bmssIHRoaXMucC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucCA9IGNodW5rO1xuICAgICAgICAgICAgaWYgKHRoaXMucC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjYiA9IGZ1bmN0aW9uICgpIHsgX3RoaXNfMS5vbmRhdGEuYXBwbHkoX3RoaXNfMSwgYXJndW1lbnRzKTsgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnMgPSAodGhpcy5wWzBdID09IDMxICYmIHRoaXMucFsxXSA9PSAxMzkgJiYgdGhpcy5wWzJdID09IDgpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IHRoaXMuRyhjYilcbiAgICAgICAgICAgICAgICAgICAgOiAoKHRoaXMucFswXSAmIDE1KSAhPSA4IHx8ICh0aGlzLnBbMF0gPj4gNCkgPiA3IHx8ICgodGhpcy5wWzBdIDw8IDggfCB0aGlzLnBbMV0pICUgMzEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgdGhpcy5JKGNiKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgdGhpcy5aKGNiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnMucHVzaCh0aGlzLnAsIGZpbmFsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucy5wdXNoKGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVjb21wcmVzcztcbn0oKSk7XG5leHBvcnQgeyBEZWNvbXByZXNzIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgR1pJUCwgWmxpYiwgb3IgcmF3IERFRkxBVEUgZGVjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNEZWNvbXByZXNzID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFzeW5jaHJvbm91cyBkZWNvbXByZXNzaW9uIHN0cmVhbVxuICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWNvbXByZXNzZWRcbiAgICovXG4gICAgZnVuY3Rpb24gQXN5bmNEZWNvbXByZXNzKGNiKSB7XG4gICAgICAgIHRoaXMuRyA9IEFzeW5jR3VuemlwO1xuICAgICAgICB0aGlzLkkgPSBBc3luY0luZmxhdGU7XG4gICAgICAgIHRoaXMuWiA9IEFzeW5jVW56bGliO1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWNvbXByZXNzZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgQXN5bmNEZWNvbXByZXNzLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBEZWNvbXByZXNzLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBBc3luY0RlY29tcHJlc3M7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNEZWNvbXByZXNzIH07XG5leHBvcnQgZnVuY3Rpb24gZGVjb21wcmVzcyhkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gKGRhdGFbMF0gPT0gMzEgJiYgZGF0YVsxXSA9PSAxMzkgJiYgZGF0YVsyXSA9PSA4KVxuICAgICAgICA/IGd1bnppcChkYXRhLCBvcHRzLCBjYilcbiAgICAgICAgOiAoKGRhdGFbMF0gJiAxNSkgIT0gOCB8fCAoZGF0YVswXSA+PiA0KSA+IDcgfHwgKChkYXRhWzBdIDw8IDggfCBkYXRhWzFdKSAlIDMxKSlcbiAgICAgICAgICAgID8gaW5mbGF0ZShkYXRhLCBvcHRzLCBjYilcbiAgICAgICAgICAgIDogdW56bGliKGRhdGEsIG9wdHMsIGNiKTtcbn1cbi8qKlxuICogRXhwYW5kcyBjb21wcmVzc2VkIEdaSVAsIFpsaWIsIG9yIHJhdyBERUZMQVRFIGRhdGEsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0aW5nIHRoZSBmb3JtYXRcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29tcHJlc3NcbiAqIEBwYXJhbSBvdXQgV2hlcmUgdG8gd3JpdGUgdGhlIGRhdGEuIFNhdmVzIG1lbW9yeSBpZiB5b3Uga25vdyB0aGUgZGVjb21wcmVzc2VkIHNpemUgYW5kIHByb3ZpZGUgYW4gb3V0cHV0IGJ1ZmZlciBvZiB0aGF0IGxlbmd0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb21wcmVzc1N5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIChkYXRhWzBdID09IDMxICYmIGRhdGFbMV0gPT0gMTM5ICYmIGRhdGFbMl0gPT0gOClcbiAgICAgICAgPyBndW56aXBTeW5jKGRhdGEsIG91dClcbiAgICAgICAgOiAoKGRhdGFbMF0gJiAxNSkgIT0gOCB8fCAoZGF0YVswXSA+PiA0KSA+IDcgfHwgKChkYXRhWzBdIDw8IDggfCBkYXRhWzFdKSAlIDMxKSlcbiAgICAgICAgICAgID8gaW5mbGF0ZVN5bmMoZGF0YSwgb3V0KVxuICAgICAgICAgICAgOiB1bnpsaWJTeW5jKGRhdGEsIG91dCk7XG59XG4vLyBmbGF0dGVuIGEgZGlyZWN0b3J5IHN0cnVjdHVyZVxudmFyIGZsdG4gPSBmdW5jdGlvbiAoZCwgcCwgdCwgbykge1xuICAgIGZvciAodmFyIGsgaW4gZCkge1xuICAgICAgICB2YXIgdmFsID0gZFtrXSwgbiA9IHAgKyBrO1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgdTgpXG4gICAgICAgICAgICB0W25dID0gW3ZhbCwgb107XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSlcbiAgICAgICAgICAgIHRbbl0gPSBbdmFsWzBdLCBtcmcobywgdmFsWzFdKV07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZsdG4odmFsLCBuICsgJy8nLCB0LCBvKTtcbiAgICB9XG59O1xuLy8gdGV4dCBlbmNvZGVyXG52YXIgdGUgPSB0eXBlb2YgVGV4dEVuY29kZXIgIT0gJ3VuZGVmaW5lZCcgJiYgLyojX19QVVJFX18qLyBuZXcgVGV4dEVuY29kZXIoKTtcbi8vIHRleHQgZGVjb2RlclxudmFyIHRkID0gdHlwZW9mIFRleHREZWNvZGVyICE9ICd1bmRlZmluZWQnICYmIC8qI19fUFVSRV9fKi8gbmV3IFRleHREZWNvZGVyKCk7XG4vLyB0ZXh0IGRlY29kZXIgc3RyZWFtXG52YXIgdGRzID0gMDtcbnRyeSB7XG4gICAgdGQuZGVjb2RlKGV0LCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICB0ZHMgPSAxO1xufVxuY2F0Y2ggKGUpIHsgfVxuLy8gZGVjb2RlIFVURjhcbnZhciBkdXRmOCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgZm9yICh2YXIgciA9ICcnLCBpID0gMDs7KSB7XG4gICAgICAgIHZhciBjID0gZFtpKytdO1xuICAgICAgICB2YXIgZWIgPSAoYyA+IDEyNykgKyAoYyA+IDIyMykgKyAoYyA+IDIzOSk7XG4gICAgICAgIGlmIChpICsgZWIgPiBkLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBbciwgc2xjKGQsIGkgLSAxKV07XG4gICAgICAgIGlmICghZWIpXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIGVsc2UgaWYgKGViID09IDMpIHtcbiAgICAgICAgICAgIGMgPSAoKGMgJiAxNSkgPDwgMTggfCAoZFtpKytdICYgNjMpIDw8IDEyIHwgKGRbaSsrXSAmIDYzKSA8PCA2IHwgKGRbaSsrXSAmIDYzKSkgLSA2NTUzNixcbiAgICAgICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgfCAoYyA+PiAxMCksIDU2MzIwIHwgKGMgJiAxMDIzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWIgJiAxKVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMzEpIDw8IDYgfCAoZFtpKytdICYgNjMpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMTUpIDw8IDEyIHwgKGRbaSsrXSAmIDYzKSA8PCA2IHwgKGRbaSsrXSAmIDYzKSk7XG4gICAgfVxufTtcbi8qKlxuICogU3RyZWFtaW5nIFVURi04IGRlY29kaW5nXG4gKi9cbnZhciBEZWNvZGVVVEY4ID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBVVEYtOCBkZWNvZGluZyBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWNvZGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVjb2RlVVRGOChjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICBpZiAodGRzKVxuICAgICAgICAgICAgdGhpcy50ID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucCA9IGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWNvZGVkIGZyb20gVVRGLTggYmluYXJ5XG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIERlY29kZVVURjgucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgICAgICBmaW5hbCA9ICEhZmluYWw7XG4gICAgICAgIGlmICh0aGlzLnQpIHtcbiAgICAgICAgICAgIHRoaXMub25kYXRhKHRoaXMudC5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pLCBmaW5hbCk7XG4gICAgICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50LmRlY29kZSgpLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgdXRmLTggZGF0YSc7XG4gICAgICAgICAgICAgICAgdGhpcy50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucClcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICB2YXIgZGF0ID0gbmV3IHU4KHRoaXMucC5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICBkYXQuc2V0KHRoaXMucCk7XG4gICAgICAgIGRhdC5zZXQoY2h1bmssIHRoaXMucC5sZW5ndGgpO1xuICAgICAgICB2YXIgX2EgPSBkdXRmOChkYXQpLCBjaCA9IF9hWzBdLCBucCA9IF9hWzFdO1xuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIGlmIChucC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgdXRmLTggZGF0YSc7XG4gICAgICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucCA9IG5wO1xuICAgICAgICB0aGlzLm9uZGF0YShjaCwgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIERlY29kZVVURjg7XG59KCkpO1xuZXhwb3J0IHsgRGVjb2RlVVRGOCB9O1xuLyoqXG4gKiBTdHJlYW1pbmcgVVRGLTggZW5jb2RpbmdcbiAqL1xudmFyIEVuY29kZVVURjggPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFVURi04IGRlY29kaW5nIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGVuY29kZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbmNvZGVVVEY4KGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGVuY29kZWQgdG8gVVRGLThcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIHN0cmluZyBkYXRhIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgRW5jb2RlVVRGOC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgdGhpcy5vbmRhdGEoc3RyVG9VOChjaHVuayksIHRoaXMuZCA9IGZpbmFsIHx8IGZhbHNlKTtcbiAgICB9O1xuICAgIHJldHVybiBFbmNvZGVVVEY4O1xufSgpKTtcbmV4cG9ydCB7IEVuY29kZVVURjggfTtcbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIFVpbnQ4QXJyYXkgZm9yIHVzZSB3aXRoIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gbWV0aG9kc1xuICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIGVuY29kZVxuICogQHBhcmFtIGxhdGluMSBXaGV0aGVyIG9yIG5vdCB0byBpbnRlcnByZXQgdGhlIGRhdGEgYXMgTGF0aW4tMS4gVGhpcyBzaG91bGRcbiAqICAgICAgICAgICAgICAgbm90IG5lZWQgdG8gYmUgdHJ1ZSB1bmxlc3MgZGVjb2RpbmcgYSBiaW5hcnkgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHN0cmluZyBlbmNvZGVkIGluIFVURi04L0xhdGluLTEgYmluYXJ5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJUb1U4KHN0ciwgbGF0aW4xKSB7XG4gICAgaWYgKGxhdGluMSkge1xuICAgICAgICB2YXIgYXJfMSA9IG5ldyB1OChzdHIubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBhcl8xW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHJldHVybiBhcl8xO1xuICAgIH1cbiAgICBpZiAodGUpXG4gICAgICAgIHJldHVybiB0ZS5lbmNvZGUoc3RyKTtcbiAgICB2YXIgbCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIGFyID0gbmV3IHU4KHN0ci5sZW5ndGggKyAoc3RyLmxlbmd0aCA+PiAxKSk7XG4gICAgdmFyIGFpID0gMDtcbiAgICB2YXIgdyA9IGZ1bmN0aW9uICh2KSB7IGFyW2FpKytdID0gdjsgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICBpZiAoYWkgKyA1ID4gYXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbiA9IG5ldyB1OChhaSArIDggKyAoKGwgLSBpKSA8PCAxKSk7XG4gICAgICAgICAgICBuLnNldChhcik7XG4gICAgICAgICAgICBhciA9IG47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjggfHwgbGF0aW4xKVxuICAgICAgICAgICAgdyhjKTtcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpXG4gICAgICAgICAgICB3KDE5MiB8IChjID4+IDYpKSwgdygxMjggfCAoYyAmIDYzKSk7XG4gICAgICAgIGVsc2UgaWYgKGMgPiA1NTI5NSAmJiBjIDwgNTczNDQpXG4gICAgICAgICAgICBjID0gNjU1MzYgKyAoYyAmIDEwMjMgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAxMDIzKSxcbiAgICAgICAgICAgICAgICB3KDI0MCB8IChjID4+IDE4KSksIHcoMTI4IHwgKChjID4+IDEyKSAmIDYzKSksIHcoMTI4IHwgKChjID4+IDYpICYgNjMpKSwgdygxMjggfCAoYyAmIDYzKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHcoMjI0IHwgKGMgPj4gMTIpKSwgdygxMjggfCAoKGMgPj4gNikgJiA2MykpLCB3KDEyOCB8IChjICYgNjMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNsYyhhciwgMCwgYWkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFVpbnQ4QXJyYXkgdG8gYSBzdHJpbmdcbiAqIEBwYXJhbSBkYXQgVGhlIGRhdGEgdG8gZGVjb2RlIHRvIHN0cmluZ1xuICogQHBhcmFtIGxhdGluMSBXaGV0aGVyIG9yIG5vdCB0byBpbnRlcnByZXQgdGhlIGRhdGEgYXMgTGF0aW4tMS4gVGhpcyBzaG91bGRcbiAqICAgICAgICAgICAgICAgbm90IG5lZWQgdG8gYmUgdHJ1ZSB1bmxlc3MgZW5jb2RpbmcgdG8gYmluYXJ5IHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBvcmlnaW5hbCBVVEYtOC9MYXRpbi0xIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyRnJvbVU4KGRhdCwgbGF0aW4xKSB7XG4gICAgaWYgKGxhdGluMSkge1xuICAgICAgICB2YXIgciA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdC5sZW5ndGg7IGkgKz0gMTYzODQpXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0LnN1YmFycmF5KGksIGkgKyAxNjM4NCkpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZWxzZSBpZiAodGQpXG4gICAgICAgIHJldHVybiB0ZC5kZWNvZGUoZGF0KTtcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIF9hID0gZHV0ZjgoZGF0KSwgb3V0ID0gX2FbMF0sIGV4dCA9IF9hWzFdO1xuICAgICAgICBpZiAoZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIHV0Zi04IGRhdGEnO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbn1cbjtcbi8vIGRlZmxhdGUgYml0IGZsYWdcbnZhciBkYmYgPSBmdW5jdGlvbiAobCkgeyByZXR1cm4gbCA9PSAxID8gMyA6IGwgPCA2ID8gMiA6IGwgPT0gOSA/IDEgOiAwOyB9O1xuLy8gc2tpcCBsb2NhbCB6aXAgaGVhZGVyXG52YXIgc2x6aCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiBiICsgMzAgKyBiMihkLCBiICsgMjYpICsgYjIoZCwgYiArIDI4KTsgfTtcbi8vIHJlYWQgemlwIGhlYWRlclxudmFyIHpoID0gZnVuY3Rpb24gKGQsIGIsIHopIHtcbiAgICB2YXIgZm5sID0gYjIoZCwgYiArIDI4KSwgZm4gPSBzdHJGcm9tVTgoZC5zdWJhcnJheShiICsgNDYsIGIgKyA0NiArIGZubCksICEoYjIoZCwgYiArIDgpICYgMjA0OCkpLCBlcyA9IGIgKyA0NiArIGZubCwgYnMgPSBiNChkLCBiICsgMjApO1xuICAgIHZhciBfYSA9IHogJiYgYnMgPT0gNDI5NDk2NzI5NSA/IHo2NGUoZCwgZXMpIDogW2JzLCBiNChkLCBiICsgMjQpLCBiNChkLCBiICsgNDIpXSwgc2MgPSBfYVswXSwgc3UgPSBfYVsxXSwgb2ZmID0gX2FbMl07XG4gICAgcmV0dXJuIFtiMihkLCBiICsgMTApLCBzYywgc3UsIGZuLCBlcyArIGIyKGQsIGIgKyAzMCkgKyBiMihkLCBiICsgMzIpLCBvZmZdO1xufTtcbi8vIHJlYWQgemlwNjQgZXh0cmEgZmllbGRcbnZhciB6NjRlID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKDsgYjIoZCwgYikgIT0gMTsgYiArPSA0ICsgYjIoZCwgYiArIDIpKVxuICAgICAgICA7XG4gICAgcmV0dXJuIFtiOChkLCBiICsgMTIpLCBiOChkLCBiICsgNCksIGI4KGQsIGIgKyAyMCldO1xufTtcbi8vIGV4dHJhIGZpZWxkIGxlbmd0aFxudmFyIGV4ZmwgPSBmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgbGUgPSAwO1xuICAgIGlmIChleCkge1xuICAgICAgICBmb3IgKHZhciBrIGluIGV4KSB7XG4gICAgICAgICAgICB2YXIgbCA9IGV4W2tdLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsID4gNjU1MzUpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2V4dHJhIGZpZWxkIHRvbyBsb25nJztcbiAgICAgICAgICAgIGxlICs9IGwgKyA0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZTtcbn07XG4vLyB3cml0ZSB6aXAgaGVhZGVyXG52YXIgd3poID0gZnVuY3Rpb24gKGQsIGIsIGYsIGZuLCB1LCBjLCBjZSwgY28pIHtcbiAgICB2YXIgZmwgPSBmbi5sZW5ndGgsIGV4ID0gZi5leHRyYSwgY29sID0gY28gJiYgY28ubGVuZ3RoO1xuICAgIHZhciBleGwgPSBleGZsKGV4KTtcbiAgICB3Ynl0ZXMoZCwgYiwgY2UgIT0gbnVsbCA/IDB4MjAxNEI1MCA6IDB4NDAzNEI1MCksIGIgKz0gNDtcbiAgICBpZiAoY2UgIT0gbnVsbClcbiAgICAgICAgZFtiKytdID0gMjAsIGRbYisrXSA9IGYub3M7XG4gICAgZFtiXSA9IDIwLCBiICs9IDI7IC8vIHNwZWMgY29tcGxpYW5jZT8gd2hhdCdzIHRoYXQ/XG4gICAgZFtiKytdID0gKGYuZmxhZyA8PCAxKSB8IChjID09IG51bGwgJiYgOCksIGRbYisrXSA9IHUgJiYgODtcbiAgICBkW2IrK10gPSBmLmNvbXByZXNzaW9uICYgMjU1LCBkW2IrK10gPSBmLmNvbXByZXNzaW9uID4+IDg7XG4gICAgdmFyIGR0ID0gbmV3IERhdGUoZi5tdGltZSA9PSBudWxsID8gRGF0ZS5ub3coKSA6IGYubXRpbWUpLCB5ID0gZHQuZ2V0RnVsbFllYXIoKSAtIDE5ODA7XG4gICAgaWYgKHkgPCAwIHx8IHkgPiAxMTkpXG4gICAgICAgIHRocm93ICdkYXRlIG5vdCBpbiByYW5nZSAxOTgwLTIwOTknO1xuICAgIHdieXRlcyhkLCBiLCAoeSA8PCAyNSkgfCAoKGR0LmdldE1vbnRoKCkgKyAxKSA8PCAyMSkgfCAoZHQuZ2V0RGF0ZSgpIDw8IDE2KSB8IChkdC5nZXRIb3VycygpIDw8IDExKSB8IChkdC5nZXRNaW51dGVzKCkgPDwgNSkgfCAoZHQuZ2V0U2Vjb25kcygpID4+PiAxKSksIGIgKz0gNDtcbiAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgIHdieXRlcyhkLCBiLCBmLmNyYyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgNCwgYyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgOCwgZi5zaXplKTtcbiAgICB9XG4gICAgd2J5dGVzKGQsIGIgKyAxMiwgZmwpO1xuICAgIHdieXRlcyhkLCBiICsgMTQsIGV4bCksIGIgKz0gMTY7XG4gICAgaWYgKGNlICE9IG51bGwpIHtcbiAgICAgICAgd2J5dGVzKGQsIGIsIGNvbCk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgNiwgZi5hdHRycyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgMTAsIGNlKSwgYiArPSAxNDtcbiAgICB9XG4gICAgZC5zZXQoZm4sIGIpO1xuICAgIGIgKz0gZmw7XG4gICAgaWYgKGV4bCkge1xuICAgICAgICBmb3IgKHZhciBrIGluIGV4KSB7XG4gICAgICAgICAgICB2YXIgZXhmID0gZXhba10sIGwgPSBleGYubGVuZ3RoO1xuICAgICAgICAgICAgd2J5dGVzKGQsIGIsICtrKTtcbiAgICAgICAgICAgIHdieXRlcyhkLCBiICsgMiwgbCk7XG4gICAgICAgICAgICBkLnNldChleGYsIGIgKyA0KSwgYiArPSA0ICsgbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sKVxuICAgICAgICBkLnNldChjbywgYiksIGIgKz0gY29sO1xuICAgIHJldHVybiBiO1xufTtcbi8vIHdyaXRlIHppcCBmb290ZXIgKGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSlcbnZhciB3emYgPSBmdW5jdGlvbiAobywgYiwgYywgZCwgZSkge1xuICAgIHdieXRlcyhvLCBiLCAweDYwNTRCNTApOyAvLyBza2lwIGRpc2tcbiAgICB3Ynl0ZXMobywgYiArIDgsIGMpO1xuICAgIHdieXRlcyhvLCBiICsgMTAsIGMpO1xuICAgIHdieXRlcyhvLCBiICsgMTIsIGQpO1xuICAgIHdieXRlcyhvLCBiICsgMTYsIGUpO1xufTtcbi8qKlxuICogQSBwYXNzLXRocm91Z2ggc3RyZWFtIHRvIGtlZXAgZGF0YSB1bmNvbXByZXNzZWQgaW4gYSBaSVAgYXJjaGl2ZS5cbiAqL1xudmFyIFppcFBhc3NUaHJvdWdoID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwYXNzLXRocm91Z2ggc3RyZWFtIHRoYXQgY2FuIGJlIGFkZGVkIHRvIFpJUCBhcmNoaXZlc1xuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBUaGUgZmlsZW5hbWUgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBkYXRhIHN0cmVhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFppcFBhc3NUaHJvdWdoKGZpbGVuYW1lKSB7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgdGhpcy5jID0gY3JjKCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgYSBjaHVuayBhbmQgcHVzaGVzIHRvIHRoZSBvdXRwdXQgc3RyZWFtLiBZb3UgY2FuIG92ZXJyaWRlIHRoaXNcbiAgICAgKiBtZXRob2QgaW4gYSBzdWJjbGFzcyBmb3IgY3VzdG9tIGJlaGF2aW9yLCBidXQgYnkgZGVmYXVsdCB0aGlzIHBhc3Nlc1xuICAgICAqIHRoZSBkYXRhIHRocm91Z2guIFlvdSBtdXN0IGNhbGwgdGhpcy5vbmRhdGEoZXJyLCBjaHVuaywgZmluYWwpIGF0IHNvbWVcbiAgICAgKiBwb2ludCBpbiB0aGlzIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHByb2Nlc3NcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmlwUGFzc1Rocm91Z2gucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRoaXMub25kYXRhKG51bGwsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBhZGRlZC4gSWYgeW91IGFyZSBzdWJjbGFzc2luZyB0aGlzIHdpdGggYSBjdXN0b21cbiAgICAgKiBjb21wcmVzc2lvbiBhbGdvcml0aG0sIG5vdGUgdGhhdCB5b3UgbXVzdCBwdXNoIGRhdGEgZnJvbSB0aGUgc291cmNlXG4gICAgICogZmlsZSBvbmx5LCBwcmUtY29tcHJlc3Npb24uXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrIC0gYWRkIHRvIFpJUCBhcmNoaXZlIGJlZm9yZSBwdXNoaW5nJztcbiAgICAgICAgdGhpcy5jLnAoY2h1bmspO1xuICAgICAgICB0aGlzLnNpemUgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBpZiAoZmluYWwpXG4gICAgICAgICAgICB0aGlzLmNyYyA9IHRoaXMuYy5kKCk7XG4gICAgICAgIHRoaXMucHJvY2VzcyhjaHVuaywgZmluYWwgfHwgZmFsc2UpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcFBhc3NUaHJvdWdoO1xufSgpKTtcbmV4cG9ydCB7IFppcFBhc3NUaHJvdWdoIH07XG4vLyBJIGRvbid0IGV4dGVuZCBiZWNhdXNlIFR5cGVTY3JpcHQgZXh0ZW5zaW9uIGFkZHMgMWtCIG9mIHJ1bnRpbWUgYmxvYXRcbi8qKlxuICogU3RyZWFtaW5nIERFRkxBVEUgY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlcy4gUHJlZmVyIHVzaW5nIEFzeW5jWmlwRGVmbGF0ZVxuICogZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICovXG52YXIgWmlwRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgREVGTEFURSBzdHJlYW0gdGhhdCBjYW4gYmUgYWRkZWQgdG8gWklQIGFyY2hpdmVzXG4gICAgICogQHBhcmFtIGZpbGVuYW1lIFRoZSBmaWxlbmFtZSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGRhdGEgc3RyZWFtXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBaaXBEZWZsYXRlKGZpbGVuYW1lLCBvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgaWYgKCFvcHRzKVxuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICBaaXBQYXNzVGhyb3VnaC5jYWxsKHRoaXMsIGZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5kID0gbmV3IERlZmxhdGUob3B0cywgZnVuY3Rpb24gKGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzXzEub25kYXRhKG51bGwsIGRhdCwgZmluYWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbiA9IDg7XG4gICAgICAgIHRoaXMuZmxhZyA9IGRiZihvcHRzLmxldmVsKTtcbiAgICB9XG4gICAgWmlwRGVmbGF0ZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZC5wdXNoKGNodW5rLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25kYXRhKGUsIG51bGwsIGZpbmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVmbGF0ZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmlwRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgWmlwUGFzc1Rocm91Z2gucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcERlZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgWmlwRGVmbGF0ZSB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIERFRkxBVEUgY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlc1xuICovXG52YXIgQXN5bmNaaXBEZWZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBERUZMQVRFIHN0cmVhbSB0aGF0IGNhbiBiZSBhZGRlZCB0byBaSVAgYXJjaGl2ZXNcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgZGF0YSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jWmlwRGVmbGF0ZShmaWxlbmFtZSwgb3B0cykge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIGlmICghb3B0cylcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgWmlwUGFzc1Rocm91Z2guY2FsbCh0aGlzLCBmaWxlbmFtZSk7XG4gICAgICAgIHRoaXMuZCA9IG5ldyBBc3luY0RlZmxhdGUob3B0cywgZnVuY3Rpb24gKGVyciwgZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgX3RoaXNfMS5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSA4O1xuICAgICAgICB0aGlzLmZsYWcgPSBkYmYob3B0cy5sZXZlbCk7XG4gICAgICAgIHRoaXMudGVybWluYXRlID0gdGhpcy5kLnRlcm1pbmF0ZTtcbiAgICB9XG4gICAgQXN5bmNaaXBEZWZsYXRlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICB0aGlzLmQucHVzaChjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVmbGF0ZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgQXN5bmNaaXBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBaaXBQYXNzVGhyb3VnaC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNaaXBEZWZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jWmlwRGVmbGF0ZSB9O1xuLy8gVE9ETzogQmV0dGVyIHRyZWUgc2hha2luZ1xuLyoqXG4gKiBBIHppcHBhYmxlIGFyY2hpdmUgdG8gd2hpY2ggZmlsZXMgY2FuIGluY3JlbWVudGFsbHkgYmUgYWRkZWRcbiAqL1xudmFyIFppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVtcHR5IFpJUCBhcmNoaXZlIHRvIHdoaWNoIGZpbGVzIGNhbiBiZSBhZGRlZFxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGZvciB0aGUgZ2VuZXJhdGVkIFpJUCBhcmNoaXZlXG4gICAgICogICAgICAgICAgIGlzIGF2YWlsYWJsZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFppcChjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICB0aGlzLnUgPSBbXTtcbiAgICAgICAgdGhpcy5kID0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZpbGUgdG8gdGhlIFpJUCBhcmNoaXZlXG4gICAgICogQHBhcmFtIGZpbGUgVGhlIGZpbGUgc3RyZWFtIHRvIGFkZFxuICAgICAqL1xuICAgIFppcC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kICYgMilcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICB2YXIgZiA9IHN0clRvVTgoZmlsZS5maWxlbmFtZSksIGZsID0gZi5sZW5ndGg7XG4gICAgICAgIHZhciBjb20gPSBmaWxlLmNvbW1lbnQsIG8gPSBjb20gJiYgc3RyVG9VOChjb20pO1xuICAgICAgICB2YXIgdSA9IGZsICE9IGZpbGUuZmlsZW5hbWUubGVuZ3RoIHx8IChvICYmIChjb20ubGVuZ3RoICE9IG8ubGVuZ3RoKSk7XG4gICAgICAgIHZhciBobCA9IGZsICsgZXhmbChmaWxlLmV4dHJhKSArIDMwO1xuICAgICAgICBpZiAoZmwgPiA2NTUzNSlcbiAgICAgICAgICAgIHRocm93ICdmaWxlbmFtZSB0b28gbG9uZyc7XG4gICAgICAgIHZhciBoZWFkZXIgPSBuZXcgdTgoaGwpO1xuICAgICAgICB3emgoaGVhZGVyLCAwLCBmaWxlLCBmLCB1KTtcbiAgICAgICAgdmFyIGNoa3MgPSBbaGVhZGVyXTtcbiAgICAgICAgdmFyIHBBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNoa3NfMSA9IGNoa3M7IF9pIDwgY2hrc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGsgPSBjaGtzXzFbX2ldO1xuICAgICAgICAgICAgICAgIF90aGlzXzEub25kYXRhKG51bGwsIGNoaywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hrcyA9IFtdO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdHIgPSB0aGlzLmQ7XG4gICAgICAgIHRoaXMuZCA9IDA7XG4gICAgICAgIHZhciBpbmQgPSB0aGlzLnUubGVuZ3RoO1xuICAgICAgICB2YXIgdWYgPSBtcmcoZmlsZSwge1xuICAgICAgICAgICAgZjogZixcbiAgICAgICAgICAgIHU6IHUsXG4gICAgICAgICAgICBvOiBvLFxuICAgICAgICAgICAgdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlLnRlcm1pbmF0ZSlcbiAgICAgICAgICAgICAgICAgICAgZmlsZS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcEFsbCgpO1xuICAgICAgICAgICAgICAgIGlmICh0cikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnh0ID0gX3RoaXNfMS51W2luZCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobnh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgbnh0LnIoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXNfMS5kID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHIgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNsID0gMDtcbiAgICAgICAgZmlsZS5vbmRhdGEgPSBmdW5jdGlvbiAoZXJyLCBkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXNfMS5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgICAgICAgICBfdGhpc18xLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2wgKz0gZGF0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjaGtzLnB1c2goZGF0KTtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRkID0gbmV3IHU4KDE2KTtcbiAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCAwLCAweDgwNzRCNTApO1xuICAgICAgICAgICAgICAgICAgICB3Ynl0ZXMoZGQsIDQsIGZpbGUuY3JjKTtcbiAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCA4LCBjbCk7XG4gICAgICAgICAgICAgICAgICAgIHdieXRlcyhkZCwgMTIsIGZpbGUuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNoa3MucHVzaChkZCk7XG4gICAgICAgICAgICAgICAgICAgIHVmLmMgPSBjbCwgdWYuYiA9IGhsICsgY2wgKyAxNiwgdWYuY3JjID0gZmlsZS5jcmMsIHVmLnNpemUgPSBmaWxlLnNpemU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cilcbiAgICAgICAgICAgICAgICAgICAgICAgIHVmLnIoKTtcbiAgICAgICAgICAgICAgICAgICAgdHIgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0cilcbiAgICAgICAgICAgICAgICAgICAgcEFsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnUucHVzaCh1Zik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbmRzIHRoZSBwcm9jZXNzIG9mIGFkZGluZyBmaWxlcyBhbmQgcHJlcGFyZXMgdG8gZW1pdCB0aGUgZmluYWwgY2h1bmtzLlxuICAgICAqIFRoaXMgKm11c3QqIGJlIGNhbGxlZCBhZnRlciBhZGRpbmcgYWxsIGRlc2lyZWQgZmlsZXMgZm9yIHRoZSByZXN1bHRpbmdcbiAgICAgKiBaSVAgZmlsZSB0byB3b3JrIHByb3Blcmx5LlxuICAgICAqL1xuICAgIFppcC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmQgJiAyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kICYgMSlcbiAgICAgICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGluZyc7XG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgdGhpcy5lKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMudS5wdXNoKHtcbiAgICAgICAgICAgICAgICByOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKF90aGlzXzEuZCAmIDEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBfdGhpc18xLnUuc3BsaWNlKC0xLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNfMS5lKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0OiBmdW5jdGlvbiAoKSB7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLmQgPSAzO1xuICAgIH07XG4gICAgWmlwLnByb3RvdHlwZS5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnQgPSAwLCBsID0gMCwgdGwgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy51OyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGYgPSBfYVtfaV07XG4gICAgICAgICAgICB0bCArPSA0NiArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpICsgKGYubyA/IGYuby5sZW5ndGggOiAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gbmV3IHU4KHRsICsgMjIpO1xuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGhpcy51OyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgdmFyIGYgPSBfY1tfYl07XG4gICAgICAgICAgICB3emgob3V0LCBidCwgZiwgZi5mLCBmLnUsIGYuYywgbCwgZi5vKTtcbiAgICAgICAgICAgIGJ0ICs9IDQ2ICsgZi5mLmxlbmd0aCArIGV4ZmwoZi5leHRyYSkgKyAoZi5vID8gZi5vLmxlbmd0aCA6IDApLCBsICs9IGYuYjtcbiAgICAgICAgfVxuICAgICAgICB3emYob3V0LCBidCwgdGhpcy51Lmxlbmd0aCwgdGwsIGwpO1xuICAgICAgICB0aGlzLm9uZGF0YShudWxsLCBvdXQsIHRydWUpO1xuICAgICAgICB0aGlzLmQgPSAyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgdG8gdGVybWluYXRlIGFueSBpbnRlcm5hbCB3b3JrZXJzIHVzZWQgYnkgdGhlIHN0cmVhbS4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIGFkZCgpIHdpbGwgZmFpbC5cbiAgICAgKi9cbiAgICBaaXAucHJvdG90eXBlLnRlcm1pbmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMudTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBmID0gX2FbX2ldO1xuICAgICAgICAgICAgZi50KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kID0gMjtcbiAgICB9O1xuICAgIHJldHVybiBaaXA7XG59KCkpO1xuZXhwb3J0IHsgWmlwIH07XG5leHBvcnQgZnVuY3Rpb24gemlwKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgIHZhciByID0ge307XG4gICAgZmx0bihkYXRhLCAnJywgciwgb3B0cyk7XG4gICAgdmFyIGsgPSBPYmplY3Qua2V5cyhyKTtcbiAgICB2YXIgbGZ0ID0gay5sZW5ndGgsIG8gPSAwLCB0b3QgPSAwO1xuICAgIHZhciBzbGZ0ID0gbGZ0LCBmaWxlcyA9IG5ldyBBcnJheShsZnQpO1xuICAgIHZhciB0ZXJtID0gW107XG4gICAgdmFyIHRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVybS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRlcm1baV0oKTtcbiAgICB9O1xuICAgIHZhciBjYmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXQgPSBuZXcgdTgodG90ICsgMjIpLCBvZSA9IG8sIGNkbCA9IHRvdCAtIG87XG4gICAgICAgIHRvdCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xmdDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZpbGVzW2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGYuYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd3poKG91dCwgdG90LCBmLCBmLmYsIGYudSwgbCk7XG4gICAgICAgICAgICAgICAgdmFyIGJhZGQgPSAzMCArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpO1xuICAgICAgICAgICAgICAgIHZhciBsb2MgPSB0b3QgKyBiYWRkO1xuICAgICAgICAgICAgICAgIG91dC5zZXQoZi5jLCBsb2MpO1xuICAgICAgICAgICAgICAgIHd6aChvdXQsIG8sIGYsIGYuZiwgZi51LCBsLCB0b3QsIGYubSksIG8gKz0gMTYgKyBiYWRkICsgKGYubSA/IGYubS5sZW5ndGggOiAwKSwgdG90ID0gbG9jICsgbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHd6ZihvdXQsIG8sIGZpbGVzLmxlbmd0aCwgY2RsLCBvZSk7XG4gICAgICAgIGNiKG51bGwsIG91dCk7XG4gICAgfTtcbiAgICBpZiAoIWxmdClcbiAgICAgICAgY2JmKCk7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgZm4gPSBrW2ldO1xuICAgICAgICB2YXIgX2EgPSByW2ZuXSwgZmlsZSA9IF9hWzBdLCBwID0gX2FbMV07XG4gICAgICAgIHZhciBjID0gY3JjKCksIHNpemUgPSBmaWxlLmxlbmd0aDtcbiAgICAgICAgYy5wKGZpbGUpO1xuICAgICAgICB2YXIgZiA9IHN0clRvVTgoZm4pLCBzID0gZi5sZW5ndGg7XG4gICAgICAgIHZhciBjb20gPSBwLmNvbW1lbnQsIG0gPSBjb20gJiYgc3RyVG9VOChjb20pLCBtcyA9IG0gJiYgbS5sZW5ndGg7XG4gICAgICAgIHZhciBleGwgPSBleGZsKHAuZXh0cmEpO1xuICAgICAgICB2YXIgY29tcHJlc3Npb24gPSBwLmxldmVsID09IDAgPyAwIDogODtcbiAgICAgICAgdmFyIGNibCA9IGZ1bmN0aW9uIChlLCBkKSB7XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgIHRBbGwoKTtcbiAgICAgICAgICAgICAgICBjYihlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsID0gZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZmlsZXNbaV0gPSBtcmcocCwge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgICAgICAgICBjcmM6IGMuZCgpLFxuICAgICAgICAgICAgICAgICAgICBjOiBkLFxuICAgICAgICAgICAgICAgICAgICBmOiBmLFxuICAgICAgICAgICAgICAgICAgICBtOiBtLFxuICAgICAgICAgICAgICAgICAgICB1OiBzICE9IGZuLmxlbmd0aCB8fCAobSAmJiAoY29tLmxlbmd0aCAhPSBtcykpLFxuICAgICAgICAgICAgICAgICAgICBjb21wcmVzc2lvbjogY29tcHJlc3Npb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvICs9IDMwICsgcyArIGV4bCArIGw7XG4gICAgICAgICAgICAgICAgdG90ICs9IDc2ICsgMiAqIChzICsgZXhsKSArIChtcyB8fCAwKSArIGw7XG4gICAgICAgICAgICAgICAgaWYgKCEtLWxmdClcbiAgICAgICAgICAgICAgICAgICAgY2JmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzID4gNjU1MzUpXG4gICAgICAgICAgICBjYmwoJ2ZpbGVuYW1lIHRvbyBsb25nJywgbnVsbCk7XG4gICAgICAgIGlmICghY29tcHJlc3Npb24pXG4gICAgICAgICAgICBjYmwobnVsbCwgZmlsZSk7XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPCAxNjAwMDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2JsKG51bGwsIGRlZmxhdGVTeW5jKGZpbGUsIHApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2JsKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRlcm0ucHVzaChkZWZsYXRlKGZpbGUsIHAsIGNibCkpO1xuICAgIH07XG4gICAgLy8gQ2Fubm90IHVzZSBsZnQgYmVjYXVzZSBpdCBjYW4gZGVjcmVhc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsZnQ7ICsraSkge1xuICAgICAgICBfbG9vcF8xKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdEFsbDtcbn1cbi8qKlxuICogU3luY2hyb25vdXNseSBjcmVhdGVzIGEgWklQIGZpbGUuIFByZWZlciB1c2luZyBgemlwYCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gKiB3aXRoIG1vcmUgdGhhbiBvbmUgZmlsZS5cbiAqIEBwYXJhbSBkYXRhIFRoZSBkaXJlY3Rvcnkgc3RydWN0dXJlIGZvciB0aGUgWklQIGFyY2hpdmVcbiAqIEBwYXJhbSBvcHRzIFRoZSBtYWluIG9wdGlvbnMsIG1lcmdlZCB3aXRoIHBlci1maWxlIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgWklQIGFyY2hpdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHppcFN5bmMoZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cylcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIHZhciByID0ge307XG4gICAgdmFyIGZpbGVzID0gW107XG4gICAgZmx0bihkYXRhLCAnJywgciwgb3B0cyk7XG4gICAgdmFyIG8gPSAwO1xuICAgIHZhciB0b3QgPSAwO1xuICAgIGZvciAodmFyIGZuIGluIHIpIHtcbiAgICAgICAgdmFyIF9hID0gcltmbl0sIGZpbGUgPSBfYVswXSwgcCA9IF9hWzFdO1xuICAgICAgICB2YXIgY29tcHJlc3Npb24gPSBwLmxldmVsID09IDAgPyAwIDogODtcbiAgICAgICAgdmFyIGYgPSBzdHJUb1U4KGZuKSwgcyA9IGYubGVuZ3RoO1xuICAgICAgICB2YXIgY29tID0gcC5jb21tZW50LCBtID0gY29tICYmIHN0clRvVTgoY29tKSwgbXMgPSBtICYmIG0ubGVuZ3RoO1xuICAgICAgICB2YXIgZXhsID0gZXhmbChwLmV4dHJhKTtcbiAgICAgICAgaWYgKHMgPiA2NTUzNSlcbiAgICAgICAgICAgIHRocm93ICdmaWxlbmFtZSB0b28gbG9uZyc7XG4gICAgICAgIHZhciBkID0gY29tcHJlc3Npb24gPyBkZWZsYXRlU3luYyhmaWxlLCBwKSA6IGZpbGUsIGwgPSBkLmxlbmd0aDtcbiAgICAgICAgdmFyIGMgPSBjcmMoKTtcbiAgICAgICAgYy5wKGZpbGUpO1xuICAgICAgICBmaWxlcy5wdXNoKG1yZyhwLCB7XG4gICAgICAgICAgICBzaXplOiBmaWxlLmxlbmd0aCxcbiAgICAgICAgICAgIGNyYzogYy5kKCksXG4gICAgICAgICAgICBjOiBkLFxuICAgICAgICAgICAgZjogZixcbiAgICAgICAgICAgIG06IG0sXG4gICAgICAgICAgICB1OiBzICE9IGZuLmxlbmd0aCB8fCAobSAmJiAoY29tLmxlbmd0aCAhPSBtcykpLFxuICAgICAgICAgICAgbzogbyxcbiAgICAgICAgICAgIGNvbXByZXNzaW9uOiBjb21wcmVzc2lvblxuICAgICAgICB9KSk7XG4gICAgICAgIG8gKz0gMzAgKyBzICsgZXhsICsgbDtcbiAgICAgICAgdG90ICs9IDc2ICsgMiAqIChzICsgZXhsKSArIChtcyB8fCAwKSArIGw7XG4gICAgfVxuICAgIHZhciBvdXQgPSBuZXcgdTgodG90ICsgMjIpLCBvZSA9IG8sIGNkbCA9IHRvdCAtIG87XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZiA9IGZpbGVzW2ldO1xuICAgICAgICB3emgob3V0LCBmLm8sIGYsIGYuZiwgZi51LCBmLmMubGVuZ3RoKTtcbiAgICAgICAgdmFyIGJhZGQgPSAzMCArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpO1xuICAgICAgICBvdXQuc2V0KGYuYywgZi5vICsgYmFkZCk7XG4gICAgICAgIHd6aChvdXQsIG8sIGYsIGYuZiwgZi51LCBmLmMubGVuZ3RoLCBmLm8sIGYubSksIG8gKz0gMTYgKyBiYWRkICsgKGYubSA/IGYubS5sZW5ndGggOiAwKTtcbiAgICB9XG4gICAgd3pmKG91dCwgbywgZmlsZXMubGVuZ3RoLCBjZGwsIG9lKTtcbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTdHJlYW1pbmcgcGFzcy10aHJvdWdoIGRlY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlc1xuICovXG52YXIgVW56aXBQYXNzVGhyb3VnaCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbnppcFBhc3NUaHJvdWdoKCkge1xuICAgIH1cbiAgICBVbnppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZpbmFsKSB7XG4gICAgICAgIHRoaXMub25kYXRhKG51bGwsIGRhdGEsIGZpbmFsKTtcbiAgICB9O1xuICAgIFVuemlwUGFzc1Rocm91Z2guY29tcHJlc3Npb24gPSAwO1xuICAgIHJldHVybiBVbnppcFBhc3NUaHJvdWdoO1xufSgpKTtcbmV4cG9ydCB7IFVuemlwUGFzc1Rocm91Z2ggfTtcbi8qKlxuICogU3RyZWFtaW5nIERFRkxBVEUgZGVjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzLiBQcmVmZXIgQXN5bmNaaXBJbmZsYXRlIGZvclxuICogYmV0dGVyIHBlcmZvcm1hbmNlLlxuICovXG52YXIgVW56aXBJbmZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBERUZMQVRFIGRlY29tcHJlc3Npb24gdGhhdCBjYW4gYmUgdXNlZCBpbiBaSVAgYXJjaGl2ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVbnppcEluZmxhdGUoKSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgdGhpcy5pID0gbmV3IEluZmxhdGUoZnVuY3Rpb24gKGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzXzEub25kYXRhKG51bGwsIGRhdCwgZmluYWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgVW56aXBJbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZpbmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmkucHVzaChkYXRhLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25kYXRhKGUsIGRhdGEsIGZpbmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVW56aXBJbmZsYXRlLmNvbXByZXNzaW9uID0gODtcbiAgICByZXR1cm4gVW56aXBJbmZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IFVuemlwSW5mbGF0ZSB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIERFRkxBVEUgZGVjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzXG4gKi9cbnZhciBBc3luY1VuemlwSW5mbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgREVGTEFURSBkZWNvbXByZXNzaW9uIHRoYXQgY2FuIGJlIHVzZWQgaW4gWklQIGFyY2hpdmVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXN5bmNVbnppcEluZmxhdGUoXywgc3opIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAoc3ogPCAzMjAwMDApIHtcbiAgICAgICAgICAgIHRoaXMuaSA9IG5ldyBJbmZsYXRlKGZ1bmN0aW9uIChkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXNfMS5vbmRhdGEobnVsbCwgZGF0LCBmaW5hbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaSA9IG5ldyBBc3luY0luZmxhdGUoZnVuY3Rpb24gKGVyciwgZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgICAgIF90aGlzXzEub25kYXRhKGVyciwgZGF0LCBmaW5hbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlID0gdGhpcy5pLnRlcm1pbmF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBc3luY1VuemlwSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmaW5hbCkge1xuICAgICAgICBpZiAodGhpcy5pLnRlcm1pbmF0ZSlcbiAgICAgICAgICAgIGRhdGEgPSBzbGMoZGF0YSwgMCk7XG4gICAgICAgIHRoaXMuaS5wdXNoKGRhdGEsIGZpbmFsKTtcbiAgICB9O1xuICAgIEFzeW5jVW56aXBJbmZsYXRlLmNvbXByZXNzaW9uID0gODtcbiAgICByZXR1cm4gQXN5bmNVbnppcEluZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNVbnppcEluZmxhdGUgfTtcbi8qKlxuICogQSBaSVAgYXJjaGl2ZSBkZWNvbXByZXNzaW9uIHN0cmVhbSB0aGF0IGVtaXRzIGZpbGVzIGFzIHRoZXkgYXJlIGRpc2NvdmVyZWRcbiAqL1xudmFyIFVuemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBaSVAgZGVjb21wcmVzc2lvbiBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgYSBmaWxlIGluIHRoZSBaSVAgYXJjaGl2ZSBpcyBmb3VuZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVuemlwKGNiKSB7XG4gICAgICAgIHRoaXMub25maWxlID0gY2I7XG4gICAgICAgIHRoaXMuayA9IFtdO1xuICAgICAgICB0aGlzLm8gPSB7XG4gICAgICAgICAgICAwOiBVbnppcFBhc3NUaHJvdWdoXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucCA9IGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSB1bnppcHBlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBVbnppcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMub25maWxlKVxuICAgICAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICAgICAgaWYgKCF0aGlzLnApXG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgaWYgKHRoaXMuYyA+IDApIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbih0aGlzLmMsIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgdG9BZGQgPSBjaHVuay5zdWJhcnJheSgwLCBsZW4pO1xuICAgICAgICAgICAgdGhpcy5jIC09IGxlbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICAgICAgdGhpcy5kLnB1c2godG9BZGQsICF0aGlzLmMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMua1swXS5wdXNoKHRvQWRkKTtcbiAgICAgICAgICAgIGNodW5rID0gY2h1bmsuc3ViYXJyYXkobGVuKTtcbiAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaChjaHVuaywgZmluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGYgPSAwLCBpID0gMCwgaXMgPSB2b2lkIDAsIGJ1ZiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICghdGhpcy5wLmxlbmd0aClcbiAgICAgICAgICAgICAgICBidWYgPSBjaHVuaztcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnVmID0gdGhpcy5wO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmID0gbmV3IHU4KHRoaXMucC5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJ1Zi5zZXQodGhpcy5wKSwgYnVmLnNldChjaHVuaywgdGhpcy5wLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbCA9IGJ1Zi5sZW5ndGgsIG9jID0gdGhpcy5jLCBhZGQgPSBvYyAmJiB0aGlzLmQ7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdmFyIHNpZyA9IGI0KGJ1ZiwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZyA9PSAweDQwMzRCNTApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IDEsIGlzID0gaTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLmQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzXzEuYyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZiA9IGIyKGJ1ZiwgaSArIDYpLCBjbXBfMSA9IGIyKGJ1ZiwgaSArIDgpLCB1ID0gYmYgJiAyMDQ4LCBkZCA9IGJmICYgOCwgZm5sID0gYjIoYnVmLCBpICsgMjYpLCBlcyA9IGIyKGJ1ZiwgaSArIDI4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwgPiBpICsgMzAgKyBmbmwgKyBlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoa3NfMiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLmsudW5zaGlmdChjaGtzXzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NfMSA9IGI0KGJ1ZiwgaSArIDE4KSwgc3VfMSA9IGI0KGJ1ZiwgaSArIDIyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbl8xID0gc3RyRnJvbVU4KGJ1Zi5zdWJhcnJheShpICsgMzAsIGkgKz0gMzAgKyBmbmwpLCAhdSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NfMSA9PSA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBkZCA/IFstMl0gOiB6NjRlKGJ1ZiwgaSksIHNjXzEgPSBfYVswXSwgc3VfMSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NfMSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5jID0gc2NfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZV8xID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZuXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Npb246IGNtcF8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsZV8xLm9uZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2NfMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfMS5vbmRhdGEobnVsbCwgZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHIgPSBfdGhpc18xLm9bY21wXzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ3Vua25vd24gY29tcHJlc3Npb24gdHlwZSAnICsgY21wXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEgPSBzY18xIDwgMCA/IG5ldyBjdHIoZm5fMSkgOiBuZXcgY3RyKGZuXzEsIHNjXzEsIHN1XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZF8xLm9uZGF0YSA9IGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHsgZmlsZV8xLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjaGtzXzMgPSBjaGtzXzI7IF9pIDwgY2hrc18zLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXQgPSBjaGtzXzNbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRfMS5wdXNoKGRhdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzXzEua1swXSA9PSBjaGtzXzIgJiYgX3RoaXNfMS5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzXzEuZCA9IGRfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEucHVzaChldCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZF8xICYmIGRfMS50ZXJtaW5hdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEudGVybWluYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY18xID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV8xLnNpemUgPSBzY18xLCBmaWxlXzEub3JpZ2luYWxTaXplID0gc3VfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5vbmZpbGUoZmlsZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnID09IDB4ODA3NEI1MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXMgPSBpICs9IDEyICsgKG9jID09IC0yICYmIDgpLCBmID0gMywgdGhpc18xLmMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzaWcgPT0gMHgyMDE0QjUwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcyA9IGkgLT0gNCwgZiA9IDMsIHRoaXNfMS5jID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGwgLSA0OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzIoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucCA9IGV0O1xuICAgICAgICAgICAgaWYgKG9jIDwgMCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXQgPSBmID8gYnVmLnN1YmFycmF5KDAsIGlzIC0gMTIgLSAob2MgPT0gLTIgJiYgOCkgLSAoYjQoYnVmLCBpcyAtIDE2KSA9PSAweDgwNzRCNTAgJiYgNCkpIDogYnVmLnN1YmFycmF5KDAsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpXG4gICAgICAgICAgICAgICAgICAgIGFkZC5wdXNoKGRhdCwgISFmKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMua1srKGYgPT0gMildLnB1c2goZGF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmICYgMilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoKGJ1Zi5zdWJhcnJheShpKSwgZmluYWwpO1xuICAgICAgICAgICAgdGhpcy5wID0gYnVmLnN1YmFycmF5KGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYylcbiAgICAgICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB6aXAgZmlsZSc7XG4gICAgICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBkZWNvZGVyIHdpdGggdGhlIHN0cmVhbSwgYWxsb3dpbmcgZm9yIGZpbGVzIGNvbXByZXNzZWQgd2l0aFxuICAgICAqIHRoZSBjb21wcmVzc2lvbiB0eXBlIHByb3ZpZGVkIHRvIGJlIGV4cGFuZGVkIGNvcnJlY3RseVxuICAgICAqIEBwYXJhbSBkZWNvZGVyIFRoZSBkZWNvZGVyIGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgVW56aXAucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGRlY29kZXIpIHtcbiAgICAgICAgdGhpcy5vW2RlY29kZXIuY29tcHJlc3Npb25dID0gZGVjb2RlcjtcbiAgICB9O1xuICAgIHJldHVybiBVbnppcDtcbn0oKSk7XG5leHBvcnQgeyBVbnppcCB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXNseSBkZWNvbXByZXNzZXMgYSBaSVAgYXJjaGl2ZVxuICogQHBhcmFtIGRhdGEgVGhlIHJhdyBjb21wcmVzc2VkIFpJUCBmaWxlXG4gKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2l0aCB0aGUgZGVjb21wcmVzc2VkIGZpbGVzXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gaW1tZWRpYXRlbHkgdGVybWluYXRlIHRoZSB1bnppcHBpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuemlwKGRhdGEsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgIHZhciB0ZXJtID0gW107XG4gICAgdmFyIHRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVybS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRlcm1baV0oKTtcbiAgICB9O1xuICAgIHZhciBmaWxlcyA9IHt9O1xuICAgIHZhciBlID0gZGF0YS5sZW5ndGggLSAyMjtcbiAgICBmb3IgKDsgYjQoZGF0YSwgZSkgIT0gMHg2MDU0QjUwOyAtLWUpIHtcbiAgICAgICAgaWYgKCFlIHx8IGRhdGEubGVuZ3RoIC0gZSA+IDY1NTU4KSB7XG4gICAgICAgICAgICBjYignaW52YWxpZCB6aXAgZmlsZScsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICB2YXIgbGZ0ID0gYjIoZGF0YSwgZSArIDgpO1xuICAgIGlmICghbGZ0KVxuICAgICAgICBjYihudWxsLCB7fSk7XG4gICAgdmFyIGMgPSBsZnQ7XG4gICAgdmFyIG8gPSBiNChkYXRhLCBlICsgMTYpO1xuICAgIHZhciB6ID0gbyA9PSA0Mjk0OTY3Mjk1O1xuICAgIGlmICh6KSB7XG4gICAgICAgIGUgPSBiNChkYXRhLCBlIC0gMTIpO1xuICAgICAgICBpZiAoYjQoZGF0YSwgZSkgIT0gMHg2MDY0QjUwKSB7XG4gICAgICAgICAgICBjYignaW52YWxpZCB6aXAgZmlsZScsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGMgPSBsZnQgPSBiNChkYXRhLCBlICsgMzIpO1xuICAgICAgICBvID0gYjQoZGF0YSwgZSArIDQ4KTtcbiAgICB9XG4gICAgdmFyIF9sb29wXzMgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgX2EgPSB6aChkYXRhLCBvLCB6KSwgY18xID0gX2FbMF0sIHNjID0gX2FbMV0sIHN1ID0gX2FbMl0sIGZuID0gX2FbM10sIG5vID0gX2FbNF0sIG9mZiA9IF9hWzVdLCBiID0gc2x6aChkYXRhLCBvZmYpO1xuICAgICAgICBvID0gbm87XG4gICAgICAgIHZhciBjYmwgPSBmdW5jdGlvbiAoZSwgZCkge1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICB0QWxsKCk7XG4gICAgICAgICAgICAgICAgY2IoZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWxlc1tmbl0gPSBkO1xuICAgICAgICAgICAgICAgIGlmICghLS1sZnQpXG4gICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIGZpbGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFjXzEpXG4gICAgICAgICAgICBjYmwobnVsbCwgc2xjKGRhdGEsIGIsIGIgKyBzYykpO1xuICAgICAgICBlbHNlIGlmIChjXzEgPT0gOCkge1xuICAgICAgICAgICAgdmFyIGluZmwgPSBkYXRhLnN1YmFycmF5KGIsIGIgKyBzYyk7XG4gICAgICAgICAgICBpZiAoc2MgPCAzMjAwMDApIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYmwobnVsbCwgaW5mbGF0ZVN5bmMoaW5mbCwgbmV3IHU4KHN1KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYmwoZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRlcm0ucHVzaChpbmZsYXRlKGluZmwsIHsgc2l6ZTogc3UgfSwgY2JsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2JsKCd1bmtub3duIGNvbXByZXNzaW9uIHR5cGUgJyArIGNfMSwgbnVsbCk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGM7ICsraSkge1xuICAgICAgICBfbG9vcF8zKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdEFsbDtcbn1cbi8qKlxuICogU3luY2hyb25vdXNseSBkZWNvbXByZXNzZXMgYSBaSVAgYXJjaGl2ZS4gUHJlZmVyIHVzaW5nIGB1bnppcGAgZm9yIGJldHRlclxuICogcGVyZm9ybWFuY2Ugd2l0aCBtb3JlIHRoYW4gb25lIGZpbGUuXG4gKiBAcGFyYW0gZGF0YSBUaGUgcmF3IGNvbXByZXNzZWQgWklQIGZpbGVcbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgZmlsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuemlwU3luYyhkYXRhKSB7XG4gICAgdmFyIGZpbGVzID0ge307XG4gICAgdmFyIGUgPSBkYXRhLmxlbmd0aCAtIDIyO1xuICAgIGZvciAoOyBiNChkYXRhLCBlKSAhPSAweDYwNTRCNTA7IC0tZSkge1xuICAgICAgICBpZiAoIWUgfHwgZGF0YS5sZW5ndGggLSBlID4gNjU1NTgpXG4gICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB6aXAgZmlsZSc7XG4gICAgfVxuICAgIDtcbiAgICB2YXIgYyA9IGIyKGRhdGEsIGUgKyA4KTtcbiAgICBpZiAoIWMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB2YXIgbyA9IGI0KGRhdGEsIGUgKyAxNik7XG4gICAgdmFyIHogPSBvID09IDQyOTQ5NjcyOTU7XG4gICAgaWYgKHopIHtcbiAgICAgICAgZSA9IGI0KGRhdGEsIGUgLSAxMik7XG4gICAgICAgIGlmIChiNChkYXRhLCBlKSAhPSAweDYwNjRCNTApXG4gICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB6aXAgZmlsZSc7XG4gICAgICAgIGMgPSBiNChkYXRhLCBlICsgMzIpO1xuICAgICAgICBvID0gYjQoZGF0YSwgZSArIDQ4KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjOyArK2kpIHtcbiAgICAgICAgdmFyIF9hID0gemgoZGF0YSwgbywgeiksIGNfMiA9IF9hWzBdLCBzYyA9IF9hWzFdLCBzdSA9IF9hWzJdLCBmbiA9IF9hWzNdLCBubyA9IF9hWzRdLCBvZmYgPSBfYVs1XSwgYiA9IHNsemgoZGF0YSwgb2ZmKTtcbiAgICAgICAgbyA9IG5vO1xuICAgICAgICBpZiAoIWNfMilcbiAgICAgICAgICAgIGZpbGVzW2ZuXSA9IHNsYyhkYXRhLCBiLCBiICsgc2MpO1xuICAgICAgICBlbHNlIGlmIChjXzIgPT0gOClcbiAgICAgICAgICAgIGZpbGVzW2ZuXSA9IGluZmxhdGVTeW5jKGRhdGEuc3ViYXJyYXkoYiwgYiArIHNjKSwgbmV3IHU4KHN1KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93ICd1bmtub3duIGNvbXByZXNzaW9uIHR5cGUgJyArIGNfMjtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGVzO1xufVxuIl0sIm5hbWVzIjpbImNyZWF0ZVJlcXVpcmUiLCJyZXF1aXJlIiwiV29ya2VyIiwid29ya2VyQWRkIiwiZSIsIndrIiwiYyIsIl8iLCJtc2ciLCJ0cmFuc2ZlciIsImNiIiwiZG9uZSIsInciLCJldmFsIiwib24iLCJtIiwiRXJyb3IiLCJwb3N0TWVzc2FnZSIsInRlcm1pbmF0ZSIsInByb3RvdHlwZSIsImNhbGwiLCJfXyIsIl9fXyIsIl9fX18iLCJzZXRJbW1lZGlhdGUiLCJOT1AiLCJ1OCIsIlVpbnQ4QXJyYXkiLCJ1MTYiLCJVaW50MTZBcnJheSIsInUzMiIsIlVpbnQzMkFycmF5IiwiZmxlYiIsImZkZWIiLCJjbGltIiwiZnJlYiIsImViIiwic3RhcnQiLCJiIiwiaSIsInIiLCJqIiwiX2EiLCJmbCIsInJldmZsIiwiX2IiLCJmZCIsInJldmZkIiwicmV2IiwieCIsImhNYXAiLCJjZCIsIm1iIiwicyIsImxlbmd0aCIsImwiLCJsZSIsImNvIiwicnZiIiwic3YiLCJyXzEiLCJ2IiwiZmx0IiwiZmR0IiwiZmxtIiwiZmxybSIsImZkbSIsImZkcm0iLCJtYXgiLCJhIiwiYml0cyIsImQiLCJwIiwibyIsImJpdHMxNiIsInNoZnQiLCJzbGMiLCJuIiwic2V0Iiwic3ViYXJyYXkiLCJpbmZsdCIsImRhdCIsImJ1ZiIsInN0Iiwic2wiLCJub0J1ZiIsIm5vU3QiLCJjYnVmIiwiYmwiLCJuYnVmIiwiTWF0aCIsImZpbmFsIiwiZiIsInBvcyIsImJ0IiwibG0iLCJkbSIsImxidCIsImRidCIsInRidHMiLCJ0eXBlIiwidCIsImhMaXQiLCJoY0xlbiIsInRsIiwibGR0IiwiY2x0IiwiY2xiIiwiY2xibXNrIiwiY2xtIiwibHQiLCJkdCIsImxtcyIsImRtcyIsImxwb3MiLCJzeW0iLCJhZGQiLCJkc3ltIiwiZW5kIiwid2JpdHMiLCJ3Yml0czE2IiwiaFRyZWUiLCJwdXNoIiwidDIiLCJzbGljZSIsImV0Iiwic29ydCIsImkwIiwiaTEiLCJpMiIsIm1heFN5bSIsInRyIiwibWJ0IiwibG4iLCJsZnQiLCJjc3QiLCJpMl8xIiwiaTJfMiIsImkyXzMiLCJsYyIsImNsIiwiY2xpIiwiY2xuIiwiY2xzIiwiY2xlbiIsImNmIiwid2ZibGsiLCJvdXQiLCJ3YmxrIiwic3ltcyIsImxmIiwiZGYiLCJsaSIsImJzIiwiZGx0IiwibWxiIiwiZGR0IiwibWRiIiwiX2MiLCJsY2x0IiwibmxjIiwiX2QiLCJsY2R0IiwibmRjIiwibGNmcmVxIiwiX2UiLCJsY3QiLCJtbGNiIiwibmxjYyIsImZsZW4iLCJmdGxlbiIsImR0bGVuIiwibGwiLCJkbCIsImxsbSIsImxjdHMiLCJpdCIsImNsY3QiLCJsZW4iLCJkc3QiLCJkZW8iLCJkZmx0IiwibHZsIiwicGx2bCIsInByZSIsInBvc3QiLCJsc3QiLCJjZWlsIiwib3B0IiwibXNrXzEiLCJwcmV2IiwiaGVhZCIsImJzMV8xIiwiYnMyXzEiLCJoc2giLCJsY18xIiwid2kiLCJodiIsImltb2QiLCJwaW1vZCIsInJlbSIsImNoXzEiLCJkaWYiLCJtYXhuIiwibWluIiwibWF4ZCIsIm1sIiwibmwiLCJtbWQiLCJtZCIsInRpIiwicHRpIiwibGluIiwiZGluIiwiY3JjdCIsIkludDMyQXJyYXkiLCJrIiwiY3JjIiwiY3IiLCJhZGxlciIsImRvcHQiLCJsZXZlbCIsIm1lbSIsImxvZyIsIm1yZyIsIndjbG4iLCJmbiIsImZuU3RyIiwidGQiLCJ0b1N0cmluZyIsImtzIiwiaW5kZXhPZiIsImxhc3RJbmRleE9mIiwicmVwbGFjZSIsInNwbGl0Iiwic3RfMSIsInNwSW5kIiwiY2giLCJjYmZzIiwiY29uc3RydWN0b3IiLCJidWZmZXIiLCJ3cmtyIiwiZm5zIiwiaW5pdCIsImlkIiwidGRfMSIsImJJbmZsdCIsImluZmxhdGVTeW5jIiwicGJmIiwiZ3U4IiwiYkRmbHQiLCJkZWZsYXRlU3luYyIsImd6ZSIsImd6aCIsImd6aGwiLCJ3Ynl0ZXMiLCJndXplIiwiZ3pzIiwiZ3psIiwiemxlIiwiemxoIiwienVsZSIsInpsdiIsInNpemUiLCJjYmlmeSIsIm9wdHMiLCJlcnIiLCJjb25zdW1lIiwiYXN0cm0iLCJzdHJtIiwib25kYXRhIiwiZXYiLCJkYXRhIiwiYXN0cm1pZnkiLCJiMiIsImI0IiwiYjgiLCJmaWxlbmFtZSIsIm10aW1lIiwiZmxvb3IiLCJEYXRlIiwibm93IiwiY2hhckNvZGVBdCIsImZsZyIsInpzIiwibHYiLCJBc3luY0NtcFN0cm0iLCJEZWZsYXRlIiwiY2h1bmsiLCJBc3luY0RlZmxhdGUiLCJvbm1lc3NhZ2UiLCJkZWZsYXRlIiwiSW5mbGF0ZSIsImJ0cyIsIkFzeW5jSW5mbGF0ZSIsImluZmxhdGUiLCJHemlwIiwicmF3IiwiQXN5bmNHemlwIiwiZ3ppcCIsImd6aXBTeW5jIiwiR3VuemlwIiwiQXN5bmNHdW56aXAiLCJndW56aXAiLCJndW56aXBTeW5jIiwiWmxpYiIsIkFzeW5jWmxpYiIsInpsaWIiLCJ6bGliU3luYyIsIlVuemxpYiIsIkFzeW5jVW56bGliIiwidW56bGliIiwidW56bGliU3luYyIsImNvbXByZXNzIiwiQXN5bmNDb21wcmVzcyIsImNvbXByZXNzU3luYyIsIkNvbXByZXNzIiwiRGVjb21wcmVzcyIsIkciLCJJIiwiWiIsIl90aGlzXzEiLCJhcHBseSIsImFyZ3VtZW50cyIsIkFzeW5jRGVjb21wcmVzcyIsImRlY29tcHJlc3MiLCJkZWNvbXByZXNzU3luYyIsImZsdG4iLCJ2YWwiLCJBcnJheSIsImlzQXJyYXkiLCJ0ZSIsIlRleHRFbmNvZGVyIiwiVGV4dERlY29kZXIiLCJ0ZHMiLCJkZWNvZGUiLCJzdHJlYW0iLCJkdXRmOCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIkRlY29kZVVURjgiLCJucCIsIkVuY29kZVVURjgiLCJzdHJUb1U4Iiwic3RyIiwibGF0aW4xIiwiYXJfMSIsImVuY29kZSIsImFyIiwiYWkiLCJzdHJGcm9tVTgiLCJleHQiLCJkYmYiLCJzbHpoIiwiemgiLCJ6IiwiZm5sIiwiZXMiLCJ6NjRlIiwic2MiLCJzdSIsIm9mZiIsImV4ZmwiLCJleCIsInd6aCIsInUiLCJjZSIsImV4dHJhIiwiY29sIiwiZXhsIiwib3MiLCJmbGFnIiwiY29tcHJlc3Npb24iLCJ5IiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiYXR0cnMiLCJleGYiLCJ3emYiLCJaaXBQYXNzVGhyb3VnaCIsInByb2Nlc3MiLCJaaXBEZWZsYXRlIiwiQXN5bmNaaXBEZWZsYXRlIiwiWmlwIiwiZmlsZSIsImNvbSIsImNvbW1lbnQiLCJobCIsImhlYWRlciIsImNoa3MiLCJwQWxsIiwiX2kiLCJjaGtzXzEiLCJjaGsiLCJpbmQiLCJ1ZiIsIm54dCIsImRkIiwic3BsaWNlIiwiemlwIiwiT2JqZWN0Iiwia2V5cyIsInRvdCIsInNsZnQiLCJmaWxlcyIsInRlcm0iLCJ0QWxsIiwiY2JmIiwib2UiLCJjZGwiLCJiYWRkIiwibG9jIiwiX2xvb3BfMSIsIm1zIiwiY2JsIiwiemlwU3luYyIsIlVuemlwUGFzc1Rocm91Z2giLCJVbnppcEluZmxhdGUiLCJBc3luY1VuemlwSW5mbGF0ZSIsInN6IiwiVW56aXAiLCJvbmZpbGUiLCJ0b0FkZCIsImlzIiwib2MiLCJfbG9vcF8yIiwic2lnIiwidGhpc18xIiwiYmYiLCJjbXBfMSIsImNoa3NfMiIsInVuc2hpZnQiLCJzY18xIiwic3VfMSIsImZuXzEiLCJkXzEiLCJmaWxlXzEiLCJuYW1lIiwiY3RyIiwiY2hrc18zIiwib3JpZ2luYWxTaXplIiwic3RhdGVfMSIsInJlZ2lzdGVyIiwiZGVjb2RlciIsInVuemlwIiwiX2xvb3BfMyIsImNfMSIsIm5vIiwiaW5mbCIsInVuemlwU3luYyIsImNfMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/node_modules/fflate/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/objects/GroundProjectedEnv.js":
/*!*****************************************************************!*\
  !*** ./node_modules/three-stdlib/objects/GroundProjectedEnv.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroundProjectedEnv: () => (/* binding */ GroundProjectedEnv)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst isCubeTexture = (def)=>def && def.isCubeTexture;\nclass GroundProjectedEnv extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n    constructor(texture, options){\n        var _a, _b;\n        const isCubeMap = isCubeTexture(texture);\n        const w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;\n        const cubeSize = w / 4;\n        const _lodMax = Math.floor(Math.log2(cubeSize));\n        const _cubeSize = Math.pow(2, _lodMax);\n        const width = 3 * Math.max(_cubeSize, 16 * 7);\n        const height = 4 * _cubeSize;\n        const defines = [\n            isCubeMap ? \"#define ENVMAP_TYPE_CUBE\" : \"\",\n            `#define CUBEUV_TEXEL_WIDTH ${1 / width}`,\n            `#define CUBEUV_TEXEL_HEIGHT ${1 / height}`,\n            `#define CUBEUV_MAX_MIP ${_lodMax}.0`\n        ];\n        const vertexShader = /* glsl */ `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `;\n        const fragmentShader = defines.join(\"\\n\") + /* glsl */ `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <${parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n        }\n        `;\n        const uniforms = {\n            map: {\n                value: texture\n            },\n            height: {\n                value: (options == null ? void 0 : options.height) || 15\n            },\n            radius: {\n                value: (options == null ? void 0 : options.radius) || 100\n            }\n        };\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.IcosahedronGeometry(1, 16);\n        const material = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n            uniforms,\n            fragmentShader,\n            vertexShader,\n            side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide\n        });\n        super(geometry, material);\n    }\n    set radius(radius) {\n        this.material.uniforms.radius.value = radius;\n    }\n    get radius() {\n        return this.material.uniforms.radius.value;\n    }\n    set height(height) {\n        this.material.uniforms.height.value = height;\n    }\n    get height() {\n        return this.material.uniforms.height.value;\n    }\n}\n //# sourceMappingURL=GroundProjectedEnv.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL29iamVjdHMvR3JvdW5kUHJvamVjdGVkRW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdGO0FBQ3hGLE1BQU1LLGdCQUFnQixDQUFDQyxNQUFRQSxPQUFPQSxJQUFJRCxhQUFhO0FBQ3ZELE1BQU1FLDJCQUEyQlAsdUNBQUlBO0lBQ25DUSxZQUFZQyxPQUFPLEVBQUVDLE9BQU8sQ0FBRTtRQUM1QixJQUFJQyxJQUFJQztRQUNSLE1BQU1DLFlBQVlSLGNBQWNJO1FBQ2hDLE1BQU1LLElBQUksQ0FBQ0YsS0FBS0MsWUFBWSxDQUFDRixLQUFLRixRQUFRTSxLQUFLLENBQUMsRUFBRSxLQUFLLE9BQU8sS0FBSyxJQUFJSixHQUFHSyxLQUFLLEdBQUdQLFFBQVFNLEtBQUssQ0FBQ0MsS0FBSyxLQUFLLE9BQU9KLEtBQUs7UUFDdEgsTUFBTUssV0FBV0gsSUFBSTtRQUNyQixNQUFNSSxVQUFVQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLElBQUksQ0FBQ0o7UUFDckMsTUFBTUssWUFBWUgsS0FBS0ksR0FBRyxDQUFDLEdBQUdMO1FBQzlCLE1BQU1GLFFBQVEsSUFBSUcsS0FBS0ssR0FBRyxDQUFDRixXQUFXLEtBQUs7UUFDM0MsTUFBTUcsU0FBUyxJQUFJSDtRQUNuQixNQUFNSSxVQUFVO1lBQ2RiLFlBQVksNkJBQTZCO1lBQ3pDLENBQUMsMkJBQTJCLEVBQUUsSUFBSUcsTUFBTSxDQUFDO1lBQ3pDLENBQUMsNEJBQTRCLEVBQUUsSUFBSVMsT0FBTyxDQUFDO1lBQzNDLENBQUMsdUJBQXVCLEVBQUVQLFFBQVEsRUFBRSxDQUFDO1NBQ3RDO1FBQ0QsTUFBTVMsZUFDSixRQUFRLEdBQ1IsQ0FBQzs7Ozs7Ozs7O1FBU0MsQ0FBQztRQUVMLE1BQU1DLGlCQUFpQkYsUUFBUUcsSUFBSSxDQUFDLFFBQVEsUUFBUSxHQUNwRCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBcUVpQixFQUFFQyxTQUFTN0IsMkNBQVFBLENBQUM4QixPQUFPLENBQUMsUUFBUSxRQUFRLE1BQU0sd0JBQXdCLHFCQUFxQjs7UUFFN0csQ0FBQztRQUNMLE1BQU1DLFdBQVc7WUFDZkMsS0FBSztnQkFBRUMsT0FBT3pCO1lBQVE7WUFDdEJnQixRQUFRO2dCQUFFUyxPQUFPLENBQUN4QixXQUFXLE9BQU8sS0FBSyxJQUFJQSxRQUFRZSxNQUFNLEtBQUs7WUFBRztZQUNuRVUsUUFBUTtnQkFBRUQsT0FBTyxDQUFDeEIsV0FBVyxPQUFPLEtBQUssSUFBSUEsUUFBUXlCLE1BQU0sS0FBSztZQUFJO1FBQ3RFO1FBQ0EsTUFBTUMsV0FBVyxJQUFJbEMsc0RBQW1CQSxDQUFDLEdBQUc7UUFDNUMsTUFBTW1DLFdBQVcsSUFBSWxDLGlEQUFjQSxDQUFDO1lBQ2xDNkI7WUFDQUo7WUFDQUQ7WUFDQVcsTUFBTWxDLDZDQUFVQTtRQUNsQjtRQUNBLEtBQUssQ0FBQ2dDLFVBQVVDO0lBQ2xCO0lBQ0EsSUFBSUYsT0FBT0EsTUFBTSxFQUFFO1FBQ2pCLElBQUksQ0FBQ0UsUUFBUSxDQUFDTCxRQUFRLENBQUNHLE1BQU0sQ0FBQ0QsS0FBSyxHQUFHQztJQUN4QztJQUNBLElBQUlBLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQ0UsUUFBUSxDQUFDTCxRQUFRLENBQUNHLE1BQU0sQ0FBQ0QsS0FBSztJQUM1QztJQUNBLElBQUlULE9BQU9BLE1BQU0sRUFBRTtRQUNqQixJQUFJLENBQUNZLFFBQVEsQ0FBQ0wsUUFBUSxDQUFDUCxNQUFNLENBQUNTLEtBQUssR0FBR1Q7SUFDeEM7SUFDQSxJQUFJQSxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUNZLFFBQVEsQ0FBQ0wsUUFBUSxDQUFDUCxNQUFNLENBQUNTLEtBQUs7SUFDNUM7QUFDRjtBQUdFLENBQ0YsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vM0QtQUktRW5nbGlzaC8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvb2JqZWN0cy9Hcm91bmRQcm9qZWN0ZWRFbnYuanM/NjBiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNZXNoLCBSRVZJU0lPTiwgSWNvc2FoZWRyb25HZW9tZXRyeSwgU2hhZGVyTWF0ZXJpYWwsIERvdWJsZVNpZGUgfSBmcm9tIFwidGhyZWVcIjtcbmNvbnN0IGlzQ3ViZVRleHR1cmUgPSAoZGVmKSA9PiBkZWYgJiYgZGVmLmlzQ3ViZVRleHR1cmU7XG5jbGFzcyBHcm91bmRQcm9qZWN0ZWRFbnYgZXh0ZW5kcyBNZXNoIHtcbiAgY29uc3RydWN0b3IodGV4dHVyZSwgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgaXNDdWJlTWFwID0gaXNDdWJlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICBjb25zdCB3ID0gKF9iID0gaXNDdWJlTWFwID8gKF9hID0gdGV4dHVyZS5pbWFnZVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLndpZHRoIDogdGV4dHVyZS5pbWFnZS53aWR0aCkgIT0gbnVsbCA/IF9iIDogMTAyNDtcbiAgICBjb25zdCBjdWJlU2l6ZSA9IHcgLyA0O1xuICAgIGNvbnN0IF9sb2RNYXggPSBNYXRoLmZsb29yKE1hdGgubG9nMihjdWJlU2l6ZSkpO1xuICAgIGNvbnN0IF9jdWJlU2l6ZSA9IE1hdGgucG93KDIsIF9sb2RNYXgpO1xuICAgIGNvbnN0IHdpZHRoID0gMyAqIE1hdGgubWF4KF9jdWJlU2l6ZSwgMTYgKiA3KTtcbiAgICBjb25zdCBoZWlnaHQgPSA0ICogX2N1YmVTaXplO1xuICAgIGNvbnN0IGRlZmluZXMgPSBbXG4gICAgICBpc0N1YmVNYXAgPyBcIiNkZWZpbmUgRU5WTUFQX1RZUEVfQ1VCRVwiIDogXCJcIixcbiAgICAgIGAjZGVmaW5lIENVQkVVVl9URVhFTF9XSURUSCAkezEgLyB3aWR0aH1gLFxuICAgICAgYCNkZWZpbmUgQ1VCRVVWX1RFWEVMX0hFSUdIVCAkezEgLyBoZWlnaHR9YCxcbiAgICAgIGAjZGVmaW5lIENVQkVVVl9NQVhfTUlQICR7X2xvZE1heH0uMGBcbiAgICBdO1xuICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IChcbiAgICAgIC8qIGdsc2wgKi9cbiAgICAgIGBcbiAgICAgICAgdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xuICAgICAgICB2b2lkIG1haW4oKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmVjNCB3b3JsZFBvc2l0aW9uID0gKCBtb2RlbE1hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKSApO1xuICAgICAgICAgICAgdldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xuICAgICAgICB9XG4gICAgICAgIGBcbiAgICApO1xuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gZGVmaW5lcy5qb2luKFwiXFxuXCIpICsgLyogZ2xzbCAqL1xuICAgIGBcbiAgICAgICAgI2RlZmluZSBFTlZNQVBfVFlQRV9DVUJFX1VWXG4gICAgICAgIHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgaGVpZ2h0O1xuICAgICAgICB1bmlmb3JtIGZsb2F0IGFuZ2xlO1xuICAgICAgICAjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyQ3ViZSBtYXA7XG4gICAgICAgICNlbHNlXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XG4gICAgICAgICNlbmRpZlxuICAgICAgICAvLyBGcm9tOiBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvNHRzQkQ3XG4gICAgICAgIGZsb2F0IGRpc2tJbnRlcnNlY3RXaXRoQmFja0ZhY2VDdWxsaW5nKCB2ZWMzIHJvLCB2ZWMzIHJkLCB2ZWMzIGMsIHZlYzMgbiwgZmxvYXQgciApIFxuICAgICAgICB7XG4gICAgICAgICAgICBmbG9hdCBkID0gZG90ICggcmQsIG4gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIGQgPiAwLjAgKSB7IHJldHVybiAxZTY7IH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmVjMyAgbyA9IHJvIC0gYztcbiAgICAgICAgICAgIGZsb2F0IHQgPSAtIGRvdCggbiwgbyApIC8gZDtcbiAgICAgICAgICAgIHZlYzMgIHEgPSBvICsgcmQgKiB0O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gKCBkb3QoIHEsIHEgKSA8IHIgKiByICkgPyB0IDogMWU2O1xuICAgICAgICB9XG4gICAgICAgIC8vIEZyb206IGh0dHBzOi8vd3d3LmlxdWlsZXpsZXMub3JnL3d3dy9hcnRpY2xlcy9pbnRlcnNlY3RvcnMvaW50ZXJzZWN0b3JzLmh0bVxuICAgICAgICBmbG9hdCBzcGhlcmVJbnRlcnNlY3QoIHZlYzMgcm8sIHZlYzMgcmQsIHZlYzMgY2UsIGZsb2F0IHJhICkgXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlYzMgb2MgPSBybyAtIGNlO1xuICAgICAgICAgICAgZmxvYXQgYiA9IGRvdCggb2MsIHJkICk7XG4gICAgICAgICAgICBmbG9hdCBjID0gZG90KCBvYywgb2MgKSAtIHJhICogcmE7XG4gICAgICAgICAgICBmbG9hdCBoID0gYiAqIGIgLSBjO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggaCA8IDAuMCApIHsgcmV0dXJuIC0xLjA7IH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaCA9IHNxcnQoIGggKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIC0gYiArIGg7XG4gICAgICAgIH1cbiAgICAgICAgdmVjMyBwcm9qZWN0KCkgXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlYzMgcCA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gKTtcbiAgICAgICAgICAgIHZlYzMgY2FtUG9zID0gY2FtZXJhUG9zaXRpb247XG4gICAgICAgICAgICBjYW1Qb3MueSAtPSBoZWlnaHQ7XG4gICAgICAgICAgICBmbG9hdCBpbnRlcnNlY3Rpb24gPSBzcGhlcmVJbnRlcnNlY3QoIGNhbVBvcywgcCwgdmVjMyggMC4wICksIHJhZGl1cyApO1xuICAgICAgICAgICAgaWYoIGludGVyc2VjdGlvbiA+IDAuMCApIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2ZWMzIGggPSB2ZWMzKCAwLjAsIC0gaGVpZ2h0LCAwLjAgKTtcbiAgICAgICAgICAgICAgICBmbG9hdCBpbnRlcnNlY3Rpb24yID0gZGlza0ludGVyc2VjdFdpdGhCYWNrRmFjZUN1bGxpbmcoIGNhbVBvcywgcCwgaCwgdmVjMyggMC4wLCAxLjAsIDAuMCApLCByYWRpdXMgKTtcbiAgICAgICAgICAgICAgICBwID0gKCBjYW1Qb3MgKyBtaW4oIGludGVyc2VjdGlvbiwgaW50ZXJzZWN0aW9uMiApICogcCApIC8gcmFkaXVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwID0gdmVjMyggMC4wLCAxLjAsIDAuMCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICAgICAgI2luY2x1ZGUgPGNvbW1vbj5cbiAgICAgICAgI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cbiAgICAgICAgdm9pZCBtYWluKCkgXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlYzMgcHJvamVjdGVkV29ybGRQb3NpdGlvbiA9IHByb2plY3QoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcbiAgICAgICAgICAgICAgICB2ZWMzIG91dGNvbG9yID0gdGV4dHVyZUN1YmUoIG1hcCwgcHJvamVjdGVkV29ybGRQb3NpdGlvbiApLnJnYjtcbiAgICAgICAgICAgICNlbHNlXG4gICAgICAgICAgICAgICAgdmVjMyBkaXJlY3Rpb24gPSBub3JtYWxpemUoIHByb2plY3RlZFdvcmxkUG9zaXRpb24gKTtcbiAgICAgICAgICAgICAgICB2ZWMyIHV2ID0gZXF1aXJlY3RVdiggZGlyZWN0aW9uICk7XG4gICAgICAgICAgICAgICAgdmVjMyBvdXRjb2xvciA9IHRleHR1cmUyRCggbWFwLCB1diApLnJnYjtcbiAgICAgICAgICAgICNlbmRpZlxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Y29sb3IsIDEuMCApO1xuICAgICAgICAgICAgI2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxuICAgICAgICAgICAgI2luY2x1ZGUgPCR7cGFyc2VJbnQoUkVWSVNJT04ucmVwbGFjZSgvXFxEKy9nLCBcIlwiKSkgPj0gMTU0ID8gXCJjb2xvcnNwYWNlX2ZyYWdtZW50XCIgOiBcImVuY29kaW5nc19mcmFnbWVudFwifT5cbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgIGNvbnN0IHVuaWZvcm1zID0ge1xuICAgICAgbWFwOiB7IHZhbHVlOiB0ZXh0dXJlIH0sXG4gICAgICBoZWlnaHQ6IHsgdmFsdWU6IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhlaWdodCkgfHwgMTUgfSxcbiAgICAgIHJhZGl1czogeyB2YWx1ZTogKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucmFkaXVzKSB8fCAxMDAgfVxuICAgIH07XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgSWNvc2FoZWRyb25HZW9tZXRyeSgxLCAxNik7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXMsXG4gICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgIHZlcnRleFNoYWRlcixcbiAgICAgIHNpZGU6IERvdWJsZVNpZGVcbiAgICB9KTtcbiAgICBzdXBlcihnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICB9XG4gIHNldCByYWRpdXMocmFkaXVzKSB7XG4gICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5yYWRpdXMudmFsdWUgPSByYWRpdXM7XG4gIH1cbiAgZ2V0IHJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5yYWRpdXMudmFsdWU7XG4gIH1cbiAgc2V0IGhlaWdodChoZWlnaHQpIHtcbiAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLmhlaWdodC52YWx1ZSA9IGhlaWdodDtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLmhlaWdodC52YWx1ZTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgR3JvdW5kUHJvamVjdGVkRW52XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JvdW5kUHJvamVjdGVkRW52LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk1lc2giLCJSRVZJU0lPTiIsIkljb3NhaGVkcm9uR2VvbWV0cnkiLCJTaGFkZXJNYXRlcmlhbCIsIkRvdWJsZVNpZGUiLCJpc0N1YmVUZXh0dXJlIiwiZGVmIiwiR3JvdW5kUHJvamVjdGVkRW52IiwiY29uc3RydWN0b3IiLCJ0ZXh0dXJlIiwib3B0aW9ucyIsIl9hIiwiX2IiLCJpc0N1YmVNYXAiLCJ3IiwiaW1hZ2UiLCJ3aWR0aCIsImN1YmVTaXplIiwiX2xvZE1heCIsIk1hdGgiLCJmbG9vciIsImxvZzIiLCJfY3ViZVNpemUiLCJwb3ciLCJtYXgiLCJoZWlnaHQiLCJkZWZpbmVzIiwidmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiLCJqb2luIiwicGFyc2VJbnQiLCJyZXBsYWNlIiwidW5pZm9ybXMiLCJtYXAiLCJ2YWx1ZSIsInJhZGl1cyIsImdlb21ldHJ5IiwibWF0ZXJpYWwiLCJzaWRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/objects/GroundProjectedEnv.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/types/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/three-stdlib/types/helpers.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWithKey: () => (/* binding */ getWithKey)\n/* harmony export */ });\nconst getWithKey = (obj, key)=>obj[key];\n //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3R5cGVzL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLGFBQWEsQ0FBQ0MsS0FBS0MsTUFBUUQsR0FBRyxDQUFDQyxJQUFJO0FBR3ZDLENBQ0YsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vM0QtQUktRW5nbGlzaC8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvdHlwZXMvaGVscGVycy5qcz8yZjRmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGdldFdpdGhLZXkgPSAob2JqLCBrZXkpID0+IG9ialtrZXldO1xuZXhwb3J0IHtcbiAgZ2V0V2l0aEtleVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwXG4iXSwibmFtZXMiOlsiZ2V0V2l0aEtleSIsIm9iaiIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/types/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/three-stdlib/utils/BufferGeometryUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMorphedAttributes: () => (/* binding */ computeMorphedAttributes),\n/* harmony export */   estimateBytesUsed: () => (/* binding */ estimateBytesUsed),\n/* harmony export */   interleaveAttributes: () => (/* binding */ interleaveAttributes),\n/* harmony export */   mergeBufferAttributes: () => (/* binding */ mergeBufferAttributes),\n/* harmony export */   mergeBufferGeometries: () => (/* binding */ mergeBufferGeometries),\n/* harmony export */   mergeVertices: () => (/* binding */ mergeVertices),\n/* harmony export */   toCreasedNormals: () => (/* binding */ toCreasedNormals),\n/* harmony export */   toTrianglesDrawMode: () => (/* binding */ toTrianglesDrawMode)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _types_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/helpers.js */ \"(ssr)/./node_modules/three-stdlib/types/helpers.js\");\n\n\nconst mergeBufferGeometries = (geometries, useGroups)=>{\n    const isIndexed = geometries[0].index !== null;\n    const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n    const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n    const attributes = {};\n    const morphAttributes = {};\n    const morphTargetsRelative = geometries[0].morphTargetsRelative;\n    const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n    let offset = 0;\n    geometries.forEach((geom, i)=>{\n        let attributesCount = 0;\n        if (isIndexed !== (geom.index !== null)) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\");\n            return null;\n        }\n        for(let name in geom.attributes){\n            if (!attributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n                return null;\n            }\n            if (attributes[name] === void 0) {\n                attributes[name] = [];\n            }\n            attributes[name].push(geom.attributes[name]);\n            attributesCount++;\n        }\n        if (attributesCount !== attributesUsed.size) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\");\n            return null;\n        }\n        if (morphTargetsRelative !== geom.morphTargetsRelative) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\");\n            return null;\n        }\n        for(let name in geom.morphAttributes){\n            if (!morphAttributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\");\n                return null;\n            }\n            if (morphAttributes[name] === void 0) morphAttributes[name] = [];\n            morphAttributes[name].push(geom.morphAttributes[name]);\n        }\n        mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n        mergedGeometry.userData.mergedUserData.push(geom.userData);\n        if (useGroups) {\n            let count;\n            if (geom.index) {\n                count = geom.index.count;\n            } else if (geom.attributes.position !== void 0) {\n                count = geom.attributes.position.count;\n            } else {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\");\n                return null;\n            }\n            mergedGeometry.addGroup(offset, count, i);\n            offset += count;\n        }\n    });\n    if (isIndexed) {\n        let indexOffset = 0;\n        const mergedIndex = [];\n        geometries.forEach((geom)=>{\n            const index = geom.index;\n            for(let j = 0; j < index.count; ++j){\n                mergedIndex.push(index.getX(j) + indexOffset);\n            }\n            indexOffset += geom.attributes.position.count;\n        });\n        mergedGeometry.setIndex(mergedIndex);\n    }\n    for(let name in attributes){\n        const mergedAttribute = mergeBufferAttributes(attributes[name]);\n        if (!mergedAttribute) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\");\n            return null;\n        }\n        mergedGeometry.setAttribute(name, mergedAttribute);\n    }\n    for(let name in morphAttributes){\n        const numMorphTargets = morphAttributes[name][0].length;\n        if (numMorphTargets === 0) break;\n        mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n        mergedGeometry.morphAttributes[name] = [];\n        for(let i = 0; i < numMorphTargets; ++i){\n            const morphAttributesToMerge = [];\n            for(let j = 0; j < morphAttributes[name].length; ++j){\n                morphAttributesToMerge.push(morphAttributes[name][j][i]);\n            }\n            const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n            if (!mergedMorphAttribute) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\");\n                return null;\n            }\n            mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n        }\n    }\n    return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes)=>{\n    let TypedArray = void 0;\n    let itemSize = void 0;\n    let normalized = void 0;\n    let arrayLength = 0;\n    attributes.forEach((attr)=>{\n        if (TypedArray === void 0) {\n            TypedArray = attr.array.constructor;\n        }\n        if (TypedArray !== attr.array.constructor) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\");\n            return null;\n        }\n        if (itemSize === void 0) itemSize = attr.itemSize;\n        if (itemSize !== attr.itemSize) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\");\n            return null;\n        }\n        if (normalized === void 0) normalized = attr.normalized;\n        if (normalized !== attr.normalized) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\");\n            return null;\n        }\n        arrayLength += attr.array.length;\n    });\n    if (TypedArray && itemSize) {\n        const array = new TypedArray(arrayLength);\n        let offset = 0;\n        attributes.forEach((attr)=>{\n            array.set(attr.array, offset);\n            offset += attr.array.length;\n        });\n        return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n    }\n};\nconst interleaveAttributes = (attributes)=>{\n    let TypedArray = void 0;\n    let arrayLength = 0;\n    let stride = 0;\n    for(let i = 0, l = attributes.length; i < l; ++i){\n        const attribute = attributes[i];\n        if (TypedArray === void 0) TypedArray = attribute.array.constructor;\n        if (TypedArray !== attribute.array.constructor) {\n            console.error(\"AttributeBuffers of different types cannot be interleaved\");\n            return null;\n        }\n        arrayLength += attribute.array.length;\n        stride += attribute.itemSize;\n    }\n    const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride);\n    let offset = 0;\n    const res = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    const setters = [\n        \"setX\",\n        \"setY\",\n        \"setZ\",\n        \"setW\"\n    ];\n    for(let j = 0, l = attributes.length; j < l; j++){\n        const attribute = attributes[j];\n        const itemSize = attribute.itemSize;\n        const count = attribute.count;\n        const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n        res.push(iba);\n        offset += itemSize;\n        for(let c = 0; c < count; c++){\n            for(let k = 0; k < itemSize; k++){\n                const set = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(iba, setters[k]);\n                const get = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(attribute, getters[k]);\n                set(c, get(c));\n            }\n        }\n    }\n    return res;\n};\nfunction estimateBytesUsed(geometry) {\n    let mem = 0;\n    for(let name in geometry.attributes){\n        const attr = geometry.getAttribute(name);\n        mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n    }\n    const indices = geometry.getIndex();\n    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n    return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n    tolerance = Math.max(tolerance, Number.EPSILON);\n    const hashToIndex = {};\n    const indices = geometry.getIndex();\n    const positions = geometry.getAttribute(\"position\");\n    const vertexCount = indices ? indices.count : positions.count;\n    let nextIndex = 0;\n    const attributeNames = Object.keys(geometry.attributes);\n    const attrArrays = {};\n    const morphAttrsArrays = {};\n    const newIndices = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    for(let i = 0, l = attributeNames.length; i < l; i++){\n        const name = attributeNames[i];\n        attrArrays[name] = [];\n        const morphAttr = geometry.morphAttributes[name];\n        if (morphAttr) {\n            morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(()=>[]);\n        }\n    }\n    const decimalShift = Math.log10(1 / tolerance);\n    const shiftMultiplier = Math.pow(10, decimalShift);\n    for(let i = 0; i < vertexCount; i++){\n        const index = indices ? indices.getX(i) : i;\n        let hash = \"\";\n        for(let j = 0, l = attributeNames.length; j < l; j++){\n            const name = attributeNames[j];\n            const attribute = geometry.getAttribute(name);\n            const itemSize = attribute.itemSize;\n            for(let k = 0; k < itemSize; k++){\n                hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n            }\n        }\n        if (hash in hashToIndex) {\n            newIndices.push(hashToIndex[hash]);\n        } else {\n            for(let j = 0, l = attributeNames.length; j < l; j++){\n                const name = attributeNames[j];\n                const attribute = geometry.getAttribute(name);\n                const morphAttr = geometry.morphAttributes[name];\n                const itemSize = attribute.itemSize;\n                const newarray = attrArrays[name];\n                const newMorphArrays = morphAttrsArrays[name];\n                for(let k = 0; k < itemSize; k++){\n                    const getterFunc = getters[k];\n                    newarray.push(attribute[getterFunc](index));\n                    if (morphAttr) {\n                        for(let m = 0, ml = morphAttr.length; m < ml; m++){\n                            newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n                        }\n                    }\n                }\n            }\n            hashToIndex[hash] = nextIndex;\n            newIndices.push(nextIndex);\n            nextIndex++;\n        }\n    }\n    const result = geometry.clone();\n    for(let i = 0, l = attributeNames.length; i < l; i++){\n        const name = attributeNames[i];\n        const oldAttribute = geometry.getAttribute(name);\n        const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n        const attribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n        result.setAttribute(name, attribute);\n        if (name in morphAttrsArrays) {\n            for(let j = 0; j < morphAttrsArrays[name].length; j++){\n                const oldMorphAttribute = geometry.morphAttributes[name][j];\n                const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n                const morphAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n                result.morphAttributes[name][j] = morphAttribute;\n            }\n        }\n    }\n    result.setIndex(newIndices);\n    return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode) {\n        console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n        return geometry;\n    }\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {\n        let index = geometry.getIndex();\n        if (index === null) {\n            const indices = [];\n            const position = geometry.getAttribute(\"position\");\n            if (position !== void 0) {\n                for(let i = 0; i < position.count; i++){\n                    indices.push(i);\n                }\n                geometry.setIndex(indices);\n                index = geometry.getIndex();\n            } else {\n                console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\");\n                return geometry;\n            }\n        }\n        const numberOfTriangles = index.count - 2;\n        const newIndices = [];\n        if (index) {\n            if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {\n                for(let i = 1; i <= numberOfTriangles; i++){\n                    newIndices.push(index.getX(0));\n                    newIndices.push(index.getX(i));\n                    newIndices.push(index.getX(i + 1));\n                }\n            } else {\n                for(let i = 0; i < numberOfTriangles; i++){\n                    if (i % 2 === 0) {\n                        newIndices.push(index.getX(i));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i + 2));\n                    } else {\n                        newIndices.push(index.getX(i + 2));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i));\n                    }\n                }\n            }\n        }\n        if (newIndices.length / 3 !== numberOfTriangles) {\n            console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n        }\n        const newGeometry = geometry.clone();\n        newGeometry.setIndex(newIndices);\n        newGeometry.clearGroups();\n        return newGeometry;\n    } else {\n        console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n        return geometry;\n    }\n}\nfunction computeMorphedAttributes(object) {\n    if (object.geometry.isBufferGeometry !== true) {\n        console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n        return null;\n    }\n    const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n        _vA.fromBufferAttribute(attribute, a2);\n        _vB.fromBufferAttribute(attribute, b2);\n        _vC.fromBufferAttribute(attribute, c2);\n        const morphInfluences = object2.morphTargetInfluences;\n        if (// @ts-ignore\n        material2.morphTargets && morphAttribute && morphInfluences) {\n            _morphA.set(0, 0, 0);\n            _morphB.set(0, 0, 0);\n            _morphC.set(0, 0, 0);\n            for(let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++){\n                const influence = morphInfluences[i2];\n                const morph = morphAttribute[i2];\n                if (influence === 0) continue;\n                _tempA.fromBufferAttribute(morph, a2);\n                _tempB.fromBufferAttribute(morph, b2);\n                _tempC.fromBufferAttribute(morph, c2);\n                if (morphTargetsRelative2) {\n                    _morphA.addScaledVector(_tempA, influence);\n                    _morphB.addScaledVector(_tempB, influence);\n                    _morphC.addScaledVector(_tempC, influence);\n                } else {\n                    _morphA.addScaledVector(_tempA.sub(_vA), influence);\n                    _morphB.addScaledVector(_tempB.sub(_vB), influence);\n                    _morphC.addScaledVector(_tempC.sub(_vC), influence);\n                }\n            }\n            _vA.add(_morphA);\n            _vB.add(_morphB);\n            _vC.add(_morphC);\n        }\n        if (object2.isSkinnedMesh) {\n            object2.boneTransform(a2, _vA);\n            object2.boneTransform(b2, _vB);\n            object2.boneTransform(c2, _vC);\n        }\n        modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n        modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n        modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n        modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n        modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n        modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n        modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n        modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n        modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n    }\n    const geometry = object.geometry;\n    const material = object.material;\n    let a, b, c;\n    const index = geometry.index;\n    const positionAttribute = geometry.attributes.position;\n    const morphPosition = geometry.morphAttributes.position;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    const normalAttribute = geometry.attributes.normal;\n    const morphNormal = geometry.morphAttributes.position;\n    const groups = geometry.groups;\n    const drawRange = geometry.drawRange;\n    let i, j, il, jl;\n    let group, groupMaterial;\n    let start, end;\n    const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n    const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n    if (index !== null) {\n        if (Array.isArray(material)) {\n            for(i = 0, il = groups.length; i < il; i++){\n                group = groups[i];\n                groupMaterial = material[group.materialIndex];\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n                for(j = start, jl = end; j < jl; j += 3){\n                    a = index.getX(j);\n                    b = index.getX(j + 1);\n                    c = index.getX(j + 2);\n                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n                }\n            }\n        } else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(index.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = index.getX(i);\n                b = index.getX(i + 1);\n                c = index.getX(i + 2);\n                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    } else if (positionAttribute !== void 0) {\n        if (Array.isArray(material)) {\n            for(i = 0, il = groups.length; i < il; i++){\n                group = groups[i];\n                groupMaterial = material[group.materialIndex];\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n                for(j = start, jl = end; j < jl; j += 3){\n                    a = j;\n                    b = j + 1;\n                    c = j + 2;\n                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n                }\n            }\n        } else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = i;\n                b = i + 1;\n                c = i + 2;\n                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    }\n    const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3);\n    const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);\n    return {\n        positionAttribute,\n        normalAttribute,\n        morphedPositionAttribute,\n        morphedNormalAttribute\n    };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n    const creaseDot = Math.cos(creaseAngle);\n    const hashMultiplier = (1 + 1e-10) * 100;\n    const verts = [\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n    ];\n    const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    function hashVertex(v) {\n        const x = ~~(v.x * hashMultiplier);\n        const y = ~~(v.y * hashMultiplier);\n        const z = ~~(v.z * hashMultiplier);\n        return `${x},${y},${z}`;\n    }\n    const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n    const posAttr = resultGeometry.attributes.position;\n    const vertexMap = {};\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            if (!(hash in vertexMap)) {\n                vertexMap[hash] = [];\n            }\n            vertexMap[hash].push(normal);\n        }\n    }\n    const normalArray = new Float32Array(posAttr.count * 3);\n    const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, false);\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            const otherNormals = vertexMap[hash];\n            tempNorm2.set(0, 0, 0);\n            for(let k = 0, lk = otherNormals.length; k < lk; k++){\n                const otherNorm = otherNormals[k];\n                if (tempNorm.dot(otherNorm) > creaseDot) {\n                    tempNorm2.add(otherNorm);\n                }\n            }\n            tempNorm2.normalize();\n            normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n        }\n    }\n    resultGeometry.setAttribute(\"normal\", normAttr);\n    return resultGeometry;\n}\n //# sourceMappingURL=BufferGeometryUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1TTtBQUN0SjtBQUNqRCxNQUFNVSx3QkFBd0IsQ0FBQ0MsWUFBWUM7SUFDekMsTUFBTUMsWUFBWUYsVUFBVSxDQUFDLEVBQUUsQ0FBQ0csS0FBSyxLQUFLO0lBQzFDLE1BQU1DLGlCQUFpQixJQUFJQyxJQUFJQyxPQUFPQyxJQUFJLENBQUNQLFVBQVUsQ0FBQyxFQUFFLENBQUNRLFVBQVU7SUFDbkUsTUFBTUMsc0JBQXNCLElBQUlKLElBQUlDLE9BQU9DLElBQUksQ0FBQ1AsVUFBVSxDQUFDLEVBQUUsQ0FBQ1UsZUFBZTtJQUM3RSxNQUFNRixhQUFhLENBQUM7SUFDcEIsTUFBTUUsa0JBQWtCLENBQUM7SUFDekIsTUFBTUMsdUJBQXVCWCxVQUFVLENBQUMsRUFBRSxDQUFDVyxvQkFBb0I7SUFDL0QsTUFBTUMsaUJBQWlCLElBQUl2QixpREFBY0E7SUFDekMsSUFBSXdCLFNBQVM7SUFDYmIsV0FBV2MsT0FBTyxDQUFDLENBQUNDLE1BQU1DO1FBQ3hCLElBQUlDLGtCQUFrQjtRQUN0QixJQUFJZixjQUFlYSxDQUFBQSxLQUFLWixLQUFLLEtBQUssSUFBRyxHQUFJO1lBQ3ZDZSxRQUFRQyxLQUFLLENBQ1gsdUZBQXVGSCxJQUFJO1lBRTdGLE9BQU87UUFDVDtRQUNBLElBQUssSUFBSUksUUFBUUwsS0FBS1AsVUFBVSxDQUFFO1lBQ2hDLElBQUksQ0FBQ0osZUFBZWlCLEdBQUcsQ0FBQ0QsT0FBTztnQkFDN0JGLFFBQVFDLEtBQUssQ0FDWCx1RkFBdUZILElBQUksa0VBQWtFSSxPQUFPO2dCQUV0SyxPQUFPO1lBQ1Q7WUFDQSxJQUFJWixVQUFVLENBQUNZLEtBQUssS0FBSyxLQUFLLEdBQUc7Z0JBQy9CWixVQUFVLENBQUNZLEtBQUssR0FBRyxFQUFFO1lBQ3ZCO1lBQ0FaLFVBQVUsQ0FBQ1ksS0FBSyxD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ZXMvdGhyZWUtc3RkbGliL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanM/MTJlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSwgQnVmZmVyQXR0cmlidXRlLCBJbnRlcmxlYXZlZEJ1ZmZlciwgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUsIFRyaWFuZ2xlc0RyYXdNb2RlLCBUcmlhbmdsZUZhbkRyYXdNb2RlLCBUcmlhbmdsZVN0cmlwRHJhd01vZGUsIFZlY3RvcjMsIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IGdldFdpdGhLZXkgfSBmcm9tIFwiLi4vdHlwZXMvaGVscGVycy5qc1wiO1xuY29uc3QgbWVyZ2VCdWZmZXJHZW9tZXRyaWVzID0gKGdlb21ldHJpZXMsIHVzZUdyb3VwcykgPT4ge1xuICBjb25zdCBpc0luZGV4ZWQgPSBnZW9tZXRyaWVzWzBdLmluZGV4ICE9PSBudWxsO1xuICBjb25zdCBhdHRyaWJ1dGVzVXNlZCA9IG5ldyBTZXQoT2JqZWN0LmtleXMoZ2VvbWV0cmllc1swXS5hdHRyaWJ1dGVzKSk7XG4gIGNvbnN0IG1vcnBoQXR0cmlidXRlc1VzZWQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGdlb21ldHJpZXNbMF0ubW9ycGhBdHRyaWJ1dGVzKSk7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3QgbW9ycGhBdHRyaWJ1dGVzID0ge307XG4gIGNvbnN0IG1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gZ2VvbWV0cmllc1swXS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcbiAgY29uc3QgbWVyZ2VkR2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGdlb21ldHJpZXMuZm9yRWFjaCgoZ2VvbSwgaSkgPT4ge1xuICAgIGxldCBhdHRyaWJ1dGVzQ291bnQgPSAwO1xuICAgIGlmIChpc0luZGV4ZWQgIT09IChnZW9tLmluZGV4ICE9PSBudWxsKSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIEFsbCBnZW9tZXRyaWVzIG11c3QgaGF2ZSBjb21wYXRpYmxlIGF0dHJpYnV0ZXM7IG1ha2Ugc3VyZSBpbmRleCBhdHRyaWJ1dGUgZXhpc3RzIGFtb25nIGFsbCBnZW9tZXRyaWVzLCBvciBpbiBub25lIG9mIHRoZW0uXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yIChsZXQgbmFtZSBpbiBnZW9tLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghYXR0cmlidXRlc1VzZWQuaGFzKG5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgJy4gQWxsIGdlb21ldHJpZXMgbXVzdCBoYXZlIGNvbXBhdGlibGUgYXR0cmlidXRlczsgbWFrZSBzdXJlIFwiJyArIG5hbWUgKyAnXCIgYXR0cmlidXRlIGV4aXN0cyBhbW9uZyBhbGwgZ2VvbWV0cmllcywgb3IgaW4gbm9uZSBvZiB0aGVtLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlc1tuYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGF0dHJpYnV0ZXNbbmFtZV0ucHVzaChnZW9tLmF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgICAgYXR0cmlidXRlc0NvdW50Kys7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVzQ291bnQgIT09IGF0dHJpYnV0ZXNVc2VkLnNpemUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiBNYWtlIHN1cmUgYWxsIGdlb21ldHJpZXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAobW9ycGhUYXJnZXRzUmVsYXRpdmUgIT09IGdlb20ubW9ycGhUYXJnZXRzUmVsYXRpdmUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiAubW9ycGhUYXJnZXRzUmVsYXRpdmUgbXVzdCBiZSBjb25zaXN0ZW50IHRocm91Z2hvdXQgYWxsIGdlb21ldHJpZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yIChsZXQgbmFtZSBpbiBnZW9tLm1vcnBoQXR0cmlidXRlcykge1xuICAgICAgaWYgKCFtb3JwaEF0dHJpYnV0ZXNVc2VkLmhhcyhuYW1lKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiAgLm1vcnBoQXR0cmlidXRlcyBtdXN0IGJlIGNvbnNpc3RlbnQgdGhyb3VnaG91dCBhbGwgZ2VvbWV0cmllcy5cIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChtb3JwaEF0dHJpYnV0ZXNbbmFtZV0gPT09IHZvaWQgMClcbiAgICAgICAgbW9ycGhBdHRyaWJ1dGVzW25hbWVdID0gW107XG4gICAgICBtb3JwaEF0dHJpYnV0ZXNbbmFtZV0ucHVzaChnZW9tLm1vcnBoQXR0cmlidXRlc1tuYW1lXSk7XG4gICAgfVxuICAgIG1lcmdlZEdlb21ldHJ5LnVzZXJEYXRhLm1lcmdlZFVzZXJEYXRhID0gbWVyZ2VkR2VvbWV0cnkudXNlckRhdGEubWVyZ2VkVXNlckRhdGEgfHwgW107XG4gICAgbWVyZ2VkR2VvbWV0cnkudXNlckRhdGEubWVyZ2VkVXNlckRhdGEucHVzaChnZW9tLnVzZXJEYXRhKTtcbiAgICBpZiAodXNlR3JvdXBzKSB7XG4gICAgICBsZXQgY291bnQ7XG4gICAgICBpZiAoZ2VvbS5pbmRleCkge1xuICAgICAgICBjb3VudCA9IGdlb20uaW5kZXguY291bnQ7XG4gICAgICB9IGVsc2UgaWYgKGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvdW50ID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gVGhlIGdlb21ldHJ5IG11c3QgaGF2ZSBlaXRoZXIgYW4gaW5kZXggb3IgYSBwb3NpdGlvbiBhdHRyaWJ1dGVcIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG1lcmdlZEdlb21ldHJ5LmFkZEdyb3VwKG9mZnNldCwgY291bnQsIGkpO1xuICAgICAgb2Zmc2V0ICs9IGNvdW50O1xuICAgIH1cbiAgfSk7XG4gIGlmIChpc0luZGV4ZWQpIHtcbiAgICBsZXQgaW5kZXhPZmZzZXQgPSAwO1xuICAgIGNvbnN0IG1lcmdlZEluZGV4ID0gW107XG4gICAgZ2VvbWV0cmllcy5mb3JFYWNoKChnZW9tKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IGdlb20uaW5kZXg7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZGV4LmNvdW50OyArK2opIHtcbiAgICAgICAgbWVyZ2VkSW5kZXgucHVzaChpbmRleC5nZXRYKGopICsgaW5kZXhPZmZzZXQpO1xuICAgICAgfVxuICAgICAgaW5kZXhPZmZzZXQgKz0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuICAgIH0pO1xuICAgIG1lcmdlZEdlb21ldHJ5LnNldEluZGV4KG1lcmdlZEluZGV4KTtcbiAgfVxuICBmb3IgKGxldCBuYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBtZXJnZWRBdHRyaWJ1dGUgPSBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgaWYgKCFtZXJnZWRBdHRyaWJ1dGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aGlsZSB0cnlpbmcgdG8gbWVyZ2UgdGhlIFwiICsgbmFtZSArIFwiIGF0dHJpYnV0ZS5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBtZXJnZWRHZW9tZXRyeS5zZXRBdHRyaWJ1dGUobmFtZSwgbWVyZ2VkQXR0cmlidXRlKTtcbiAgfVxuICBmb3IgKGxldCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcykge1xuICAgIGNvbnN0IG51bU1vcnBoVGFyZ2V0cyA9IG1vcnBoQXR0cmlidXRlc1tuYW1lXVswXS5sZW5ndGg7XG4gICAgaWYgKG51bU1vcnBoVGFyZ2V0cyA9PT0gMClcbiAgICAgIGJyZWFrO1xuICAgIG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyA9IG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyB8fCB7fTtcbiAgICBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU1vcnBoVGFyZ2V0czsgKytpKSB7XG4gICAgICBjb25zdCBtb3JwaEF0dHJpYnV0ZXNUb01lcmdlID0gW107XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1vcnBoQXR0cmlidXRlc1tuYW1lXS5sZW5ndGg7ICsraikge1xuICAgICAgICBtb3JwaEF0dHJpYnV0ZXNUb01lcmdlLnB1c2gobW9ycGhBdHRyaWJ1dGVzW25hbWVdW2pdW2ldKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lcmdlZE1vcnBoQXR0cmlidXRlID0gbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKG1vcnBoQXR0cmlidXRlc1RvTWVyZ2UpO1xuICAgICAgaWYgKCFtZXJnZWRNb3JwaEF0dHJpYnV0ZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aGlsZSB0cnlpbmcgdG8gbWVyZ2UgdGhlIFwiICsgbmFtZSArIFwiIG1vcnBoQXR0cmlidXRlLlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdLnB1c2gobWVyZ2VkTW9ycGhBdHRyaWJ1dGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VkR2VvbWV0cnk7XG59O1xuY29uc3QgbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXMpID0+IHtcbiAgbGV0IFR5cGVkQXJyYXkgPSB2b2lkIDA7XG4gIGxldCBpdGVtU2l6ZSA9IHZvaWQgMDtcbiAgbGV0IG5vcm1hbGl6ZWQgPSB2b2lkIDA7XG4gIGxldCBhcnJheUxlbmd0aCA9IDA7XG4gIGF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgIGlmIChUeXBlZEFycmF5ID09PSB2b2lkIDApIHtcbiAgICAgIFR5cGVkQXJyYXkgPSBhdHRyLmFycmF5LmNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBpZiAoVHlwZWRBcnJheSAhPT0gYXR0ci5hcnJheS5jb25zdHJ1Y3Rvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKCkgZmFpbGVkLiBCdWZmZXJBdHRyaWJ1dGUuYXJyYXkgbXVzdCBiZSBvZiBjb25zaXN0ZW50IGFycmF5IHR5cGVzIGFjcm9zcyBtYXRjaGluZyBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpdGVtU2l6ZSA9PT0gdm9pZCAwKVxuICAgICAgaXRlbVNpemUgPSBhdHRyLml0ZW1TaXplO1xuICAgIGlmIChpdGVtU2l6ZSAhPT0gYXR0ci5pdGVtU2l6ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKCkgZmFpbGVkLiBCdWZmZXJBdHRyaWJ1dGUuaXRlbVNpemUgbXVzdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBtYXRjaGluZyBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemVkID09PSB2b2lkIDApXG4gICAgICBub3JtYWxpemVkID0gYXR0ci5ub3JtYWxpemVkO1xuICAgIGlmIChub3JtYWxpemVkICE9PSBhdHRyLm5vcm1hbGl6ZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyQXR0cmlidXRlcygpIGZhaWxlZC4gQnVmZmVyQXR0cmlidXRlLm5vcm1hbGl6ZWQgbXVzdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBtYXRjaGluZyBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFycmF5TGVuZ3RoICs9IGF0dHIuYXJyYXkubGVuZ3RoO1xuICB9KTtcbiAgaWYgKFR5cGVkQXJyYXkgJiYgaXRlbVNpemUpIHtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGFycmF5TGVuZ3RoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBhdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICAgIGFycmF5LnNldChhdHRyLmFycmF5LCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGF0dHIuYXJyYXkubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG4gIH1cbn07XG5jb25zdCBpbnRlcmxlYXZlQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzKSA9PiB7XG4gIGxldCBUeXBlZEFycmF5ID0gdm9pZCAwO1xuICBsZXQgYXJyYXlMZW5ndGggPSAwO1xuICBsZXQgc3RyaWRlID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV07XG4gICAgaWYgKFR5cGVkQXJyYXkgPT09IHZvaWQgMClcbiAgICAgIFR5cGVkQXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3I7XG4gICAgaWYgKFR5cGVkQXJyYXkgIT09IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkF0dHJpYnV0ZUJ1ZmZlcnMgb2YgZGlmZmVyZW50IHR5cGVzIGNhbm5vdCBiZSBpbnRlcmxlYXZlZFwiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhcnJheUxlbmd0aCArPSBhdHRyaWJ1dGUuYXJyYXkubGVuZ3RoO1xuICAgIHN0cmlkZSArPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gIH1cbiAgY29uc3QgaW50ZXJsZWF2ZWRCdWZmZXIgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXIobmV3IFR5cGVkQXJyYXkoYXJyYXlMZW5ndGgpLCBzdHJpZGUpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgcmVzID0gW107XG4gIGNvbnN0IGdldHRlcnMgPSBbXCJnZXRYXCIsIFwiZ2V0WVwiLCBcImdldFpcIiwgXCJnZXRXXCJdO1xuICBjb25zdCBzZXR0ZXJzID0gW1wic2V0WFwiLCBcInNldFlcIiwgXCJzZXRaXCIsIFwic2V0V1wiXTtcbiAgZm9yIChsZXQgaiA9IDAsIGwgPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbal07XG4gICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgY29uc3QgY291bnQgPSBhdHRyaWJ1dGUuY291bnQ7XG4gICAgY29uc3QgaWJhID0gbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKGludGVybGVhdmVkQnVmZmVyLCBpdGVtU2l6ZSwgb2Zmc2V0LCBhdHRyaWJ1dGUubm9ybWFsaXplZCk7XG4gICAgcmVzLnB1c2goaWJhKTtcbiAgICBvZmZzZXQgKz0gaXRlbVNpemU7XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb3VudDsgYysrKSB7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGl0ZW1TaXplOyBrKyspIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gZ2V0V2l0aEtleShpYmEsIHNldHRlcnNba10pO1xuICAgICAgICBjb25zdCBnZXQgPSBnZXRXaXRoS2V5KGF0dHJpYnV0ZSwgZ2V0dGVyc1trXSk7XG4gICAgICAgIHNldChjLCBnZXQoYykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmZ1bmN0aW9uIGVzdGltYXRlQnl0ZXNVc2VkKGdlb21ldHJ5KSB7XG4gIGxldCBtZW0gPSAwO1xuICBmb3IgKGxldCBuYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBhdHRyID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIG1lbSArPSBhdHRyLmNvdW50ICogYXR0ci5pdGVtU2l6ZSAqIGF0dHIuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gIH1cbiAgY29uc3QgaW5kaWNlcyA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gIG1lbSArPSBpbmRpY2VzID8gaW5kaWNlcy5jb3VudCAqIGluZGljZXMuaXRlbVNpemUgKiBpbmRpY2VzLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UIDogMDtcbiAgcmV0dXJuIG1lbTtcbn1cbmZ1bmN0aW9uIG1lcmdlVmVydGljZXMoZ2VvbWV0cnksIHRvbGVyYW5jZSA9IDFlLTQpIHtcbiAgdG9sZXJhbmNlID0gTWF0aC5tYXgodG9sZXJhbmNlLCBOdW1iZXIuRVBTSUxPTik7XG4gIGNvbnN0IGhhc2hUb0luZGV4ID0ge307XG4gIGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuICBjb25zdCBwb3NpdGlvbnMgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiKTtcbiAgY29uc3QgdmVydGV4Q291bnQgPSBpbmRpY2VzID8gaW5kaWNlcy5jb3VudCA6IHBvc2l0aW9ucy5jb3VudDtcbiAgbGV0IG5leHRJbmRleCA9IDA7XG4gIGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0gT2JqZWN0LmtleXMoZ2VvbWV0cnkuYXR0cmlidXRlcyk7XG4gIGNvbnN0IGF0dHJBcnJheXMgPSB7fTtcbiAgY29uc3QgbW9ycGhBdHRyc0FycmF5cyA9IHt9O1xuICBjb25zdCBuZXdJbmRpY2VzID0gW107XG4gIGNvbnN0IGdldHRlcnMgPSBbXCJnZXRYXCIsIFwiZ2V0WVwiLCBcImdldFpcIiwgXCJnZXRXXCJdO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tpXTtcbiAgICBhdHRyQXJyYXlzW25hbWVdID0gW107XG4gICAgY29uc3QgbW9ycGhBdHRyID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdO1xuICAgIGlmIChtb3JwaEF0dHIpIHtcbiAgICAgIG1vcnBoQXR0cnNBcnJheXNbbmFtZV0gPSBuZXcgQXJyYXkobW9ycGhBdHRyLmxlbmd0aCkuZmlsbCgwKS5tYXAoKCkgPT4gW10pO1xuICAgIH1cbiAgfVxuICBjb25zdCBkZWNpbWFsU2hpZnQgPSBNYXRoLmxvZzEwKDEgLyB0b2xlcmFuY2UpO1xuICBjb25zdCBzaGlmdE11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgZGVjaW1hbFNoaWZ0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSsrKSB7XG4gICAgY29uc3QgaW5kZXggPSBpbmRpY2VzID8gaW5kaWNlcy5nZXRYKGkpIDogaTtcbiAgICBsZXQgaGFzaCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaiA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tqXTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpdGVtU2l6ZTsgaysrKSB7XG4gICAgICAgIGhhc2ggKz0gYCR7fn4oYXR0cmlidXRlW2dldHRlcnNba11dKGluZGV4KSAqIHNoaWZ0TXVsdGlwbGllcil9LGA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNoIGluIGhhc2hUb0luZGV4KSB7XG4gICAgICBuZXdJbmRpY2VzLnB1c2goaGFzaFRvSW5kZXhbaGFzaF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBqID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbal07XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgY29uc3QgbW9ycGhBdHRyID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICAgICAgY29uc3QgbmV3YXJyYXkgPSBhdHRyQXJyYXlzW25hbWVdO1xuICAgICAgICBjb25zdCBuZXdNb3JwaEFycmF5cyA9IG1vcnBoQXR0cnNBcnJheXNbbmFtZV07XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaXRlbVNpemU7IGsrKykge1xuICAgICAgICAgIGNvbnN0IGdldHRlckZ1bmMgPSBnZXR0ZXJzW2tdO1xuICAgICAgICAgIG5ld2FycmF5LnB1c2goYXR0cmlidXRlW2dldHRlckZ1bmNdKGluZGV4KSk7XG4gICAgICAgICAgaWYgKG1vcnBoQXR0cikge1xuICAgICAgICAgICAgZm9yIChsZXQgbSA9IDAsIG1sID0gbW9ycGhBdHRyLmxlbmd0aDsgbSA8IG1sOyBtKyspIHtcbiAgICAgICAgICAgICAgbmV3TW9ycGhBcnJheXNbbV0ucHVzaChtb3JwaEF0dHJbbV1bZ2V0dGVyRnVuY10oaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhhc2hUb0luZGV4W2hhc2hdID0gbmV4dEluZGV4O1xuICAgICAgbmV3SW5kaWNlcy5wdXNoKG5leHRJbmRleCk7XG4gICAgICBuZXh0SW5kZXgrKztcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gZ2VvbWV0cnkuY2xvbmUoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbaV07XG4gICAgY29uc3Qgb2xkQXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBvbGRBdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IoYXR0ckFycmF5c1tuYW1lXSk7XG4gICAgY29uc3QgYXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShidWZmZXIsIG9sZEF0dHJpYnV0ZS5pdGVtU2l6ZSwgb2xkQXR0cmlidXRlLm5vcm1hbGl6ZWQpO1xuICAgIHJlc3VsdC5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cmlidXRlKTtcbiAgICBpZiAobmFtZSBpbiBtb3JwaEF0dHJzQXJyYXlzKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1vcnBoQXR0cnNBcnJheXNbbmFtZV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3Qgb2xkTW9ycGhBdHRyaWJ1dGUgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV1bal07XG4gICAgICAgIGNvbnN0IGJ1ZmZlcjIgPSBuZXcgb2xkTW9ycGhBdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IobW9ycGhBdHRyc0FycmF5c1tuYW1lXVtqXSk7XG4gICAgICAgIGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShidWZmZXIyLCBvbGRNb3JwaEF0dHJpYnV0ZS5pdGVtU2l6ZSwgb2xkTW9ycGhBdHRyaWJ1dGUubm9ybWFsaXplZCk7XG4gICAgICAgIHJlc3VsdC5tb3JwaEF0dHJpYnV0ZXNbbmFtZV1bal0gPSBtb3JwaEF0dHJpYnV0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVzdWx0LnNldEluZGV4KG5ld0luZGljZXMpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9UcmlhbmdsZXNEcmF3TW9kZShnZW9tZXRyeSwgZHJhd01vZGUpIHtcbiAgaWYgKGRyYXdNb2RlID09PSBUcmlhbmdsZXNEcmF3TW9kZSkge1xuICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBHZW9tZXRyeSBhbHJlYWR5IGRlZmluZWQgYXMgdHJpYW5nbGVzLlwiKTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbiAgaWYgKGRyYXdNb2RlID09PSBUcmlhbmdsZUZhbkRyYXdNb2RlIHx8IGRyYXdNb2RlID09PSBUcmlhbmdsZVN0cmlwRHJhd01vZGUpIHtcbiAgICBsZXQgaW5kZXggPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuICAgIGlmIChpbmRleCA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgaW5kaWNlcyA9IFtdO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiKTtcbiAgICAgIGlmIChwb3NpdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb24uY291bnQ7IGkrKykge1xuICAgICAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICBnZW9tZXRyeS5zZXRJbmRleChpbmRpY2VzKTtcbiAgICAgICAgaW5kZXggPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmRlZmluZWQgcG9zaXRpb24gYXR0cmlidXRlLiBQcm9jZXNzaW5nIG5vdCBwb3NzaWJsZS5cIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZ2VvbWV0cnk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG51bWJlck9mVHJpYW5nbGVzID0gaW5kZXguY291bnQgLSAyO1xuICAgIGNvbnN0IG5ld0luZGljZXMgPSBbXTtcbiAgICBpZiAoaW5kZXgpIHtcbiAgICAgIGlmIChkcmF3TW9kZSA9PT0gVHJpYW5nbGVGYW5EcmF3TW9kZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBudW1iZXJPZlRyaWFuZ2xlczsgaSsrKSB7XG4gICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoMCkpO1xuICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkpKTtcbiAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mVHJpYW5nbGVzOyBpKyspIHtcbiAgICAgICAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAxKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMikpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDEpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld0luZGljZXMubGVuZ3RoIC8gMyAhPT0gbnVtYmVyT2ZUcmlhbmdsZXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5hYmxlIHRvIGdlbmVyYXRlIGNvcnJlY3QgYW1vdW50IG9mIHRyaWFuZ2xlcy5cIik7XG4gICAgfVxuICAgIGNvbnN0IG5ld0dlb21ldHJ5ID0gZ2VvbWV0cnkuY2xvbmUoKTtcbiAgICBuZXdHZW9tZXRyeS5zZXRJbmRleChuZXdJbmRpY2VzKTtcbiAgICBuZXdHZW9tZXRyeS5jbGVhckdyb3VwcygpO1xuICAgIHJldHVybiBuZXdHZW9tZXRyeTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVua25vd24gZHJhdyBtb2RlOlwiLCBkcmF3TW9kZSk7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlTW9ycGhlZEF0dHJpYnV0ZXMob2JqZWN0KSB7XG4gIGlmIChvYmplY3QuZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSAhPT0gdHJ1ZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiBHZW9tZXRyeSBpcyBub3Qgb2YgdHlwZSBCdWZmZXJHZW9tZXRyeS5cIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgX3ZBID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3ZCID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3ZDID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3RlbXBBID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3RlbXBCID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3RlbXBDID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX21vcnBoQSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF9tb3JwaEIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfbW9ycGhDID0gbmV3IFZlY3RvcjMoKTtcbiAgZnVuY3Rpb24gX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKG9iamVjdDIsIG1hdGVyaWFsMiwgYXR0cmlidXRlLCBtb3JwaEF0dHJpYnV0ZSwgbW9ycGhUYXJnZXRzUmVsYXRpdmUyLCBhMiwgYjIsIGMyLCBtb2RpZmllZEF0dHJpYnV0ZUFycmF5KSB7XG4gICAgX3ZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBhMik7XG4gICAgX3ZCLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBiMik7XG4gICAgX3ZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBjMik7XG4gICAgY29uc3QgbW9ycGhJbmZsdWVuY2VzID0gb2JqZWN0Mi5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG4gICAgaWYgKFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbWF0ZXJpYWwyLm1vcnBoVGFyZ2V0cyAmJiBtb3JwaEF0dHJpYnV0ZSAmJiBtb3JwaEluZmx1ZW5jZXNcbiAgICApIHtcbiAgICAgIF9tb3JwaEEuc2V0KDAsIDAsIDApO1xuICAgICAgX21vcnBoQi5zZXQoMCwgMCwgMCk7XG4gICAgICBfbW9ycGhDLnNldCgwLCAwLCAwKTtcbiAgICAgIGZvciAobGV0IGkyID0gMCwgaWwyID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBpMiA8IGlsMjsgaTIrKykge1xuICAgICAgICBjb25zdCBpbmZsdWVuY2UgPSBtb3JwaEluZmx1ZW5jZXNbaTJdO1xuICAgICAgICBjb25zdCBtb3JwaCA9IG1vcnBoQXR0cmlidXRlW2kyXTtcbiAgICAgICAgaWYgKGluZmx1ZW5jZSA9PT0gMClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgX3RlbXBBLmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGgsIGEyKTtcbiAgICAgICAgX3RlbXBCLmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGgsIGIyKTtcbiAgICAgICAgX3RlbXBDLmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGgsIGMyKTtcbiAgICAgICAgaWYgKG1vcnBoVGFyZ2V0c1JlbGF0aXZlMikge1xuICAgICAgICAgIF9tb3JwaEEuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQSwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhCLmFkZFNjYWxlZFZlY3RvcihfdGVtcEIsIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQy5hZGRTY2FsZWRWZWN0b3IoX3RlbXBDLCBpbmZsdWVuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9tb3JwaEEuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQS5zdWIoX3ZBKSwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhCLmFkZFNjYWxlZFZlY3RvcihfdGVtcEIuc3ViKF92QiksIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQy5hZGRTY2FsZWRWZWN0b3IoX3RlbXBDLnN1YihfdkMpLCBpbmZsdWVuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfdkEuYWRkKF9tb3JwaEEpO1xuICAgICAgX3ZCLmFkZChfbW9ycGhCKTtcbiAgICAgIF92Qy5hZGQoX21vcnBoQyk7XG4gICAgfVxuICAgIGlmIChvYmplY3QyLmlzU2tpbm5lZE1lc2gpIHtcbiAgICAgIG9iamVjdDIuYm9uZVRyYW5zZm9ybShhMiwgX3ZBKTtcbiAgICAgIG9iamVjdDIuYm9uZVRyYW5zZm9ybShiMiwgX3ZCKTtcbiAgICAgIG9iamVjdDIuYm9uZVRyYW5zZm9ybShjMiwgX3ZDKTtcbiAgICB9XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVthMiAqIDMgKyAwXSA9IF92QS54O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYTIgKiAzICsgMV0gPSBfdkEueTtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2EyICogMyArIDJdID0gX3ZBLno7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtiMiAqIDMgKyAwXSA9IF92Qi54O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYjIgKiAzICsgMV0gPSBfdkIueTtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2IyICogMyArIDJdID0gX3ZCLno7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtjMiAqIDMgKyAwXSA9IF92Qy54O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYzIgKiAzICsgMV0gPSBfdkMueTtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2MyICogMyArIDJdID0gX3ZDLno7XG4gIH1cbiAgY29uc3QgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG4gIGNvbnN0IG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuICBsZXQgYSwgYiwgYztcbiAgY29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcbiAgY29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCBtb3JwaFBvc2l0aW9uID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuICBjb25zdCBub3JtYWxBdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbDtcbiAgY29uc3QgbW9ycGhOb3JtYWwgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcbiAgY29uc3QgZHJhd1JhbmdlID0gZ2VvbWV0cnkuZHJhd1JhbmdlO1xuICBsZXQgaSwgaiwgaWwsIGpsO1xuICBsZXQgZ3JvdXAsIGdyb3VwTWF0ZXJpYWw7XG4gIGxldCBzdGFydCwgZW5kO1xuICBjb25zdCBtb2RpZmllZFBvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCAqIHBvc2l0aW9uQXR0cmlidXRlLml0ZW1TaXplKTtcbiAgY29uc3QgbW9kaWZpZWROb3JtYWwgPSBuZXcgRmxvYXQzMkFycmF5KG5vcm1hbEF0dHJpYnV0ZS5jb3VudCAqIG5vcm1hbEF0dHJpYnV0ZS5pdGVtU2l6ZSk7XG4gIGlmIChpbmRleCAhPT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuICAgICAgZm9yIChpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsW2dyb3VwLm1hdGVyaWFsSW5kZXhdO1xuICAgICAgICBzdGFydCA9IE1hdGgubWF4KGdyb3VwLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihncm91cC5zdGFydCArIGdyb3VwLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgICBmb3IgKGogPSBzdGFydCwgamwgPSBlbmQ7IGogPCBqbDsgaiArPSAzKSB7XG4gICAgICAgICAgYSA9IGluZGV4LmdldFgoaik7XG4gICAgICAgICAgYiA9IGluZGV4LmdldFgoaiArIDEpO1xuICAgICAgICAgIGMgPSBpbmRleC5nZXRYKGogKyAyKTtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IE1hdGgubWF4KDAsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICBlbmQgPSBNYXRoLm1pbihpbmRleC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgIGZvciAoaSA9IHN0YXJ0LCBpbCA9IGVuZDsgaSA8IGlsOyBpICs9IDMpIHtcbiAgICAgICAgYSA9IGluZGV4LmdldFgoaSk7XG4gICAgICAgIGIgPSBpbmRleC5nZXRYKGkgKyAxKTtcbiAgICAgICAgYyA9IGluZGV4LmdldFgoaSArIDIpO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICApO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChwb3NpdGlvbkF0dHJpYnV0ZSAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbZ3JvdXAubWF0ZXJpYWxJbmRleF07XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICAgIGVuZCA9IE1hdGgubWluKGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICAgIGZvciAoaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMpIHtcbiAgICAgICAgICBhID0gajtcbiAgICAgICAgICBiID0gaiArIDE7XG4gICAgICAgICAgYyA9IGogKyAyO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgIGVuZCA9IE1hdGgubWluKHBvc2l0aW9uQXR0cmlidXRlLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMykge1xuICAgICAgICBhID0gaTtcbiAgICAgICAgYiA9IGkgKyAxO1xuICAgICAgICBjID0gaSArIDI7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICk7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IG1vcnBoZWRQb3NpdGlvbkF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG1vZGlmaWVkUG9zaXRpb24sIDMpO1xuICBjb25zdCBtb3JwaGVkTm9ybWFsQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobW9kaWZpZWROb3JtYWwsIDMpO1xuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICBtb3JwaGVkUG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgbW9ycGhlZE5vcm1hbEF0dHJpYnV0ZVxuICB9O1xufVxuZnVuY3Rpb24gdG9DcmVhc2VkTm9ybWFscyhnZW9tZXRyeSwgY3JlYXNlQW5nbGUgPSBNYXRoLlBJIC8gMykge1xuICBjb25zdCBjcmVhc2VEb3QgPSBNYXRoLmNvcyhjcmVhc2VBbmdsZSk7XG4gIGNvbnN0IGhhc2hNdWx0aXBsaWVyID0gKDEgKyAxZS0xMCkgKiAxMDA7XG4gIGNvbnN0IHZlcnRzID0gW25ldyBWZWN0b3IzKCksIG5ldyBWZWN0b3IzKCksIG5ldyBWZWN0b3IzKCldO1xuICBjb25zdCB0ZW1wVmVjMSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IHRlbXBWZWMyID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgdGVtcE5vcm0gPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCB0ZW1wTm9ybTIgPSBuZXcgVmVjdG9yMygpO1xuICBmdW5jdGlvbiBoYXNoVmVydGV4KHYpIHtcbiAgICBjb25zdCB4ID0gfn4odi54ICogaGFzaE11bHRpcGxpZXIpO1xuICAgIGNvbnN0IHkgPSB+fih2LnkgKiBoYXNoTXVsdGlwbGllcik7XG4gICAgY29uc3QgeiA9IH5+KHYueiAqIGhhc2hNdWx0aXBsaWVyKTtcbiAgICByZXR1cm4gYCR7eH0sJHt5fSwke3p9YDtcbiAgfVxuICBjb25zdCByZXN1bHRHZW9tZXRyeSA9IGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkudG9Ob25JbmRleGVkKCkgOiBnZW9tZXRyeTtcbiAgY29uc3QgcG9zQXR0ciA9IHJlc3VsdEdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IHZlcnRleE1hcCA9IHt9O1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHBvc0F0dHIuY291bnQgLyAzOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgaTMgPSAzICogaTtcbiAgICBjb25zdCBhID0gdmVydHNbMF0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDApO1xuICAgIGNvbnN0IGIgPSB2ZXJ0c1sxXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMSk7XG4gICAgY29uc3QgYyA9IHZlcnRzWzJdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAyKTtcbiAgICB0ZW1wVmVjMS5zdWJWZWN0b3JzKGMsIGIpO1xuICAgIHRlbXBWZWMyLnN1YlZlY3RvcnMoYSwgYik7XG4gICAgY29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKS5jcm9zc1ZlY3RvcnModGVtcFZlYzEsIHRlbXBWZWMyKS5ub3JtYWxpemUoKTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IDM7IG4rKykge1xuICAgICAgY29uc3QgdmVydCA9IHZlcnRzW25dO1xuICAgICAgY29uc3QgaGFzaCA9IGhhc2hWZXJ0ZXgodmVydCk7XG4gICAgICBpZiAoIShoYXNoIGluIHZlcnRleE1hcCkpIHtcbiAgICAgICAgdmVydGV4TWFwW2hhc2hdID0gW107XG4gICAgICB9XG4gICAgICB2ZXJ0ZXhNYXBbaGFzaF0ucHVzaChub3JtYWwpO1xuICAgIH1cbiAgfVxuICBjb25zdCBub3JtYWxBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkocG9zQXR0ci5jb3VudCAqIDMpO1xuICBjb25zdCBub3JtQXR0ciA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUobm9ybWFsQXJyYXksIDMsIGZhbHNlKTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBwb3NBdHRyLmNvdW50IC8gMzsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGkzID0gMyAqIGk7XG4gICAgY29uc3QgYSA9IHZlcnRzWzBdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAwKTtcbiAgICBjb25zdCBiID0gdmVydHNbMV0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDEpO1xuICAgIGNvbnN0IGMgPSB2ZXJ0c1syXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMik7XG4gICAgdGVtcFZlYzEuc3ViVmVjdG9ycyhjLCBiKTtcbiAgICB0ZW1wVmVjMi5zdWJWZWN0b3JzKGEsIGIpO1xuICAgIHRlbXBOb3JtLmNyb3NzVmVjdG9ycyh0ZW1wVmVjMSwgdGVtcFZlYzIpLm5vcm1hbGl6ZSgpO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgMzsgbisrKSB7XG4gICAgICBjb25zdCB2ZXJ0ID0gdmVydHNbbl07XG4gICAgICBjb25zdCBoYXNoID0gaGFzaFZlcnRleCh2ZXJ0KTtcbiAgICAgIGNvbnN0IG90aGVyTm9ybWFscyA9IHZlcnRleE1hcFtoYXNoXTtcbiAgICAgIHRlbXBOb3JtMi5zZXQoMCwgMCwgMCk7XG4gICAgICBmb3IgKGxldCBrID0gMCwgbGsgPSBvdGhlck5vcm1hbHMubGVuZ3RoOyBrIDwgbGs7IGsrKykge1xuICAgICAgICBjb25zdCBvdGhlck5vcm0gPSBvdGhlck5vcm1hbHNba107XG4gICAgICAgIGlmICh0ZW1wTm9ybS5kb3Qob3RoZXJOb3JtKSA+IGNyZWFzZURvdCkge1xuICAgICAgICAgIHRlbXBOb3JtMi5hZGQob3RoZXJOb3JtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGVtcE5vcm0yLm5vcm1hbGl6ZSgpO1xuICAgICAgbm9ybUF0dHIuc2V0WFlaKGkzICsgbiwgdGVtcE5vcm0yLngsIHRlbXBOb3JtMi55LCB0ZW1wTm9ybTIueik7XG4gICAgfVxuICB9XG4gIHJlc3VsdEdlb21ldHJ5LnNldEF0dHJpYnV0ZShcIm5vcm1hbFwiLCBub3JtQXR0cik7XG4gIHJldHVybiByZXN1bHRHZW9tZXRyeTtcbn1cbmV4cG9ydCB7XG4gIGNvbXB1dGVNb3JwaGVkQXR0cmlidXRlcyxcbiAgZXN0aW1hdGVCeXRlc1VzZWQsXG4gIGludGVybGVhdmVBdHRyaWJ1dGVzLFxuICBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMsXG4gIG1lcmdlQnVmZmVyR2VvbWV0cmllcyxcbiAgbWVyZ2VWZXJ0aWNlcyxcbiAgdG9DcmVhc2VkTm9ybWFscyxcbiAgdG9UcmlhbmdsZXNEcmF3TW9kZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1ZmZlckdlb21ldHJ5VXRpbHMuanMubWFwXG4iXSwibmFtZXMiOlsiQnVmZmVyR2VvbWV0cnkiLCJCdWZmZXJBdHRyaWJ1dGUiLCJJbnRlcmxlYXZlZEJ1ZmZlciIsIkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlIiwiVHJpYW5nbGVzRHJhd01vZGUiLCJUcmlhbmdsZUZhbkRyYXdNb2RlIiwiVHJpYW5nbGVTdHJpcERyYXdNb2RlIiwiVmVjdG9yMyIsIkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUiLCJnZXRXaXRoS2V5IiwibWVyZ2VCdWZmZXJHZW9tZXRyaWVzIiwiZ2VvbWV0cmllcyIsInVzZUdyb3VwcyIsImlzSW5kZXhlZCIsImluZGV4IiwiYXR0cmlidXRlc1VzZWQiLCJTZXQiLCJPYmplY3QiLCJrZXlzIiwiYXR0cmlidXRlcyIsIm1vcnBoQXR0cmlidXRlc1VzZWQiLCJtb3JwaEF0dHJpYnV0ZXMiLCJtb3JwaFRhcmdldHNSZWxhdGl2ZSIsIm1lcmdlZEdlb21ldHJ5Iiwib2Zmc2V0IiwiZm9yRWFjaCIsImdlb20iLCJpIiwiYXR0cmlidXRlc0NvdW50IiwiY29uc29sZSIsImVycm9yIiwibmFtZSIsImhhcyIsInB1c2giLCJzaXplIiwidXNlckRhdGEiLCJtZXJnZWRVc2VyRGF0YSIsImNvdW50IiwicG9zaXRpb24iLCJhZGRHcm91cCIsImluZGV4T2Zmc2V0IiwibWVyZ2VkSW5kZXgiLCJqIiwiZ2V0WCIsInNldEluZGV4IiwibWVyZ2VkQXR0cmlidXRlIiwibWVyZ2VCdWZmZXJBdHRyaWJ1dGVzIiwic2V0QXR0cmlidXRlIiwibnVtTW9ycGhUYXJnZXRzIiwibGVuZ3RoIiwibW9ycGhBdHRyaWJ1dGVzVG9NZXJnZSIsIm1lcmdlZE1vcnBoQXR0cmlidXRlIiwiVHlwZWRBcnJheSIsIml0ZW1TaXplIiwibm9ybWFsaXplZCIsImFycmF5TGVuZ3RoIiwiYXR0ciIsImFycmF5IiwiY29uc3RydWN0b3IiLCJzZXQiLCJpbnRlcmxlYXZlQXR0cmlidXRlcyIsInN0cmlkZSIsImwiLCJhdHRyaWJ1dGUiLCJpbnRlcmxlYXZlZEJ1ZmZlciIsInJlcyIsImdldHRlcnMiLCJzZXR0ZXJzIiwiaWJhIiwiYyIsImsiLCJnZXQiLCJlc3RpbWF0ZUJ5dGVzVXNlZCIsImdlb21ldHJ5IiwibWVtIiwiZ2V0QXR0cmlidXRlIiwiQllURVNfUEVSX0VMRU1FTlQiLCJpbmRpY2VzIiwiZ2V0SW5kZXgiLCJtZXJnZVZlcnRpY2VzIiwidG9sZXJhbmNlIiwiTWF0aCIsIm1heCIsIk51bWJlciIsIkVQU0lMT04iLCJoYXNoVG9JbmRleCIsInBvc2l0aW9ucyIsInZlcnRleENvdW50IiwibmV4dEluZGV4IiwiYXR0cmlidXRlTmFtZXMiLCJhdHRyQXJyYXlzIiwibW9ycGhBdHRyc0FycmF5cyIsIm5ld0luZGljZXMiLCJtb3JwaEF0dHIiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJkZWNpbWFsU2hpZnQiLCJsb2cxMCIsInNoaWZ0TXVsdGlwbGllciIsInBvdyIsImhhc2giLCJuZXdhcnJheSIsIm5ld01vcnBoQXJyYXlzIiwiZ2V0dGVyRnVuYyIsIm0iLCJtbCIsInJlc3VsdCIsImNsb25lIiwib2xkQXR0cmlidXRlIiwiYnVmZmVyIiwib2xkTW9ycGhBdHRyaWJ1dGUiLCJidWZmZXIyIiwibW9ycGhBdHRyaWJ1dGUiLCJ0b1RyaWFuZ2xlc0RyYXdNb2RlIiwiZHJhd01vZGUiLCJ3YXJuIiwibnVtYmVyT2ZUcmlhbmdsZXMiLCJuZXdHZW9tZXRyeSIsImNsZWFyR3JvdXBzIiwiY29tcHV0ZU1vcnBoZWRBdHRyaWJ1dGVzIiwib2JqZWN0IiwiaXNCdWZmZXJHZW9tZXRyeSIsIl92QSIsIl92QiIsIl92QyIsIl90ZW1wQSIsIl90ZW1wQiIsIl90ZW1wQyIsIl9tb3JwaEEiLCJfbW9ycGhCIiwiX21vcnBoQyIsIl9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YSIsIm9iamVjdDIiLCJtYXRlcmlhbDIiLCJtb3JwaFRhcmdldHNSZWxhdGl2ZTIiLCJhMiIsImIyIiwiYzIiLCJtb2RpZmllZEF0dHJpYnV0ZUFycmF5IiwiZnJvbUJ1ZmZlckF0dHJpYnV0ZSIsIm1vcnBoSW5mbHVlbmNlcyIsIm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyIsIm1vcnBoVGFyZ2V0cyIsImkyIiwiaWwyIiwiaW5mbHVlbmNlIiwibW9ycGgiLCJhZGRTY2FsZWRWZWN0b3IiLCJzdWIiLCJhZGQiLCJpc1NraW5uZWRNZXNoIiwiYm9uZVRyYW5zZm9ybSIsIngiLCJ5IiwieiIsIm1hdGVyaWFsIiwiYSIsImIiLCJwb3NpdGlvbkF0dHJpYnV0ZSIsIm1vcnBoUG9zaXRpb24iLCJub3JtYWxBdHRyaWJ1dGUiLCJub3JtYWwiLCJtb3JwaE5vcm1hbCIsImdyb3VwcyIsImRyYXdSYW5nZSIsImlsIiwiamwiLCJncm91cCIsImdyb3VwTWF0ZXJpYWwiLCJzdGFydCIsImVuZCIsIm1vZGlmaWVkUG9zaXRpb24iLCJGbG9hdDMyQXJyYXkiLCJtb2RpZmllZE5vcm1hbCIsImlzQXJyYXkiLCJtYXRlcmlhbEluZGV4IiwibWluIiwibW9ycGhlZFBvc2l0aW9uQXR0cmlidXRlIiwibW9ycGhlZE5vcm1hbEF0dHJpYnV0ZSIsInRvQ3JlYXNlZE5vcm1hbHMiLCJjcmVhc2VBbmdsZSIsIlBJIiwiY3JlYXNlRG90IiwiY29zIiwiaGFzaE11bHRpcGxpZXIiLCJ2ZXJ0cyIsInRlbXBWZWMxIiwidGVtcFZlYzIiLCJ0ZW1wTm9ybSIsInRlbXBOb3JtMiIsImhhc2hWZXJ0ZXgiLCJ2IiwicmVzdWx0R2VvbWV0cnkiLCJ0b05vbkluZGV4ZWQiLCJwb3NBdHRyIiwidmVydGV4TWFwIiwiaTMiLCJzdWJWZWN0b3JzIiwiY3Jvc3NWZWN0b3JzIiwibm9ybWFsaXplIiwibiIsInZlcnQiLCJub3JtYWxBcnJheSIsIm5vcm1BdHRyIiwib3RoZXJOb3JtYWxzIiwibGsiLCJvdGhlck5vcm0iLCJkb3QiLCJzZXRYWVoiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/utils/SkeletonUtils.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/utils/SkeletonUtils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SkeletonUtils: () => (/* binding */ SkeletonUtils)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nfunction retarget(target, source, options = {}) {\n    const pos = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion(), scale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), bindBoneMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), relativeMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4(), globalMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n    options.preserveMatrix = options.preserveMatrix !== void 0 ? options.preserveMatrix : true;\n    options.preservePosition = options.preservePosition !== void 0 ? options.preservePosition : true;\n    options.preserveHipPosition = options.preserveHipPosition !== void 0 ? options.preserveHipPosition : false;\n    options.useTargetMatrix = options.useTargetMatrix !== void 0 ? options.useTargetMatrix : false;\n    options.hip = options.hip !== void 0 ? options.hip : \"hip\";\n    options.names = options.names || {};\n    const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source), bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n    let bindBones, bone, name, boneTo, bonesPosition;\n    if (target.isObject3D) {\n        target.skeleton.pose();\n    } else {\n        options.useTargetMatrix = true;\n        options.preserveMatrix = false;\n    }\n    if (options.preservePosition) {\n        bonesPosition = [];\n        for(let i = 0; i < bones.length; i++){\n            bonesPosition.push(bones[i].position.clone());\n        }\n    }\n    if (options.preserveMatrix) {\n        target.updateMatrixWorld();\n        target.matrixWorld.identity();\n        for(let i = 0; i < target.children.length; ++i){\n            target.children[i].updateMatrixWorld(true);\n        }\n    }\n    if (options.offsets) {\n        bindBones = [];\n        for(let i = 0; i < bones.length; ++i){\n            bone = bones[i];\n            name = options.names[bone.name] || bone.name;\n            if (options.offsets[name]) {\n                bone.matrix.multiply(options.offsets[name]);\n                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n                bone.updateMatrixWorld();\n            }\n            bindBones.push(bone.matrixWorld.clone());\n        }\n    }\n    for(let i = 0; i < bones.length; ++i){\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = getBoneByName(name, sourceBones);\n        globalMatrix.copy(bone.matrixWorld);\n        if (boneTo) {\n            boneTo.updateMatrixWorld();\n            if (options.useTargetMatrix) {\n                relativeMatrix.copy(boneTo.matrixWorld);\n            } else {\n                relativeMatrix.copy(target.matrixWorld).invert();\n                relativeMatrix.multiply(boneTo.matrixWorld);\n            }\n            scale.setFromMatrixScale(relativeMatrix);\n            relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n            globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n            if (target.isObject3D) {\n                const boneIndex = bones.indexOf(bone), wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n                globalMatrix.multiply(wBindMatrix);\n            }\n            globalMatrix.copyPosition(relativeMatrix);\n        }\n        if (bone.parent && bone.parent.isBone) {\n            bone.matrix.copy(bone.parent.matrixWorld).invert();\n            bone.matrix.multiply(globalMatrix);\n        } else {\n            bone.matrix.copy(globalMatrix);\n        }\n        if (options.preserveHipPosition && name === options.hip) {\n            bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n        }\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n    }\n    if (options.preservePosition) {\n        for(let i = 0; i < bones.length; ++i){\n            bone = bones[i];\n            name = options.names[bone.name] || bone.name;\n            if (name !== options.hip) {\n                bone.position.copy(bonesPosition[i]);\n            }\n        }\n    }\n    if (options.preserveMatrix) {\n        target.updateMatrixWorld(true);\n    }\n}\nfunction retargetClip(target, source, clip, options = {}) {\n    options.useFirstFramePosition = options.useFirstFramePosition !== void 0 ? options.useFirstFramePosition : false;\n    options.fps = options.fps !== void 0 ? options.fps : 30;\n    options.names = options.names || [];\n    if (!source.isObject3D) {\n        source = getHelperFromSkeleton(source);\n    }\n    const numFrames = Math.round(clip.duration * (options.fps / 1e3) * 1e3), delta = 1 / options.fps, convertedTracks = [], mixer = new three__WEBPACK_IMPORTED_MODULE_0__.AnimationMixer(source), bones = getBones(target.skeleton), boneDatas = [];\n    let positionOffset, bone, boneTo, boneData, name;\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n    source.updateMatrixWorld();\n    for(let i = 0; i < numFrames; ++i){\n        const time = i * delta;\n        retarget(target, source, options);\n        for(let j = 0; j < bones.length; ++j){\n            name = options.names[bones[j].name] || bones[j].name;\n            boneTo = getBoneByName(name, source.skeleton);\n            if (boneTo) {\n                bone = bones[j];\n                boneData = boneDatas[j] = boneDatas[j] || {\n                    bone\n                };\n                if (options.hip === name) {\n                    if (!boneData.pos) {\n                        boneData.pos = {\n                            times: new Float32Array(numFrames),\n                            values: new Float32Array(numFrames * 3)\n                        };\n                    }\n                    if (options.useFirstFramePosition) {\n                        if (i === 0) {\n                            positionOffset = bone.position.clone();\n                        }\n                        bone.position.sub(positionOffset);\n                    }\n                    boneData.pos.times[i] = time;\n                    bone.position.toArray(boneData.pos.values, i * 3);\n                }\n                if (!boneData.quat) {\n                    boneData.quat = {\n                        times: new Float32Array(numFrames),\n                        values: new Float32Array(numFrames * 4)\n                    };\n                }\n                boneData.quat.times[i] = time;\n                bone.quaternion.toArray(boneData.quat.values, i * 4);\n            }\n        }\n        mixer.update(delta);\n        source.updateMatrixWorld();\n    }\n    for(let i = 0; i < boneDatas.length; ++i){\n        boneData = boneDatas[i];\n        if (boneData) {\n            if (boneData.pos) {\n                convertedTracks.push(new three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack(\".bones[\" + boneData.bone.name + \"].position\", boneData.pos.times, boneData.pos.values));\n            }\n            convertedTracks.push(new three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack(\".bones[\" + boneData.bone.name + \"].quaternion\", boneData.quat.times, boneData.quat.values));\n        }\n    }\n    mixer.uncacheAction(clip);\n    return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(clip.name, -1, convertedTracks);\n}\nfunction clone(source) {\n    const sourceLookup = /* @__PURE__ */ new Map();\n    const cloneLookup = /* @__PURE__ */ new Map();\n    const clone2 = source.clone();\n    parallelTraverse(source, clone2, function(sourceNode, clonedNode) {\n        sourceLookup.set(clonedNode, sourceNode);\n        cloneLookup.set(sourceNode, clonedNode);\n    });\n    clone2.traverse(function(node) {\n        if (!node.isSkinnedMesh) return;\n        const clonedMesh = node;\n        const sourceMesh = sourceLookup.get(node);\n        const sourceBones = sourceMesh.skeleton.bones;\n        clonedMesh.skeleton = sourceMesh.skeleton.clone();\n        clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n        clonedMesh.skeleton.bones = sourceBones.map(function(bone) {\n            return cloneLookup.get(bone);\n        });\n        clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n    return clone2;\n}\nfunction getBoneByName(name, skeleton) {\n    for(let i = 0, bones = getBones(skeleton); i < bones.length; i++){\n        if (name === bones[i].name) return bones[i];\n    }\n}\nfunction getBones(skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\nfunction getHelperFromSkeleton(skeleton) {\n    const source = new three__WEBPACK_IMPORTED_MODULE_0__.SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n    return source;\n}\nfunction parallelTraverse(a, b, callback) {\n    callback(a, b);\n    for(let i = 0; i < a.children.length; i++){\n        parallelTraverse(a.children[i], b.children[i], callback);\n    }\n}\nconst SkeletonUtils = {\n    retarget,\n    retargetClip,\n    clone\n};\n //# sourceMappingURL=SkeletonUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL1NrZWxldG9uVXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0o7QUFDbEosU0FBU1EsU0FBU0MsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO0lBQzVDLE1BQU1DLE1BQU0sSUFBSVosMENBQU9BLElBQUlhLE9BQU8sSUFBSVosNkNBQVVBLElBQUlhLFFBQVEsSUFBSWQsMENBQU9BLElBQUllLGlCQUFpQixJQUFJYiwwQ0FBT0EsSUFBSWMsaUJBQWlCLElBQUlkLDBDQUFPQSxJQUFJZSxlQUFlLElBQUlmLDBDQUFPQTtJQUNyS1MsUUFBUU8sY0FBYyxHQUFHUCxRQUFRTyxjQUFjLEtBQUssS0FBSyxJQUFJUCxRQUFRTyxjQUFjLEdBQUc7SUFDdEZQLFFBQVFRLGdCQUFnQixHQUFHUixRQUFRUSxnQkFBZ0IsS0FBSyxLQUFLLElBQUlSLFFBQVFRLGdCQUFnQixHQUFHO0lBQzVGUixRQUFRUyxtQkFBbUIsR0FBR1QsUUFBUVMsbUJBQW1CLEtBQUssS0FBSyxJQUFJVCxRQUFRUyxtQkFBbUIsR0FBRztJQUNyR1QsUUFBUVUsZUFBZSxHQUFHVixRQUFRVSxlQUFlLEtBQUssS0FBSyxJQUFJVixRQUFRVSxlQUFlLEdBQUc7SUFDekZWLFFBQVFXLEdBQUcsR0FBR1gsUUFBUVcsR0FBRyxLQUFLLEtBQUssSUFBSVgsUUFBUVcsR0FBRyxHQUFHO0lBQ3JEWCxRQUFRWSxLQUFLLEdBQUdaLFFBQVFZLEtBQUssSUFBSSxDQUFDO0lBQ2xDLE1BQU1DLGNBQWNkLE9BQU9lLFVBQVUsR0FBR2YsT0FBT2dCLFFBQVEsQ0FBQ0MsS0FBSyxHQUFHQyxTQUFTbEIsU0FBU2lCLFFBQVFsQixPQUFPZ0IsVUFBVSxHQUFHaEIsT0FBT2lCLFFBQVEsQ0FBQ0MsS0FBSyxHQUFHQyxTQUFTbkI7SUFDL0ksSUFBSW9CLFdBQVdDLE1BQU1DLE1BQU1DLFFBQVFDO0lBQ25DLElBQUl4QixPQUFPZ0Is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RSxFQUFFNkUsRUFBRXJFLFFBQVEsQ0FBQ1IsRUFBRSxFQUFFOEU7SUFDakQ7QUFDRjtBQUNBLE1BQU1DLGdCQUFnQjtJQUFFMUc7SUFBVTJEO0lBQWM1QjtBQUFNO0FBR3BELENBQ0YseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vM0QtQUktRW5nbGlzaC8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvdXRpbHMvU2tlbGV0b25VdGlscy5qcz9iOTY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3RvcjMsIFF1YXRlcm5pb24sIE1hdHJpeDQsIEFuaW1hdGlvbk1peGVyLCBWZWN0b3JLZXlmcmFtZVRyYWNrLCBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaywgQW5pbWF0aW9uQ2xpcCwgU2tlbGV0b25IZWxwZXIgfSBmcm9tIFwidGhyZWVcIjtcbmZ1bmN0aW9uIHJldGFyZ2V0KHRhcmdldCwgc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcG9zID0gbmV3IFZlY3RvcjMoKSwgcXVhdCA9IG5ldyBRdWF0ZXJuaW9uKCksIHNjYWxlID0gbmV3IFZlY3RvcjMoKSwgYmluZEJvbmVNYXRyaXggPSBuZXcgTWF0cml4NCgpLCByZWxhdGl2ZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCksIGdsb2JhbE1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gIG9wdGlvbnMucHJlc2VydmVNYXRyaXggPSBvcHRpb25zLnByZXNlcnZlTWF0cml4ICE9PSB2b2lkIDAgPyBvcHRpb25zLnByZXNlcnZlTWF0cml4IDogdHJ1ZTtcbiAgb3B0aW9ucy5wcmVzZXJ2ZVBvc2l0aW9uID0gb3B0aW9ucy5wcmVzZXJ2ZVBvc2l0aW9uICE9PSB2b2lkIDAgPyBvcHRpb25zLnByZXNlcnZlUG9zaXRpb24gOiB0cnVlO1xuICBvcHRpb25zLnByZXNlcnZlSGlwUG9zaXRpb24gPSBvcHRpb25zLnByZXNlcnZlSGlwUG9zaXRpb24gIT09IHZvaWQgMCA/IG9wdGlvbnMucHJlc2VydmVIaXBQb3NpdGlvbiA6IGZhbHNlO1xuICBvcHRpb25zLnVzZVRhcmdldE1hdHJpeCA9IG9wdGlvbnMudXNlVGFyZ2V0TWF0cml4ICE9PSB2b2lkIDAgPyBvcHRpb25zLnVzZVRhcmdldE1hdHJpeCA6IGZhbHNlO1xuICBvcHRpb25zLmhpcCA9IG9wdGlvbnMuaGlwICE9PSB2b2lkIDAgPyBvcHRpb25zLmhpcCA6IFwiaGlwXCI7XG4gIG9wdGlvbnMubmFtZXMgPSBvcHRpb25zLm5hbWVzIHx8IHt9O1xuICBjb25zdCBzb3VyY2VCb25lcyA9IHNvdXJjZS5pc09iamVjdDNEID8gc291cmNlLnNrZWxldG9uLmJvbmVzIDogZ2V0Qm9uZXMoc291cmNlKSwgYm9uZXMgPSB0YXJnZXQuaXNPYmplY3QzRCA/IHRhcmdldC5za2VsZXRvbi5ib25lcyA6IGdldEJvbmVzKHRhcmdldCk7XG4gIGxldCBiaW5kQm9uZXMsIGJvbmUsIG5hbWUsIGJvbmVUbywgYm9uZXNQb3NpdGlvbjtcbiAgaWYgKHRhcmdldC5pc09iamVjdDNEKSB7XG4gICAgdGFyZ2V0LnNrZWxldG9uLnBvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLnVzZVRhcmdldE1hdHJpeCA9IHRydWU7XG4gICAgb3B0aW9ucy5wcmVzZXJ2ZU1hdHJpeCA9IGZhbHNlO1xuICB9XG4gIGlmIChvcHRpb25zLnByZXNlcnZlUG9zaXRpb24pIHtcbiAgICBib25lc1Bvc2l0aW9uID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib25lcy5sZW5ndGg7IGkrKykge1xuICAgICAgYm9uZXNQb3NpdGlvbi5wdXNoKGJvbmVzW2ldLnBvc2l0aW9uLmNsb25lKCkpO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5wcmVzZXJ2ZU1hdHJpeCkge1xuICAgIHRhcmdldC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgIHRhcmdldC5tYXRyaXhXb3JsZC5pZGVudGl0eSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0LmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICB0YXJnZXQuY2hpbGRyZW5baV0udXBkYXRlTWF0cml4V29ybGQodHJ1ZSk7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLm9mZnNldHMpIHtcbiAgICBiaW5kQm9uZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBib25lID0gYm9uZXNbaV07XG4gICAgICBuYW1lID0gb3B0aW9ucy5uYW1lc1tib25lLm5hbWVdIHx8IGJvbmUubmFtZTtcbiAgICAgIGlmIChvcHRpb25zLm9mZnNldHNbbmFtZV0pIHtcbiAgICAgICAgYm9uZS5tYXRyaXgubXVsdGlwbHkob3B0aW9ucy5vZmZzZXRzW25hbWVdKTtcbiAgICAgICAgYm9uZS5tYXRyaXguZGVjb21wb3NlKGJvbmUucG9zaXRpb24sIGJvbmUucXVhdGVybmlvbiwgYm9uZS5zY2FsZSk7XG4gICAgICAgIGJvbmUudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICAgIH1cbiAgICAgIGJpbmRCb25lcy5wdXNoKGJvbmUubWF0cml4V29ybGQuY2xvbmUoKSk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyArK2kpIHtcbiAgICBib25lID0gYm9uZXNbaV07XG4gICAgbmFtZSA9IG9wdGlvbnMubmFtZXNbYm9uZS5uYW1lXSB8fCBib25lLm5hbWU7XG4gICAgYm9uZVRvID0gZ2V0Qm9uZUJ5TmFtZShuYW1lLCBzb3VyY2VCb25lcyk7XG4gICAgZ2xvYmFsTWF0cml4LmNvcHkoYm9uZS5tYXRyaXhXb3JsZCk7XG4gICAgaWYgKGJvbmVUbykge1xuICAgICAgYm9uZVRvLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICBpZiAob3B0aW9ucy51c2VUYXJnZXRNYXRyaXgpIHtcbiAgICAgICAgcmVsYXRpdmVNYXRyaXguY29weShib25lVG8ubWF0cml4V29ybGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVsYXRpdmVNYXRyaXguY29weSh0YXJnZXQubWF0cml4V29ybGQpLmludmVydCgpO1xuICAgICAgICByZWxhdGl2ZU1hdHJpeC5tdWx0aXBseShib25lVG8ubWF0cml4V29ybGQpO1xuICAgICAgfVxuICAgICAgc2NhbGUuc2V0RnJvbU1hdHJpeFNjYWxlKHJlbGF0aXZlTWF0cml4KTtcbiAgICAgIHJlbGF0aXZlTWF0cml4LnNjYWxlKHNjYWxlLnNldCgxIC8gc2NhbGUueCwgMSAvIHNjYWxlLnksIDEgLyBzY2FsZS56KSk7XG4gICAgICBnbG9iYWxNYXRyaXgubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24ocXVhdC5zZXRGcm9tUm90YXRpb25NYXRyaXgocmVsYXRpdmVNYXRyaXgpKTtcbiAgICAgIGlmICh0YXJnZXQuaXNPYmplY3QzRCkge1xuICAgICAgICBjb25zdCBib25lSW5kZXggPSBib25lcy5pbmRleE9mKGJvbmUpLCB3QmluZE1hdHJpeCA9IGJpbmRCb25lcyA/IGJpbmRCb25lc1tib25lSW5kZXhdIDogYmluZEJvbmVNYXRyaXguY29weSh0YXJnZXQuc2tlbGV0b24uYm9uZUludmVyc2VzW2JvbmVJbmRleF0pLmludmVydCgpO1xuICAgICAgICBnbG9iYWxNYXRyaXgubXVsdGlwbHkod0JpbmRNYXRyaXgpO1xuICAgICAgfVxuICAgICAgZ2xvYmFsTWF0cml4LmNvcHlQb3NpdGlvbihyZWxhdGl2ZU1hdHJpeCk7XG4gICAgfVxuICAgIGlmIChib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUpIHtcbiAgICAgIGJvbmUubWF0cml4LmNvcHkoYm9uZS5wYXJlbnQubWF0cml4V29ybGQpLmludmVydCgpO1xuICAgICAgYm9uZS5tYXRyaXgubXVsdGlwbHkoZ2xvYmFsTWF0cml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9uZS5tYXRyaXguY29weShnbG9iYWxNYXRyaXgpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5wcmVzZXJ2ZUhpcFBvc2l0aW9uICYmIG5hbWUgPT09IG9wdGlvbnMuaGlwKSB7XG4gICAgICBib25lLm1hdHJpeC5zZXRQb3NpdGlvbihwb3Muc2V0KDAsIGJvbmUucG9zaXRpb24ueSwgMCkpO1xuICAgIH1cbiAgICBib25lLm1hdHJpeC5kZWNvbXBvc2UoYm9uZS5wb3NpdGlvbiwgYm9uZS5xdWF0ZXJuaW9uLCBib25lLnNjYWxlKTtcbiAgICBib25lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMucHJlc2VydmVQb3NpdGlvbikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9uZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJvbmUgPSBib25lc1tpXTtcbiAgICAgIG5hbWUgPSBvcHRpb25zLm5hbWVzW2JvbmUubmFtZV0gfHwgYm9uZS5uYW1lO1xuICAgICAgaWYgKG5hbWUgIT09IG9wdGlvbnMuaGlwKSB7XG4gICAgICAgIGJvbmUucG9zaXRpb24uY29weShib25lc1Bvc2l0aW9uW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMucHJlc2VydmVNYXRyaXgpIHtcbiAgICB0YXJnZXQudXBkYXRlTWF0cml4V29ybGQodHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJldGFyZ2V0Q2xpcCh0YXJnZXQsIHNvdXJjZSwgY2xpcCwgb3B0aW9ucyA9IHt9KSB7XG4gIG9wdGlvbnMudXNlRmlyc3RGcmFtZVBvc2l0aW9uID0gb3B0aW9ucy51c2VGaXJzdEZyYW1lUG9zaXRpb24gIT09IHZvaWQgMCA/IG9wdGlvbnMudXNlRmlyc3RGcmFtZVBvc2l0aW9uIDogZmFsc2U7XG4gIG9wdGlvbnMuZnBzID0gb3B0aW9ucy5mcHMgIT09IHZvaWQgMCA/IG9wdGlvbnMuZnBzIDogMzA7XG4gIG9wdGlvbnMubmFtZXMgPSBvcHRpb25zLm5hbWVzIHx8IFtdO1xuICBpZiAoIXNvdXJjZS5pc09iamVjdDNEKSB7XG4gICAgc291cmNlID0gZ2V0SGVscGVyRnJvbVNrZWxldG9uKHNvdXJjZSk7XG4gIH1cbiAgY29uc3QgbnVtRnJhbWVzID0gTWF0aC5yb3VuZChjbGlwLmR1cmF0aW9uICogKG9wdGlvbnMuZnBzIC8gMWUzKSAqIDFlMyksIGRlbHRhID0gMSAvIG9wdGlvbnMuZnBzLCBjb252ZXJ0ZWRUcmFja3MgPSBbXSwgbWl4ZXIgPSBuZXcgQW5pbWF0aW9uTWl4ZXIoc291cmNlKSwgYm9uZXMgPSBnZXRCb25lcyh0YXJnZXQuc2tlbGV0b24pLCBib25lRGF0YXMgPSBbXTtcbiAgbGV0IHBvc2l0aW9uT2Zmc2V0LCBib25lLCBib25lVG8sIGJvbmVEYXRhLCBuYW1lO1xuICBtaXhlci5jbGlwQWN0aW9uKGNsaXApLnBsYXkoKTtcbiAgbWl4ZXIudXBkYXRlKDApO1xuICBzb3VyY2UudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1GcmFtZXM7ICsraSkge1xuICAgIGNvbnN0IHRpbWUgPSBpICogZGVsdGE7XG4gICAgcmV0YXJnZXQodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgYm9uZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIG5hbWUgPSBvcHRpb25zLm5hbWVzW2JvbmVzW2pdLm5hbWVdIHx8IGJvbmVzW2pdLm5hbWU7XG4gICAgICBib25lVG8gPSBnZXRCb25lQnlOYW1lKG5hbWUsIHNvdXJjZS5za2VsZXRvbik7XG4gICAgICBpZiAoYm9uZVRvKSB7XG4gICAgICAgIGJvbmUgPSBib25lc1tqXTtcbiAgICAgICAgYm9uZURhdGEgPSBib25lRGF0YXNbal0gPSBib25lRGF0YXNbal0gfHwgeyBib25lIH07XG4gICAgICAgIGlmIChvcHRpb25zLmhpcCA9PT0gbmFtZSkge1xuICAgICAgICAgIGlmICghYm9uZURhdGEucG9zKSB7XG4gICAgICAgICAgICBib25lRGF0YS5wb3MgPSB7XG4gICAgICAgICAgICAgIHRpbWVzOiBuZXcgRmxvYXQzMkFycmF5KG51bUZyYW1lcyksXG4gICAgICAgICAgICAgIHZhbHVlczogbmV3IEZsb2F0MzJBcnJheShudW1GcmFtZXMgKiAzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMudXNlRmlyc3RGcmFtZVBvc2l0aW9uKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICBwb3NpdGlvbk9mZnNldCA9IGJvbmUucG9zaXRpb24uY2xvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvbmUucG9zaXRpb24uc3ViKHBvc2l0aW9uT2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm9uZURhdGEucG9zLnRpbWVzW2ldID0gdGltZTtcbiAgICAgICAgICBib25lLnBvc2l0aW9uLnRvQXJyYXkoYm9uZURhdGEucG9zLnZhbHVlcywgaSAqIDMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYm9uZURhdGEucXVhdCkge1xuICAgICAgICAgIGJvbmVEYXRhLnF1YXQgPSB7XG4gICAgICAgICAgICB0aW1lczogbmV3IEZsb2F0MzJBcnJheShudW1GcmFtZXMpLFxuICAgICAgICAgICAgdmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KG51bUZyYW1lcyAqIDQpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBib25lRGF0YS5xdWF0LnRpbWVzW2ldID0gdGltZTtcbiAgICAgICAgYm9uZS5xdWF0ZXJuaW9uLnRvQXJyYXkoYm9uZURhdGEucXVhdC52YWx1ZXMsIGkgKiA0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWl4ZXIudXBkYXRlKGRlbHRhKTtcbiAgICBzb3VyY2UudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJvbmVEYXRhcy5sZW5ndGg7ICsraSkge1xuICAgIGJvbmVEYXRhID0gYm9uZURhdGFzW2ldO1xuICAgIGlmIChib25lRGF0YSkge1xuICAgICAgaWYgKGJvbmVEYXRhLnBvcykge1xuICAgICAgICBjb252ZXJ0ZWRUcmFja3MucHVzaChcbiAgICAgICAgICBuZXcgVmVjdG9yS2V5ZnJhbWVUcmFjayhcbiAgICAgICAgICAgIFwiLmJvbmVzW1wiICsgYm9uZURhdGEuYm9uZS5uYW1lICsgXCJdLnBvc2l0aW9uXCIsXG4gICAgICAgICAgICBib25lRGF0YS5wb3MudGltZXMsXG4gICAgICAgICAgICBib25lRGF0YS5wb3MudmFsdWVzXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29udmVydGVkVHJhY2tzLnB1c2goXG4gICAgICAgIG5ldyBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayhcbiAgICAgICAgICBcIi5ib25lc1tcIiArIGJvbmVEYXRhLmJvbmUubmFtZSArIFwiXS5xdWF0ZXJuaW9uXCIsXG4gICAgICAgICAgYm9uZURhdGEucXVhdC50aW1lcyxcbiAgICAgICAgICBib25lRGF0YS5xdWF0LnZhbHVlc1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBtaXhlci51bmNhY2hlQWN0aW9uKGNsaXApO1xuICByZXR1cm4gbmV3IEFuaW1hdGlvbkNsaXAoY2xpcC5uYW1lLCAtMSwgY29udmVydGVkVHJhY2tzKTtcbn1cbmZ1bmN0aW9uIGNsb25lKHNvdXJjZSkge1xuICBjb25zdCBzb3VyY2VMb29rdXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBjbG9uZUxvb2t1cCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGNsb25lMiA9IHNvdXJjZS5jbG9uZSgpO1xuICBwYXJhbGxlbFRyYXZlcnNlKHNvdXJjZSwgY2xvbmUyLCBmdW5jdGlvbihzb3VyY2VOb2RlLCBjbG9uZWROb2RlKSB7XG4gICAgc291cmNlTG9va3VwLnNldChjbG9uZWROb2RlLCBzb3VyY2VOb2RlKTtcbiAgICBjbG9uZUxvb2t1cC5zZXQoc291cmNlTm9kZSwgY2xvbmVkTm9kZSk7XG4gIH0pO1xuICBjbG9uZTIudHJhdmVyc2UoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5pc1NraW5uZWRNZXNoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNsb25lZE1lc2ggPSBub2RlO1xuICAgIGNvbnN0IHNvdXJjZU1lc2ggPSBzb3VyY2VMb29rdXAuZ2V0KG5vZGUpO1xuICAgIGNvbnN0IHNvdXJjZUJvbmVzID0gc291cmNlTWVzaC5za2VsZXRvbi5ib25lcztcbiAgICBjbG9uZWRNZXNoLnNrZWxldG9uID0gc291cmNlTWVzaC5za2VsZXRvbi5jbG9uZSgpO1xuICAgIGNsb25lZE1lc2guYmluZE1hdHJpeC5jb3B5KHNvdXJjZU1lc2guYmluZE1hdHJpeCk7XG4gICAgY2xvbmVkTWVzaC5za2VsZXRvbi5ib25lcyA9IHNvdXJjZUJvbmVzLm1hcChmdW5jdGlvbihib25lKSB7XG4gICAgICByZXR1cm4gY2xvbmVMb29rdXAuZ2V0KGJvbmUpO1xuICAgIH0pO1xuICAgIGNsb25lZE1lc2guYmluZChjbG9uZWRNZXNoLnNrZWxldG9uLCBjbG9uZWRNZXNoLmJpbmRNYXRyaXgpO1xuICB9KTtcbiAgcmV0dXJuIGNsb25lMjtcbn1cbmZ1bmN0aW9uIGdldEJvbmVCeU5hbWUobmFtZSwgc2tlbGV0b24pIHtcbiAgZm9yIChsZXQgaSA9IDAsIGJvbmVzID0gZ2V0Qm9uZXMoc2tlbGV0b24pOyBpIDwgYm9uZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobmFtZSA9PT0gYm9uZXNbaV0ubmFtZSlcbiAgICAgIHJldHVybiBib25lc1tpXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Qm9uZXMoc2tlbGV0b24pIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc2tlbGV0b24pID8gc2tlbGV0b24gOiBza2VsZXRvbi5ib25lcztcbn1cbmZ1bmN0aW9uIGdldEhlbHBlckZyb21Ta2VsZXRvbihza2VsZXRvbikge1xuICBjb25zdCBzb3VyY2UgPSBuZXcgU2tlbGV0b25IZWxwZXIoc2tlbGV0b24uYm9uZXNbMF0pO1xuICBzb3VyY2Uuc2tlbGV0b24gPSBza2VsZXRvbjtcbiAgcmV0dXJuIHNvdXJjZTtcbn1cbmZ1bmN0aW9uIHBhcmFsbGVsVHJhdmVyc2UoYSwgYiwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soYSwgYik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHBhcmFsbGVsVHJhdmVyc2UoYS5jaGlsZHJlbltpXSwgYi5jaGlsZHJlbltpXSwgY2FsbGJhY2spO1xuICB9XG59XG5jb25zdCBTa2VsZXRvblV0aWxzID0geyByZXRhcmdldCwgcmV0YXJnZXRDbGlwLCBjbG9uZSB9O1xuZXhwb3J0IHtcbiAgU2tlbGV0b25VdGlsc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNrZWxldG9uVXRpbHMuanMubWFwXG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIlF1YXRlcm5pb24iLCJNYXRyaXg0IiwiQW5pbWF0aW9uTWl4ZXIiLCJWZWN0b3JLZXlmcmFtZVRyYWNrIiwiUXVhdGVybmlvbktleWZyYW1lVHJhY2siLCJBbmltYXRpb25DbGlwIiwiU2tlbGV0b25IZWxwZXIiLCJyZXRhcmdldCIsInRhcmdldCIsInNvdXJjZSIsIm9wdGlvbnMiLCJwb3MiLCJxdWF0Iiwic2NhbGUiLCJiaW5kQm9uZU1hdHJpeCIsInJlbGF0aXZlTWF0cml4IiwiZ2xvYmFsTWF0cml4IiwicHJlc2VydmVNYXRyaXgiLCJwcmVzZXJ2ZVBvc2l0aW9uIiwicHJlc2VydmVIaXBQb3NpdGlvbiIsInVzZVRhcmdldE1hdHJpeCIsImhpcCIsIm5hbWVzIiwic291cmNlQm9uZXMiLCJpc09iamVjdDNEIiwic2tlbGV0b24iLCJib25lcyIsImdldEJvbmVzIiwiYmluZEJvbmVzIiwiYm9uZSIsIm5hbWUiLCJib25lVG8iLCJib25lc1Bvc2l0aW9uIiwicG9zZSIsImkiLCJsZW5ndGgiLCJwdXNoIiwicG9zaXRpb24iLCJjbG9uZSIsInVwZGF0ZU1hdHJpeFdvcmxkIiwibWF0cml4V29ybGQiLCJpZGVudGl0eSIsImNoaWxkcmVuIiwib2Zmc2V0cyIsIm1hdHJpeCIsIm11bHRpcGx5IiwiZGVjb21wb3NlIiwicXVhdGVybmlvbiIsImdldEJvbmVCeU5hbWUiLCJjb3B5IiwiaW52ZXJ0Iiwic2V0RnJvbU1hdHJpeFNjYWxlIiwic2V0IiwieCIsInkiLCJ6IiwibWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24iLCJzZXRGcm9tUm90YXRpb25NYXRyaXgiLCJib25lSW5kZXgiLCJpbmRleE9mIiwid0JpbmRNYXRyaXgiLCJib25lSW52ZXJzZXMiLCJjb3B5UG9zaXRpb24iLCJwYXJlbnQiLCJpc0JvbmUiLCJzZXRQb3NpdGlvbiIsInJldGFyZ2V0Q2xpcCIsImNsaXAiLCJ1c2VGaXJzdEZyYW1lUG9zaXRpb24iLCJmcHMiLCJnZXRIZWxwZXJGcm9tU2tlbGV0b24iLCJudW1GcmFtZXMiLCJNYXRoIiwicm91bmQiLCJkdXJhdGlvbiIsImRlbHRhIiwiY29udmVydGVkVHJhY2tzIiwibWl4ZXIiLCJib25lRGF0YXMiLCJwb3NpdGlvbk9mZnNldCIsImJvbmVEYXRhIiwiY2xpcEFjdGlvbiIsInBsYXkiLCJ1cGRhdGUiLCJ0aW1lIiwiaiIsInRpbWVzIiwiRmxvYXQzMkFycmF5IiwidmFsdWVzIiwic3ViIiwidG9BcnJheSIsInVuY2FjaGVBY3Rpb24iLCJzb3VyY2VMb29rdXAiLCJNYXAiLCJjbG9uZUxvb2t1cCIsImNsb25lMiIsInBhcmFsbGVsVHJhdmVyc2UiLCJzb3VyY2VOb2RlIiwiY2xvbmVkTm9kZSIsInRyYXZlcnNlIiwibm9kZSIsImlzU2tpbm5lZE1lc2giLCJjbG9uZWRNZXNoIiwic291cmNlTWVzaCIsImdldCIsImJpbmRNYXRyaXgiLCJtYXAiLCJiaW5kIiwiQXJyYXkiLCJpc0FycmF5IiwiYSIsImIiLCJjYWxsYmFjayIsIlNrZWxldG9uVXRpbHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/utils/SkeletonUtils.js\n");

/***/ })

};
;